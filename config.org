#+SETUPFILE: ~/Org/common.setup
#+AUTHOR: Ihor Radchenko
#+EMAIL: yantar92@gmail.com
#+PROPERTY: header-args+ :tangle yes :comments link

* NEXT Emacs configuration                                     :EMACS:COMMON:
:PROPERTIES:
:ID:       a27092a6-25a6-417f-818f-7f83325b58b3
:ORG-TIME-BALANCE-MULTIPLIER: -0.5
:END:
:LOGBOOK:
- State "NEXT"       from "NEXT"       [2018-09-06 Thu 21:10]
CLOCK: [2018-07-23 Mon 00:16]--[2018-07-23 Mon 00:23] =>  0:07
- State "NEXT"       from "NEXT"       [2018-07-11 Wed 18:17]
- State "NEXT"       from "NEXT"       [2018-07-09 Mon 21:47]
- State "NEXT"       from "NEXT"       [2018-01-01 Mon 13:17]
CLOCK: [2017-12-30 Sat 22:19]--[2017-12-30 Sat 22:24] =>  0:05
CLOCK: [2017-12-30 Sat 17:03]--[2017-12-30 Sat 17:14] =>  0:11
- State "NEXT"       from "NEXT"          [2017-12-29 Fri 23:14]
CLOCK: [2017-12-28 Thu 18:41]--[2017-12-28 Thu 18:42] =>  0:01
CLOCK: [2017-12-28 Thu 17:59]--[2017-12-28 Thu 18:40] =>  0:41
:END:

#+begin_src emacs-lisp
(setf user-full-name "Ihor Radchenko")
#+end_src
This Emacs configuration allows to load Emacs in both interactive and batch modes. It is controlled by special variables, identifying startup mode:
- =init-flag= :: normal startup, load all the visual packages and options
- =org-export-flag= :: load necessary options for org-export
- =org-tangle-flag= :: load necessary options for org-tangle
     One important note about this configuration is that I do not use desktop save mode and similar things. I do it because everything I intend to do is kept in my org files, which are automatically loaded by org agenda command. 
#+begin_src emacs-lisp
(defvar init-flag nil
  "Do normal init if not nil.")
(defvar org-export-flag nil
  "Set up org export if not nil.")
(defvar org-tangle-flag nil
  "Set up org tangle if not nil.")
#+end_src
** =Init.el=
:PROPERTIES:
:ID:       0948a927-42a3-4284-aaed-1ca9dd27a538
:CREATED:  [2017-12-23 Sat 15:16]
:END:
Init file, which is loads this file.
#+begin_src emacs-lisp :tangle "init.el"
;;(package-initialize)
(setq init-flag t)
(byte-compile-file "~/.emacs.d/config.el" 'load)
#+end_src
** NEXT Debugging current issues
:PROPERTIES:
:CREATED:  [2019-04-03 Wed 10:42]
:ID:       d7431e10-411b-456f-ab6e-76aa07300712
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2019-04-03 Wed 10:42]
- State "TODO"       from              [2019-04-03 Wed 10:42]
:END:

Trying to debug "Re-entering top level after C stack overflow", as suggested in [[https://www.reddit.com/r/emacs/comments/9fs8pp/reentering_top_level_after_c_stack_overflow/][reddit]]
#+begin_src emacs-lisp
(setq max-lisp-eval-depth 6000
      max-specpdl-size 6000)
#+end_src

** Emacs server settings
:PROPERTIES:
:ID:       5d8e1dca-a849-4980-bfde-cbf02801e92b
:END:
- ensure one server instance 
  #+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
  #+end_src
- run server silently
  - ignore file clashes ([[https://www.reddit.com/r/emacs/comments/733698/if_a_file_has_changed_on_disk_save_anyway_without/][reddit]])
    #+begin_src emacs-lisp
(defun ask-user-about-supersession-threat (args)
  "Ignore file clashes.")
    #+end_src
  - do not show large file warnings
    #+begin_src emacs-lisp
(setq large-file-warning-threshold nil)
    #+end_src
- exit server silently
  #+begin_src emacs-lisp
(add-hook 'kill-emacs-hook '(lambda() (save-some-buffers 'save-all-buffers)) 'append)
  #+end_src
- disable =kill-emacs= 
  I start emacs as a daemon on system startup. Hence, I need to stop
  or start it as daemon, not using =kill-emacs=
  #+BEGIN_SRC emacs-lisp
(put 'kill-emacs 'disabled t)
  #+END_SRC
** Performance 
:PROPERTIES:
:CREATED:  [2018-09-12 Wed 19:48]
:ID:       45c70cb5-df2f-4e86-8ccd-42c1881a7dbf
:END:
Elisp is not the fastest language in the world. 
There are various options, which can improve the performance.

- Bidirectional text is not something I use frequently (never used up until writing this)
#+BEGIN_SRC emacs-lisp
(setq bidi-display-reordering nil)
#+END_SRC

** Package management & configuration
:PROPERTIES:
:ID:       4c0a06f9-9e69-4ead-b570-e3143fa0d61d
:END:
#+NAME: package-archives-table
| Name  | URL                           |
|-------+-------------------------------|
| MELPA | https://melpa.org/packages/    |
| ELPA  | http://tromey.com/elpa/       |
| gnu   | http://elpa.gnu.org/packages/ |
| org   | http://orgmode.org/elpa/      |

#+NAME: parse-package-archives-table 
#+BEGIN_SRC emacs-lisp :tangle no :var packages=package-archives-table
(mapcar (lambda(el) (cons (car el) (cadr el))) packages)
#+END_SRC

#+begin_src emacs-lisp :noweb yes
(eval-and-compile
  (require 'package)
  (setq package-archives '<<parse-package-archives-table()>>
	load-prefer-newer t
	package-user-dir "~/.emacs.d/elpa/"
	package--init-file-ensured t
	package-enable-at-startup nil)
  (unless (file-directory-p package-user-dir)
    (make-directory package-user-dir t))
  (setq load-path (append '("~/.emacs.d/site-lisp/") load-path))
  (setq load-path (append (directory-files "~/.emacs.d/site-lisp/" t "^[^.]" t) load-path))
  (setq load-path (append (directory-files package-user-dir t "^[^.]" t) load-path))
  ;; (add-hook 'after-init-hook #'package-initialize)
  ;; (package-initialize 'NO-ACTIVATE)
  (package-initialize)
  )
#+end_src

- enforce =use-package=
  #+begin_src emacs-lisp
(eval-and-compile
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package)))
(eval-when-compile
  (require 'use-package))
(use-package diminish :ensure t)
(require 'bind-key)
  #+end_src
- automatically update packages on startup
  #+begin_src emacs-lisp
    (use-package auto-package-update
      :ensure t
      :config
      (setq auto-package-update-delete-old-versions t)
      (add-hook 'window-setup-hook #'auto-package-update-maybe))
  #+end_src
- prefer setting in this file over customized interface
  #+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(load custom-file)
  #+end_src
** Appearance
:PROPERTIES:
:ID:       5b50a90f-4f47-4244-a6ac-e3646464539d
:END:
*** Theme
**** =Flatui=
:PROPERTIES:
:ID:       404c54f5-26eb-4ada-8a0f-c27efc714238
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-10-08 Sun 11:58]
:END:
#+begin_src emacs-lisp
(use-package flatui-theme
  :if init-flag
  :ensure t
  :config
  (load-theme 'flatui t))
#+end_src
- I want Source Code Pro default everywhere
  #+begin_src emacs-lisp
(when init-flag
  (custom-set-faces '(default ((t (:inherit nil
					    :stipple nil
					    :inverse-video nil
					    :box nil
					    :strike-through nil
					    :overline nil
					    :underline nil
					    :slant normal
					    :weight normal
					    :height 100
					    :width normal
					    :foundry "adobe"
					    :family "source code pro"))))))
  #+end_src
- Secondary selection is the same color with some symbols in =org-agenda=
#+BEGIN_SRC emacs-lisp
(set-face-background 'secondary-selection "#aae59c")
#+END_SRC
*** No startup message
:PROPERTIES:
:ID:       5450bef9-a57a-4afb-85f3-893dbcb5f4ba
:END:
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src
*** Frame
**** No tool bar
:PROPERTIES:
:ID:       1d4d5272-e727-46cf-ac51-8c9aeeebdf53
:END:
#+begin_src emacs-lisp
(tool-bar-mode -1)
#+end_src
**** No scroll bar
:PROPERTIES:
:ID:       e0716fb4-11ac-4375-a3eb-45a73b7ace64
:END:
#+begin_src emacs-lisp
(scroll-bar-mode -1)
#+end_src
**** No menu bar
:PROPERTIES:
:CREATED:  [2018-06-30 Sat 13:00]
:ID:       b872aea3-5707-47c3-bcdf-ace4959a253a
:END:
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC
**** Divider between windows
:PROPERTIES:
:CREATED:  [2018-10-14 Sun 00:25]
:ID:       570c813d-fc52-4c6c-bdb3-1c3ba55f93e6
:END:
#+BEGIN_SRC emacs-lisp
(setq window-divider-default-places t
      window-divider-default-bottom-width 2
      window-divider-default-right-width 2)
(window-divider-mode +1)
#+END_SRC
**** Buffer arrangement
:PROPERTIES:
:CREATED:  [2019-04-24 Wed 00:02]
:END:
**** Remove useless gap in maximised state 
:PROPERTIES:
:CREATED:  [2019-04-27 Sat 16:39]
:ID:       1229776a-39f3-4d41-b800-8a6a445169d3
:END:
#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
#+end_src
*** Buffer
**** Centered window mode
:PROPERTIES:
:ID:       af9c7d6c-fd15-4d68-b379-3d439ea94370
:END:
My screen is too wide to read text comfortably. I am not very comfortable with =auto-fill-mode=, so I prefer to limit the buffer width.
#+begin_src emacs-lisp
(use-package centered-window
  :if init-flag
  :diminish centered-window-mode
  :config
  (defun pdf-view-mode-p (&rest args)
    "Return non-nil if in pdf-view-mode."
    (eq major-mode 'pdf-view-mode))
  (add-to-list 'cwm-ignore-buffer-predicates 'pdf-view-mode-p)
  (use-package boon 
    :config
    (bind-keys :map boon-x-map ("w" . centered-window-mode)))
  (centered-window-mode +1))
#+end_src
**** TODO Long lines handling
:PROPERTIES:
:ID:       827dc236-fee4-43b8-bfbe-05026d7e3e6d
:CREATED:  [2019-03-20 Wed 12:07]
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:24]
:END:
#+begin_src emacs-lisp
(when init-flag
  (bind-keys :map boon-x-map ("l" . toggle-truncate-lines)))
(setq-default truncate-lines 't
	      word-wrap 't)
#+end_src
**** Buffer boundaries
:PROPERTIES:
:ID:       00975142-2491-4f85-bd0b-f1f6c2938e36
:END:

#+begin_src emacs-lisp
(setq-default indicate-buffer-boundaries 'left)
#+end_src
*** Text in buffers
**** Coding system
:PROPERTIES:
:ID:       07c3544a-bcbd-4790-815a-25615ca2ca03
:END:
- prefer UTF
  #+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
  #+end_src
**** Visual text transformation
Show some text in buffer differently
***** Page break shown as lines
:PROPERTIES:
:ID:       6c1e16d6-7f4e-41e5-99a8-13fac4eab2a3
:END:
#+begin_src emacs-lisp
(use-package page-break-lines
  :if init-flag
  :ensure t
  :diminish page-break-lines-mode
  :config (global-page-break-lines-mode))
#+end_src
***** TODO Pretty symbols
:PROPERTIES:
:ID:       315191d1-6edf-4c10-a1fe-0fb70885fbe1
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:26]
- State "HOLD"       from              [2018-03-04 Sun 17:57]
:END:
#+begin_src emacs-lisp
(use-package pretty-symbols
  :disabled t
  :if init-flag
  :diminish pretty-symbols-mode
  :ensure t
  :after org
  :hook ((pretty-symbols-mode . font-lock-fontify-buffer)
	 ((prog-mode org-mode) . pretty-symbols-mode))
  :init
  (setq pretty-symbol-categories '(relational logical lambda org-specific nil cpp general))

  (defun yant/str-to-glyph (str)
    "Transform string into glyph, displayed correctly."
    (let ((composition nil))
      (dolist (char (string-to-list str)
		    (nreverse (cdr composition)))
	(push char composition)
	(push '(Br . Bl) composition)
	)))

  (setq pretty-symbol-patterns  (let ((lisps '(emacs-lisp-mode
					       inferior-lisp-mode
					       inferior-emacs-lisp-mode
					       lisp-mode scheme-mode))
				      (c-like '(c-mode
						c++-mode go-mode java-mode js-mode
						perl-mode cperl-mode ruby-mode
						python-mode inferior-python-mode)))
				  `(
				    ;; Basic symbols, enabled by default
				    (?λ lambda "\\<lambda\\>" (,@lisps python-mode inferior-python-mode))
				    (?ƒ lambda "\\<function\\>" (js-mode))
				    ;; general symbols, which can be applied in most of the modes
				    ;; Relational operators --
				    ;; enable by adding 'relational to `pretty-symbol-categories'
				    (?≠ relational "\\(!=\\)" (,@c-like org-mode) 1)
				    (?≠ relational "\\(/=\\)" (,@lisps) 1)
				    (?≥ relational "\\(>=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≤ relational "\\(<=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≔ relational "[^=]\\(=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≡ relational "\\(==\\)" (,@c-like ,@lisps org-mode) 1)
				    (?↠ cpp ">>" (c++-mode))
				    (?↞ cpp "<<" (c++-mode))
				    (?⇢ cpp "->" (c++-mode))
				    (?⋮ cpp "::" (c++-mode))
				    (?⏎ cpp "\\<endl\\>" (c++-mode))
				    (?∞ cpp "\\<INF\\>" (c++-mode))
				    (?⇰ cpp "\\<return\\>" (c++-mode))
				    (?↹ cpp "\\(\\\\t\\) " (,@c-like ,@lisps org-mode))
				    ;; Logical operators
				    (?∧ logical "&&" (,@c-like org-mode))
				    (?∨ logical "||" (,@c-like org-mode))
				    ;;(?¬ logical "\\<!\\>" (,@c-like)) ; TODO: Fix regex so that ! matches
					; but != doesn't. (\< and \> don't work
					; because ! isn't considered part of
					; a word). This will require support
					; for subgroups and not replacing the
					; whole match.
				    (?¬ logical "(\\<\\(not\\)\\>" (,@lisps) 1)
				    (?∅ nil "\\<nil\\>" (,@lisps))
				    ))))

#+end_src
***** Latex pretty symbols
:PROPERTIES:
:ID:       bdf24c4b-681c-4286-86cd-e81f63b94ec0
:END:
#+begin_src emacs-lisp 
(use-package latex-pretty-symbols
  :if init-flag
  :ensure t
  :config
  (global-prettify-symbols-mode t))
#+end_src
*** TODO Mode line
:PROPERTIES:
:ID:       ca75c464-f35c-43ed-a90e-d78d4cfaa99a
:END:
:LOGBOOK:
- State "TODO"       from              [2018-09-05 Wed 08:57]
:END:
- =Powerline= + =smart-mode-line=
  - triangular arrow shape
  - set the foreground manually because =boon-powerline= default background is not good with [[id:404c54f5-26eb-4ada-8a0f-c27efc714238][Flatui]]
    #+begin_src emacs-lisp
(use-package powerline
  :if init-flag
  :ensure t
  :config
  ;; (powerline-vim-theme)
  (use-package smart-mode-line
    :ensure t
    :config
    (setq powerline-arrow-shape 'arrow14)
    (sml/setup)))

(use-package spaceline
  :ensure t
  :init
  (setq powerline-default-separator 'arrow-fade
        spaceline-minor-modes-separator " ")
  (require 'spaceline-config)
  ;; (spaceline-emacs-theme)
  (spaceline-helm-mode))

    #+end_src
- Show column numbers
  #+begin_src emacs-lisp
(setf column-number-mode t)
  #+end_src
- Show total lines
  #+begin_src emacs-lisp
(setf size-indication-mode t)
  #+end_src
- Show boon state
  #+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package boon-powerline
    :config
    (custom-set-faces '(mode-line-inactive ((t (:background "#dfe4ea" :foreground "dim gray" :box nil)))))
    (set-face-foreground 'boon-modeline-cmd "white")
    (set-face-foreground 'boon-modeline-ins "white")
    (set-face-foreground 'boon-modeline-spc "white")
    (set-face-foreground 'boon-modeline-off "white")
    (boon-powerline-theme)))
  #+end_src
*** Minibuffer
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:29]
:END:
**** =Eldoc= show various info in minibuffer
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:29]
:ID:       461cf4e2-bcb0-4166-bdf0-fe437d352417
:END:

#+begin_src emacs-lisp 
(when init-flag
(global-eldoc-mode)
(diminish 'eldoc-mode)
(mapc #'eldoc-add-command '(meta-up meta-up-element meta-down meta-down-element meta-backward meta-backward-element meta-forward meta-forward-element meta-scroll-down meta-scroll-up self-insert-command)))
#+end_src

*** Cursor
**** COMMENT Highlight cursor when it moves far
:PROPERTIES:
:ID:       c86d4d84-aa19-43e8-990a-6305db525433
:END:
=beacon-mode= seems to slow down the org movement like =c u=.
#+begin_src emacs-lisp :tangle no
(use-package beacon
  :if init-flag
  :ensure t
  :diminish beacon-mode
  :config
  (beacon-mode 1))
#+end_src
**** Highlight current line 
:PROPERTIES:
:ID:       f90676cb-1c8a-47c1-b539-debcf961d912
:END:
#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src
**** Cursor color
:PROPERTIES:
:CREATED:  [2018-10-11 Thu 22:39]
:ID:       727818b2-7362-4772-b461-08fa3ce82450
:END:

#+BEGIN_SRC emacs-lisp
(set-cursor-color "IndianRed")
#+END_SRC

** Command loop
:PROPERTIES:
:ID:       ff7a4c41-d457-4a90-bcb9-4f653af48ff4
:END:
*** Dialogues
:PROPERTIES:
:ID:       b1e1c83a-18be-4c5c-bd77-970a0a163b72
:END:
- enforce =y-or-n-p= everywhere
- do not use graphical dialogues
  #+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
  #+end_src
*** Key bindings
At some point, a got very annoyed about distance between =C-n=, =C-p=,
=C-f=, and =C-b= and did not want to move my hand all the way to arrow
keys. So, I use modal editing  now, which allows me to move around
using the keys, which are close to each other. 
**** Modal setup
:PROPERTIES:
:ID:       0fe0bca3-fb51-4e0c-8b35-79a5e92975d6
:END:
Do not use =self-insert-command= by default, but bind character keys to navigation, selection, etc.
I use [[https://github.com/jyp/boon][boon]] package for this purpose.
- it is bad idea to enable boon insert mode in special buffers, so it has =special mode= with limited redefined key binding by default. This mode replaces normal =insert mode= 
- I add extra functionality for the case when =special mode= or =command mode= should not be enabled by default --- the buffer requires a lot of writing (I mean shell buffers, for example). This is defined by =boon-insert-state-major-mode-list= where the default mode is =insert mode=.
- =boon-special-mode= is frequently useful in all kinds of major modes, like debug, org-agenda, notmuch, etc. However, many major modes use the conventional movement key bindings or their derivatives (like "n" and "p" in =org-agenda=). I do not like it. I prefer to have some minimal [[id:46fb459b-7794-4b9a-9fce-85389aba1d95][set]] of movement keys working in all the buffers. It means, that I need to redefine the movement commands to be able to act according to the major mode (like "n" from org-mode is binded to =org-next-line= and, hence, "j" from =org-special-map= should be also bound to =org-next-line=.
  This can be done using meta-function approach when I use the function, which acts differently depending on the mode, while keeping the same general idea of the behavior.

#+BEGIN_SRC emacs-lisp
(use-package boon
  :defer t
  :config
  (set-keymap-parent boon-special-map boon-moves-map))
#+END_SRC

#+begin_src emacs-lisp :tangle ~/Git/meta-functions/meta-functions.el
  ;;; meta-functions.el --- Define meta-functions to act differently depending on major mode -*- lexical-binding: t; -*-

;; Version: 1.0
;; Author: Ihor Radchenko <yantar92@gmail.com>
;; Created: 10 March 2018

  ;;; Commentary:

;; Quick implementation of meta-functions, which allows to run multiple
;; functions, which do similar logical operations by one single "meta"
;; function in different major modes. For example, one may want to define
;; meta-next-line to call `next-line' normally, but
;; `org-agenda-next-line' in org-agenda mode. Both can be binded to, say
;; "M-j", without a need to change the key-bindings on both fundamental
;; and org-agenda modes.
;; Example usage:
;; (use-package meta-functions
;;   :init
;;   (setq meta-funcions-list '((meta-function-1 default-function-1 "Description") (meta-function-2 default-function-2  "description")))
;;   (setq meta-functions-meta-function-1-alist '((major-mode-1 . function-1)))
;;   )
;; This will define meta-function-1 and meta-function-2 to automatically
;; choose the right real functions depending on the major mode.

;;; Code:

(defvar meta-functions-list '()
  "A list of meta function names, corresponding functions to be called by default, and their description.
Each function may have meta-functions-metafunctionname-alist variable containing pairs of major mode names
and corresponding function to be called by meta-function in that major mode.
The default functions will be called if the major mode is not in the alist")

(defun meta-functions-add-meta-function (&rest args)
  "Add meta function or a list of metafunctions as in `meta-functions-list' and update the definitions."
  (setq meta-functions-list (append meta-functions-list args))
  (meta-functions-update-function-definitions))

(defun meta-functions-update-function-definitions ()
  "Update definitions of all the meta-functions according the present value of `meta-functions-list'."
  (mapc (lambda (elem)
	  (let* ((meta-func (car elem))
		 (default-func (cadr elem))
		 (meta-func-description (or (car (nthcdr 2 elem))
					    ""))
		 (func-alist (read (concat "meta-functions-" (format "%s" `,meta-func) "-alist"))))
	    (eval `(defvar ,func-alist '()
		     ,(concat "List of functions to be called by `"
			      (format "%s" meta-func)
			      "'.\nIt is an alist containing cons of major mode name and function name to be called.")))
	    (eval `(defun ,meta-func (&optional args)
		     ,(concat "Meta function."
			      (if (not (seq-empty-p meta-func-description))
				  (concat " The description is: \""
					  meta-func-description
					  "\"."))
			      "\nMeta function is calling `"
			      (format "%s" default-func)
			      "' by default."
			      (and (not (seq-empty-p (eval func-alist)))
				   (concat "\nCalling other functions in various major modes (major-mode . functions):\n"
					   (mapconcat (lambda(elem) (message "%s . `%s'" (car elem) (cdr elem))) (eval func-alist) "\n")
					   )))
		     (interactive)
		     (let ((real-func
			    (or (alist-get major-mode ,func-alist ',default-func)
				',default-func)))
		       (when (fboundp real-func)
			 (call-interactively real-func nil args)))))))
	meta-functions-list))

(meta-functions-update-function-definitions)

(provide 'meta-functions)

  ;;; meta-functions.el ends here
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :demand t)
#+END_SRC

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (meta-functions-add-meta-function '(meta-down next-logical-line "Move down.")
				    '(meta-up previous-logical-line "Move up.")
				    '(meta-down-element forward-paragraph "Move down one element.")
				    '(meta-up-element backward-paragraph "Move up one element.")
				    '(meta-forward forward-char "Move forward.")
				    '(meta-backward backward-char "Move backward.")
				    '(meta-forward-element forward-word "Move forward one element.")
				    '(meta-backward-element backward-word "Move backward one element.")
				    '(meta-scroll-up scroll-up "Scroll up.")
				    '(meta-scroll-down scroll-down "Scroll down.")
				    '(meta-undo undo "Undo.")
				    '(meta-occur helm-occur "Occur.")
				    '(meta-goto helm-imenu "Goto place in document.")
				    '(meta-next-buffer next-buffer "Go forward in buffer.")
				    '(meta-previous-buffer previous-buffer "Go backward in buffer.")
				    '(meta-insert-enclosure-new-line ignore "Insert beg/end passive structure in the line below.")
				    '(meta-insert-active-enclosure-new-line ignore "Isert beg/end active structure in the line below.")
				    '(meta-new-line boon-newline-dwim "Insert new line."))
  )
#+end_src

It should be noted, that the same can be done via setting the proper bindings for "j", "k", etc. in the mode itself. The problem is that it may mess up the cases when want to set special meanings for the single keys in =command-mode=, but leave the normal editing on in the =insert-mode=.
  
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :ensure t
  :diminish boon-local-mode
  :init
  (use-package magit)
  :config
  (setq boon-special-mode-list
	'(debugger-mode edebug-mode ediff-mode org-agenda-mode cfw:calendar-mode
			notmuch-search-mode notmuch-show-mode elfeed-search-mode
			elfeed-show-mode pomidor-mode mingus-mode
			notmuch-hello-mode ledger-report-mode help-mode
			dired-mode pdf-view-mode helpful-mode magit-file-mode
			magit-status-mode magit-revision-mode
			mingus-playlist-mode mingus-browse-mode
			mingus-help-mode))
  (defvar boon-insert-state-major-mode-list '()
    "List of major modes started with insert state active.")
  (setq boon-insert-state-major-mode-list
	'(notmuch-message-mode eshell-mode shell-mode calc-mode term-mode
			       magit-popup-mode))
  (add-hook 'boon-local-mode-hook
	    (lambda() (when (and boon-local-mode
			    (member major-mode boon-insert-state-major-mode-list))
		   (boon-set-state 'boon-insert-state)))
	    'append)
  (defun boon-set-insert-state ()
    "Switch to insert state."
    (boon-set-state 'boon-insert-state))
  (use-package boon-qwerty)
  (boon-mode))
#+end_src

Also, I do not like default implementation of =boon-special-mode-p=, which force setting special mode for terminal-modes. I prefer to rewrite it
#+BEGIN_SRC emacs-lisp
(use-package boon
  :defer t
  :config
  (define-advice boon-special-mode-p (:around (oldfun) force-special-mode-list-only)
    "Force setting boon-special-mode when mode is in `boon-special-mode-list' and only in it. No exceptions."
    (memq major-mode boon-special-mode-list)))
#+END_SRC
**** Hydra
:PROPERTIES:
:CREATED:  [2017-12-31 Sun 08:36]
:ID:       8ad95362-807a-457d-8b59-32e83a350c18
:END:
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  )
#+END_SRC
**** Ignore some system keybindings, which are used in my WM (annoying unknown keybinding error)
:PROPERTIES:
:ID:       af77c219-c181-4534-bdfc-325616965ddc
:END:
#+begin_src emacs-lisp
(global-set-key (kbd "<XF86MonBrightnessUp>") #'ignore)
(global-set-key (kbd "<XF86MonBrightnessDown>") #'ignore)
(global-set-key (kbd "S-_") #'ignore)
(global-set-key (kbd "S-)") #'ignore)
(global-set-key (kbd "S-I") #'ignore)
(global-set-key (kbd "S-y") #'ignore)
(global-set-key (kbd "S-u") #'ignore)
(global-set-key (kbd "S-w") #'ignore)
#+end_src
**** Disable some keybinding, which interfere with my setup (easy to press by mistake)
:PROPERTIES:
:CREATED:  [2018-09-25 Tue 20:22]
:ID:       c952de1f-b5f9-4238-b01e-ff0870159694
:END:
#+BEGIN_SRC emacs-lisp
(bind-key "M-u" #'ignore global-map)
(bind-key "M-k"  #'ignore global-map)
#+END_SRC
**** Make key bindings work in Ukrainian/Russian =keymap=
:PROPERTIES:
:ID:       943917fe-aecf-45a7-bc0d-591492d17898
:END:
#+begin_src emacs-lisp
(use-package reverse-im :ensure t
	     :if init-flag
	     :config
	     (reverse-im-activate "russian-computer"))
;; (when init-flag
;;   (cl-loop
;;    for from across "йцукенгшщзхїфівапролджєячсмитьбюЙЦУКЕНГШЩЗХЇФІВАПРОЛДЖЄЯЧСМИТЬБЮ№"
;;    for to   across "qwertyuiop[]asdfghjkl;'zxcvbnm,.QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>#"
;;    do
;;    (eval `(define-key local-function-key-map
;; 	    (kbd ,(concat "C-"
;; 			  (string from)))
;; 	    (kbd ,(concat "C-"
;; 			  (string to)))))
;;    (eval `(define-key local-function-key-map
;; 	    (kbd ,(concat "M-"
;; 			  (string from)))
;; 	    (kbd ,(concat "M-"
;; 			  (string to)))))
;;    (eval `(define-key local-function-key-map
;; 	    (kbd ,(concat "C-M-"
;; 			  (string from)))
;; 	    (kbd ,(concat "C-M-"
;; 			  (string to)))))
;;    (eval `(define-key local-function-key-map
;; 	    (kbd ,(string from))
;; 	    (kbd ,(string to))))))
#+end_src
***** TODO Make it work everywhere
- +This does not work with things like =C-c 'symbol= for now.+
- +This does not work with boon =command mode= and =special mode=.+
- this does not work with key chords (again read-event)
- this does not work with region specifiers on boon (it uses read-event!)
** Completion 
:PROPERTIES:
:ID:       f78e9123-ed35-4c76-a5fd-5549cc8f8210
:END:
*** Helm 
:PROPERTIES:
:ID:       d388e4f5-214e-4697-a53a-be6fb6c24411
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :ensure t
  :diminish helm-mode
  :bind (
	 ("M-x" . helm-M-x)
	 ("M-y" . helm-show-kill-ring)
	 ("<f1> a" . helm-apropos)
         ("C-x c" . nil)
	 :map helm-map
	 ("C-M-y" . helm-yank-selection)
	 ("M-j" . helm-next-line)
	 ("M-k" . helm-previous-line)
	 ("M-o" . helm-next-source)
	 ("M-i" . helm-previous-source)
	 ("M-l" . helm-execute-persistent-action)
	 ("C-u" . helm-execute-persistent-action)
	 ("C-M-h" . backward-kill-word)
	 ("M-h" . backward-kill-word)
	 ("C-h" . backward-delete-char-untabify)
	 :map helm-find-files-map
	 ("M-l" . nil)
         :map boon-goto-map
         ("e" . helm-resume)
	 )
  :defines helm-global-mode
  :config
  (use-package helm-config)
  (use-package helm-files)
  (use-package helm-command)
  (setq helm-input-idle-delay 0.01
	helm-exit-idle-delay 0
	helm-M-x-requires-pattern nil
	helm-split-window-inside-p           t ; open helm buffer inside current window, not occupy whole other window
	helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	helm-ff-file-name-history-use-recentf t)
  (define-global-minor-mode helm-global-mode helm-mode
    (lambda()
      (helm-mode 1)))
  (helm-global-mode))
#+end_src
*** Company
:PROPERTIES:
:ID:       8ca3a911-ad9d-43a6-83a6-a7b12b383984
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-09-22 Fri 07:58]
:END:
#+begin_src emacs-lisp
(use-package company
  :if init-flag
  :ensure t
  :diminish company-mode
  :hook ((prog-mode ledger-mode) . company-mode)
  :bind (
	 ("M-/" . company-complete)
	 ("C-/" . hippie-expand)
	 :map company-active-map
	 ("M-j" . company-select-next)
	 ("M-k" . company-select-previous)
	 ("C-h" . backward-delete-char-untabify)
         ("C-M-h" . backward-kill-word)
         ("M-l" . nil)
         ("M-h" . company-show-doc-buffer))
  :init
  (setq company-idle-delay 0
	company-minimum-prefix-length 2))
#+end_src
*** TODO Skeleton
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 14:28]
:END:
:LOGBOOK:
- State "TODO"       from              [2018-10-21 Sun 14:28]
:END:
** History & version control
:PROPERTIES:
:ID:       a76e7822-8153-4adc-a3f8-8f05588eff5e
:END:
*** Save buffer key binding
:PROPERTIES:
:ID:       21a8d99d-3f19-48d8-8f50-bfa9e139dbbc
:END:
Boon =command mode= allows to translate =c 'symbol= key bindings into =C-c
'symbol= key bindings. It is useful, but =save-buffer= is more meaningful
to rebind to =C-c s= is such a case and =save-some-buffers= to =C-c C-s=. 
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (bind-key "C-x s" 'save-buffer)
  (bind-key "C-x C-s" 'save-some-buffers))
#+end_src
*** Backup
:PROPERTIES:
:ID:       e9322c07-68fa-485f-abac-af5b5a2b97f5
:END:
#+begin_src emacs-lisp
(setq
 backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
 backup-by-copying t
 delete-old-versions t
 kept-new-versions 100000
 kept-old-versions 100000
 version-control t
 create-lockfiles nil
 )
#+end_src
*** Auto save
:PROPERTIES:
:ID:       2e32ad16-4c7a-46b9-8c47-06f7f5566032
:END:
#+begin_src emacs-lisp
(setq  auto-save-file-name-transforms `((".*"  "~/.emacs.d/auto-save/" t))
       auto-save-interval 20)
#+end_src
- Save virtual buffers (kill ring, etc.)
  #+begin_src emacs-lisp
(savehist-mode 1)
  #+end_src
*** TODO Never save some buffers
:PROPERTIES:
:ID:       7d188a71-560a-4d37-8037-2f2e44726a06
:END:
I got an issue with =org-src= block editing buffers. They are saved
under some weird name beside the actual org file when some command,
saving all the buffers, is executed. 
#+begin_src emacs-lisp 
(defvar yant/never-save-buffer-list nil
  "The buffers, matching any of the regexps in this list will never be saved.")
#+end_src
*** FAILED Undo tree
CLOSED: [2019-04-03 Wed 10:40]
:PROPERTIES:
:ID:       85e15d5a-65f0-4283-93e4-7997fe9fa1a3
:END:
:LOGBOOK:
- State "FAILED"     from              [2019-04-03 Wed 10:40]
:END:
#+begin_src emacs-lisp
(use-package undo-tree
  :if init-flag
  :ensure t
  :disabled t
  ;;:diminish undo-tree-mode
  :hook ((org-mode text-mode prog-mode) .  undo-tree-mode)
  :config
  (setq
   undo-tree-auto-save-history t
   undo-tree-visualizer-diff t
   undo-tree-visualizer-timestamps t
   undo-tree-history-directory-alist '((".*" . "~/.emacs.d/undo"))
   undo-tree-enable-undo-in-region nil ; workaround to fix random error thrown by undo "Unrecognized entry in undo list undo-tree-canary" (unresolved undo-tree bug)
   ))
#+end_src
*** Persistent scratch
:PROPERTIES:
:ID:       4185d833-9d1f-4763-97a0-d44bcc322da7
:END:
#+begin_src emacs-lisp
(use-package  persistent-scratch
  :if init-flag
  :ensure t
  :config
  (persistent-scratch-autosave-mode 1)
  )
#+end_src
*** Recent files
:PROPERTIES:
:ID:       b72d24a2-7692-4e37-b547-10c30b058c22
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :bind ("C-x r" . helm-recentf)
  :config
  (recentf-mode t)
  (setq
   recentf-max-menu-items 30
   recentf-max-saved-items 100
   helm-ff-file-name-history-use-recentf t))
#+end_src
*** No global auto-revert
:PROPERTIES:
:ID:       b4f4fbea-9315-412c-bb48-6984906c67d8
:END:
#+begin_src emacs-lisp 
(global-auto-revert-mode -1)
(setq revert-without-query '(".*"))
(bind-key* "M-r" #'revert-buffer)
#+end_src
*** Magit
:PROPERTIES:
:CREATED:  [2018-08-11 Sat 20:47]
:ID:       6e9f1b1e-bcd9-4927-894f-7a3ff773fb8c
:END:
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :if init-flag
  :init
  (setq vc-handled-backends nil)
  (use-package transient :ensure t)
  :config
  (use-package boon :config
    (bind-keys :map boon-x-map
	       ("g" . magit-status)
	       ("G" . magit-dispatch-popup)
	       ("M-g" . magit-file-popup))
    (use-package meta-functions
      :config
      (meta-functions-update-function-definitions)
      (add-to-list 'meta-functions-meta-down-element-alist '(magit-status-mode . magit-section-forward))
      (add-to-list 'meta-functions-meta-up-element-alist '(magit-status-mode . magit-section-backward))
      (add-to-list 'meta-functions-meta-down-element-alist '(magit-revision-mode . magit-section-forward))
      (add-to-list 'meta-functions-meta-up-element-alist '(magit-revision-mode . magit-section-backward))
      (meta-functions-update-function-definitions))))
#+END_SRC

Interaction with Github

#+BEGIN_SRC emacs-lisp
(use-package magithub
  :ensure t
  :after (magit magit-popup)
  :init
  (use-package magit-popup :ensure t)
  (require 'magit-popup)
  :config
  (magithub-feature-autoinject t)
  ;; Workaround for https://github.com/vermiculus/magithub/issues/71
  (defun magithub-issue--sort (issues)
    "Sort ISSUES by issue number."
    (sort issues
          (lambda (a b) (> (plist-get a :number)
			   (plist-get b :number))))))
#+END_SRC
** Text highlight & coloring
:PROPERTIES:
:ID:       d95f91d1-cef9-4094-9592-b38514fe2a77
:END:
*** Highlight text in buffer
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 14:29]
:ID:       9c3fe725-f67e-4abb-878f-da7b45bea121
:END:
#+begin_src emacs-lisp
(use-package hi-lock
  :if init-flag
  :diminish hi-lock-mode)
#+end_src
*** TODO Spell checking
:PROPERTIES:
:ID:       117c5718-7a46-4a7a-ab0d-b5b347444080
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-18 Wed 11:26]
:END:
**** Flyspell
:PROPERTIES:
:CREATED:  [2018-10-12 Fri 14:07]
:ID:       b79658d1-8d62-4c47-be3b-cc399a0a8c59
:END:

*************** TODO fly ispell only with idle timer?
*************** END
*************** TODO enable in org-mode
*************** END

  #+begin_src emacs-lisp
(use-package flyspell
  :if init-flag
  :ensure t
  :after org
  :hook ((notmuch-message-mode org-mode) . flyspell-mode)
  :bind (("<f8>" . ispell-word)
	 ("M-<f8>" . ispell-buffer)
         :map boon-forward-search-map
         ("s" . flyspell-goto-next-error))
  :init
  (use-package boon)
  :config
  (setq ispell-program-name "/usr/bin/ispell-aspell")
  (setq ispell-dictionary "british")
  (setq ispell-personal-dictionary "~/.emacs.d/dict")
 )
  #+end_src

***** Textual error pop-up
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 12:56]
:ID:       f99358cd-f847-4004-ac4e-bc1f49fdfcce
:END:
#+BEGIN_SRC emacs-lisp
(use-package flyspell
:config
(defun flyspell-emacs-popup-textual (event poss word)
  "A textual flyspell popup menu.
From https://www.emacswiki.org/emacs/FlySpell"
  (require 'popup)
  (let* ((corrects (if flyspell-sort-corrections
		       (sort (car (cdr (cdr poss))) 'string<)
		     (car (cdr (cdr poss)))))
	 (cor-menu (if (consp corrects)
		       (mapcar (lambda (correct)
				 (list correct correct))
			       corrects)
		     '()))
	 (affix (car (cdr (cdr (cdr poss)))))
	 show-affix-info
	 (base-menu  (let ((save (if (and (consp affix) show-affix-info)
				     (list
				      (list (concat "Save affix: " (car affix))
					    'save)
				      '("Accept (session)" session)
				      '("Accept (buffer)" buffer))
				   '(("Save word" save)
				     ("Accept (session)" session)
				     ("Accept (buffer)" buffer)))))
		       (if (consp cor-menu)
			   (append cor-menu (cons "" save))
			 save)))
	 (menu (mapcar
		(lambda (arg) (if (consp arg) (car arg) arg))
		base-menu)))
    (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
(fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)
(defadvice flyspell-goto-next-error (after check-word-spelling activate) (ispell-word))
)
#+END_SRC
***** Integration with org-mode
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 12:54]
:ID:       bc5ecae4-4038-4284-9d98-f7a6c819fe87
:END:

#+BEGIN_SRC emacs-lisp
;; from https://github.com/wdenton/.emacs.d/blob/master/setup/setup-orgmode.el
;; Use LaTeX spell-check
(add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))

;; Ispell should ignore some things in Org files
;; http://endlessparentheses.com/ispell-and-org-mode.html
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))
(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
*** Code checking
:PROPERTIES:
:ID:       3a550aad-f2a2-4636-a92c-539cdf230aeb
:END:
#+begin_src emacs-lisp
(use-package flycheck
  :if init-flag
  :ensure t
  :diminish flycheck-mode
  :hook ((prog-mode) . flycheck-mode)
  :config
  (use-package flycheck-tip
    :ensure t
    :config
    (setq flycheck-display-errors-function 'ignore)
    (use-package boon
      :config
      (bind-keys :map boon-forward-search-map
		 ("c" . flycheck-tip-cycle)
                 :map boon-backward-search-map
                 ("c" . flycheck-tip-cycle-reverse)))))
#+end_src
*** Highlight parentheses everywhere
:PROPERTIES:
:ID:       767805ca-1482-4299-8a1c-3e3b1a73f94a
:END:
#+begin_src emacs-lisp
(use-package highlight-parentheses
  :if init-flag
  :ensure t
  :diminish highlight-parentheses-mode
  :config
  (define-globalized-minor-mode global-highlight-parentheses-mode
    highlight-parentheses-mode
    (lambda ()
      (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t))

(use-package rainbow-delimiters
  :if init-flag
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
*** Highlight numbers
:PROPERTIES:
:ID:       024a16ec-c9db-4906-9896-8ebf8af76dae
:END:
#+begin_src emacs-lisp
(use-package highlight-numbers
  :if init-flag
  :ensure t
  :hook (prog-mode . highlight-numbers-mode))
#+end_src
*** Regexp escape smart highlight
:PROPERTIES:
:ID:       5d7810ea-35d4-4ee9-afaa-61b9c6c624c6
:END:
#+begin_src emacs-lisp
(use-package easy-escape
  :if init-flag
  :ensure t
  :diminish easy-escape-minor-mode
  :hook (prog-mode . easy-escape-minor-mode))
#+end_src
*** Search highlight
:PROPERTIES:
:ID:       afa67877-bede-41c1-9c44-bb168070d292
:END:
#+begin_src emacs-lisp
(setf search-highlight t)
(setf query-replace-highlight t)
#+end_src
*** Volatile highlights - highlight actions
:PROPERTIES:
:ID:       02c8a98c-a38a-4054-a0a2-400f6757693b
:END:
- I changed the background color here due to clash with my =org-mode= colors
  #+begin_src emacs-lisp
(use-package volatile-highlights
  :if init-flag
  :ensure t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t)
  (custom-set-faces
   '(vhl/default-face ((t :background "LightGray" :inherit secondary-selection)))))
  #+end_src
*** Expand region
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 20:46]
:ID:       13ec58f5-636b-479f-ad19-ad229ce47603
:END:
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :if init-flag
  :ensure t
  :bind (:map boon-command-map
	      ("`" . er/expand-region)
              :map boon-special-map
              ("`" . er/expand-region)))

#+END_SRC
*** Highlight uncommited changes in version-controlled files and dirs
:PROPERTIES:
:CREATED:  [2019-04-05 Fri 16:37]
:ID:       c5fc942a-d468-4102-9c90-6275fd605e92
:END:

#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :if init-flag
  :ensure t
  :init
  (setq git-gutter-fr:side 'right-fringe)
  :config
  (add-hook 'magit-mode-hook #'git-gutter-mode))
#+end_src

** Fold & narrow
:PROPERTIES:
:ID:       7f5795bc-6bc1-4095-b31c-ed724bbc942c
:END:
*** =Hideshow= mode
:PROPERTIES:
:ID:       6ea2a9f7-7b73-4289-976f-b53adcae8f38
:END:
#+begin_src emacs-lisp
(use-package hideshow
  :if init-flag
  :ensure t
  :bind (:map hs-minor-mode-map
	      :filter boon-command-state
	      ("<tab>" . hs-toggle-hiding)
	      ("<backtab>" . hs-hide-all)
	      ("M-S-<iso-lefttab>" . hs-show-all))
  :hook ((c-mode-common emacs-lisp-mode sh-mode org-src-mode) . hs-minor-mode))
#+end_src
*** Turn on narrow
:PROPERTIES:
:ID:       9b629716-48c5-41c7-b34e-5e458922368b
:END:
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src
** Search & navigation
:PROPERTIES:
:ID:       46fb459b-7794-4b9a-9fce-85389aba1d95
:END:
*** Text
**** Boon navigation & search
:PROPERTIES:
:ID:       e90d8071-a7ed-4aba-a694-a78aa5fded78
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (bind-keys ("C-M-S-j" . scroll-other-window)
	     ("C-M-S-k" . scroll-other-window-down)
	     :map boon-x-map
	     ("e" . eval-last-sexp)
	     ("c" . delete-frame)
	     :map boon-moves-map
	     ("j" . meta-down)
	     ("J" . meta-down-element)
	     ("k" . meta-up)
	     ("K" . meta-up-element)
	     ("o" . meta-forward)
	     ("O" . meta-forward-element)
	     ("i" . meta-backward)
	     ("I" . meta-backward-element)
	     ("l" . meta-scroll-up)
	     ("L" . meta-scroll-down)
	     (";" . recenter-top-bottom)
	     ("G" . end-of-buffer)
	     ("g" . boon-goto-map)
	     ("U" . move-beginning-of-line)
	     ("P" . move-end-of-line)
	     ("u" . boon-beginning-of-line)
	     ("p" . boon-end-of-line)
	     :map boon-goto-map
	     ("g" . beginning-of-buffer)
	     ("G" . end-of-buffer)
	     :map boon-command-map
	     ("-" . meta-undo)
             ("_" . undo-tree-redo)
	     ("~" . boon-repeat-command)
	     ("Q" . kmacro-end-or-call-macro)
	     ("q" . nil)
	     ("P" . nil)
	     ("z" . boon-quote-character)
	     ("y" . transpose-chars)
	     ("Y" . transpose-words)
             ("n" . boon-switch-mark)
             ("m" . bm-previous)
	     :map boon-forward-search-map
	     ("C-SPC" . isearch-forward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("w" . meta-occur)
             ("g" . meta-goto)
	     :map boon-backward-search-map
	     ("C-SPC" . isearch-backward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("e" . meta-occur)
             ("g" . meta-goto)
	     :map boon-special-map
	     ("c" . boon-c-god)
	     ("z" . boon-quote-character)
	     ("e" . boon-forward-search-map)
	     ("w" . boon-backward-search-map)
	     ("q" . nil)
	     ("g" . boon-goto-map)
	     ("G" . end-of-buffer)
	     ("D" . boon-treasure-region)
	     ("<SPC>" . boon-drop-mark)))
#+end_src

**** =Avy= mode - =qutebrowser= like hints to words
:PROPERTIES:
:ID:       f645973b-fcd8-466a-9fec-7e8ebcbb0be1
:END:

I do not move by visual line in files. Instead, I prefer to use avy to move within the line. 
However, it is still not fast enough with =avy-goto-char-in-line=. 
Hence, I define a new function - =avy-goto-word-in-line-1= to jump to any word in 2 keys.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :defer t
  :config
(defun avy-goto-word-in-line-1 (char &optional arg)
  "Jump to a currently visible WORD with first CHAR in the current line."
  (interactive (list (read-char "char: " t)
                     current-prefix-arg))
  (funcall-interactively #'avy-goto-word-1 char arg (line-beginning-position) (line-end-position))))
#+END_SRC

Also, I am not satisfied with moving around the visible text.
The =avy-goto-char-2= is frequently gives too many options. 
I wrote my own =avy-goto-word-2= to move around.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :defer t
  :config
  (defun avy-goto-word-2 (char1 char2 &optional arg beg end symbol)
    "Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched."
    (interactive (list (read-char "char 1: " t)
                       (read-char "char 2: " t)
                       current-prefix-arg
                       nil nil))
    (when (eq char1 ?)
      (setq char1 ?\n))
    (when (eq char2 ?)
      (setq char2 ?\n))
    (avy-with avy-goto-word-1
      (let* ((str (string char1))
             (regex (cond ((string= str ".")
                           "\\.")
                          ((and avy-word-punc-regexp
				(string-match avy-word-punc-regexp str))
                           (regexp-quote (concat str (string char2))))
			  (t
			   (concat "\\b" str (string char2))))))
        (avy-jump regex :beg beg :end end))))
  )
#+END_SRC

#+begin_src emacs-lisp 
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package avy
    :ensure t
    :bind (:map boon-moves-map
		("h" . avy-goto-word-in-line-1)
		("H" . avy-goto-word-2)
		)))
#+end_src
**** End of sentence
:PROPERTIES:
:CREATED:  [2018-01-18 Thu 14:43]
:ID:       40e35090-b8ec-4770-864b-9e286459533c
:END:
Double space convention is outdated.
#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC
*** Links
**** Browse URL
:PROPERTIES:
:ID:       17ccb0ae-e369-45bb-bfab-1d3cac9ca147
:END:
#+begin_src emacs-lisp
(use-package browse-url
  :bind (("C-c C-o" . browse-url)
	 ("C-c C-M-o" . browse-url-of-buffer))
  :init  
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "/home/yantar92/bin/qutebrowser-call.sh"))
#+end_src
*** Imenu
:PROPERTIES:
:CREATED:  [2018-10-25 Thu 22:45]
:ID:       fdbef4e6-7b49-4c80-88be-cf9f85bce94f
:END:

Imenu allows navigating through the buffer structure, according to the major mode.
#+begin_src emacs-lisp
(use-package imenu
  :init
  (setq imenu-auto-rescan 't))
#+end_src

*** TODO Bookmarks
:PROPERTIES:
:ID:       a3d45efd-52f8-44f7-a699-940033cba429
:END:
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :when init-flag
  :demand t

  :init
  ;; restore on load (even before you require bm)
  (setq bm-restore-repository-on-load t)


  :config
  ;; Allow cross-buffer 'next'
  (setq bm-cycle-all-buffers t)

  ;; highligh style
  (setq bm-highlight-style 'bm-highlight-line-and-fringe)
  (custom-set-faces '(bm-persistent-face ((t (:background "Lightyellow")))))
  (custom-set-faces '(bm-fringe-persistent-face ((t (:background "Lightyellow")))))

  ;; where to store persistant files
  (setq bm-repository-file "~/.emacs.d/bm-repository")

  ;; save bookmarks
  (setq-default bm-buffer-persistence t)

  ;; Loading the repository from file when on start up.
  (add-hook' after-init-hook 'bm-repository-load)

  ;; Saving bookmarks
  (add-hook 'kill-buffer-hook #'bm-buffer-save)

  ;; Saving the repository to file when on exit.
  ;; kill-buffer-hook is not called when Emacs is killed, so we
  ;; must save all bookmarks first.
  (add-hook 'kill-emacs-hook #'(lambda nil
                                 (bm-buffer-save-all)
                                 (bm-repository-save)))

  ;; The `after-save-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state.
  (add-hook 'after-save-hook #'bm-buffer-save)

  ;; Restoring bookmarks
  (add-hook 'find-file-hooks   #'bm-buffer-restore)
  (add-hook 'after-revert-hook #'bm-buffer-restore)

  ;; The `after-revert-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state. This hook might cause trouble when using packages
  ;; that automatically reverts the buffer (like vc after a check-in).
  ;; This can easily be avoided if the package provides a hook that is
  ;; called before the buffer is reverted (like `vc-before-checkin-hook').
  ;; Then new bookmarks can be saved before the buffer is reverted.
  ;; Make sure bookmarks is saved before check-in (and revert-buffer)
  (add-hook 'vc-before-checkin-hook #'bm-buffer-save)

  (use-package meta-functions
    :defer t
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(bm-show-mode . bm-show-next))
    (add-to-list 'meta-functions-meta-up-element-alist '(bm-show-mode . bm-show-prev))
    (meta-functions-update-function-definitions)
    )

  :bind (:map boon-command-map
	      ("N" . bm-toggle)
	      ("C-N" . bm-bookmark-annotate)
	      :map boon-insert-map
	      ("M-N" . bm-toggle)
	      ("C-M-N" . bm-toggle)
              :map boon-goto-map
              ("n" . bm-show)
              ("N" . bm-show-all)
	      :map boon-forward-search-map
	      ("n" . bm-next)
              :map boon-backward-search-map
              ("n" . bm-previous)
              :map bm-show-mode-map
              ("<tab>" . bm-show-goto-bookmark)
              )
  )
#+END_SRC
*** Buffers
**** Buffer list
:PROPERTIES:
:ID:       b69737e2-daa5-4b12-bb10-9ce37831edd4
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t 
  :bind (:map boon-forward-search-map
	      ("b" . helm-mini)
	      :map boon-backward-search-map
	      ("b" . helm-mini))
  :init
  (use-package boon))
#+end_src
**** Go to scratch key binding
:PROPERTIES:
:ID:       53b113ca-e2be-4f79-a575-aedbd0f0f7ad
:END:
#+begin_src emacs-lisp
(when init-flag
  (defun yant/show-scratch()
    (interactive)
    (pop-to-buffer "*scratch*")
    )
  (use-package boon
    :config 
    (bind-key "8" 'yant/show-scratch boon-goto-map)))
#+end_src
**** Kill buffer & buffer manipulation/movement
:PROPERTIES:
:ID:       cb74c835-f010-4880-ad84-00736172753f
:END:
#+begin_src emacs-lisp
(when init-flag
  (bind-key "C-x q" (lambda () (interactive) (kill-buffer (current-buffer))))
  (use-package boon
    :defer t
    :config
    (bind-keys
     ("M-`" . winner-undo)
     ("M-~" . winner-redo)
     :map boon-goto-map
     ("o" . meta-next-buffer)
     ("i" . meta-previous-buffer)
     ("u" . winner-undo)
     ("U" . winner-redo))))
#+end_src
*** Windows
**** Window layout management
:PROPERTIES:
:ID:       413ad4db-e20c-432f-8d15-b849d35b6cff
:END:
If we use boon, it is possible to bind =M-digit= to manage windows.
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :bind (("M-1" . delete-other-windows)
	 ("M-2" . split-window-below)
	 ("M-0" . delete-window)
	 ("M-3" . split-window-right)
	 ("M-4" . (lambda () (interactive)
		    (split-window-right)
                    (call-interactively #'clone-indirect-buffer-other-window)))))
#+end_src
**** Wind move
:PROPERTIES:
:ID:       8cd8df5e-ff33-46ac-9864-38e990f745de
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
	     ("j" . windmove-down)
             ("k" . windmove-up)
             ("i". windmove-left)
             ("o" . windmove-right)
             ("l" . other-window)
             :map boon-backward-search-map
	     ("j" . windmove-down)
             ("k" . windmove-up)
             ("i". windmove-left)
             ("o" . windmove-right)
	     ("l" . other-window)))
#+end_src
**** Winner mode
:PROPERTIES:
:CREATED:  [2018-10-08 Mon 14:45]
:ID:       46cd7842-d65f-4794-9ddd-e9dc50f6495c
:END:
Undo window configuration changes
#+BEGIN_SRC emacs-lisp
(when init-flag
  (winner-mode +1)
  (use-package boon
    :bind (:map boon-forward-search-map
		("-" . winner-undo)
                ("_" . winner-redo)
                :map boon-backward-search-map
		("-" . winner-undo)
                ("_" . winner-redo))))
#+END_SRC
*** Frame
:PROPERTIES:
:ID:       bb7ce294-1833-43bd-a837-ab4cd73fca6b
:END:
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-c") 'delete-frame)
(global-set-key (kbd "C-x c") 'delete-frame)
#+end_src
*** Files
**** Find files
:PROPERTIES:
:ID:       ecf20706-a6b2-4a46-b3c6-db3236a46d0f
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)
             ("d" . dired)
             :map boon-backward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)
	     ("d" . dired)))
#+end_src
***** Do not abbreviate file names (to avoid strange folders defined in [[id:9361bc68-010b-45f1-bddd-4638d6344758][org attachments]])
:PROPERTIES:
:CREATED:  [2018-07-25 Wed 17:28]
:ID:       7e252121-b5ba-4f9e-ba55-6eabb75d9a47
:END:
#+BEGIN_SRC emacs-lisp
(advice-add 'find-file-noselect :around #'dired-find-file@disable-abbreviate-file-name)
#+END_SRC
**** Search directories
***** NEXT Dired
:PROPERTIES:
:ID:       66f5dab7-add6-48c2-9824-fed4ef202b7a
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-10-08 Mon 14:55]
- State "TODO"       from              [2018-03-12 Mon 14:57]
- State "CANCELLED"  from              [2017-05-28 Sun 17:46]
:END:
#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :if init-flag
  :ensure t
  :hook ((dired-mode . auto-revert-mode)
	 ((dired-mode) . dired-hide-dotfiles-mode))
  :init
  (use-package autorevert)
  (setq auto-revert-verbose nil
	dired-dwim-target t
	dired-du-size-format t ;; show human readable size
	dired-listing-switches "--time-style=locale -ADhgGBF --group-directories-first")
  :config
  (put 'dired-find-alternate-file 'disabled nil)
  (defalias 'dired-find-file #'dired-find-alternate-file)
  (use-package dired-du :ensure t)
  (bind-key "." 'dired-hide-dotfiles-mode dired-mode-map)
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-alist '(dired-mode . dired-hacks-next-file))
    (add-to-list 'meta-functions-meta-up-alist '(dired-mode . dired-hacks-previous-file))
    (add-to-list 'meta-functions-meta-up-element-alist '(dired-mode . dired-up-directory))
    (add-to-list 'meta-functions-meta-down-element-alist '(dired-mode . dired-find-alternate-file))
    (meta-functions-update-function-definitions))
  (bind-keys :map dired-mode-map
	     ("q" . (lambda () (interactive) (quit-window 'kill)))
	     ("<return>" . xah-open-in-external-app)
	     ("W" . dired-copy-filename-as-kill)
             ("s" . dired-mark)
             ("a" . dired-unmark)
	     ("<tab>" . other-window)))

#+end_src
****** NEXT Dired+
SCHEDULED: <2019-02-02 Sat>
:PROPERTIES:
:CREATED:  [2018-10-08 Mon 14:53]
:ID:       f7f3a852-237e-491d-9de7-786807aa63cb
:END:
:LOGBOOK:
- State "TODO"       from              [2018-10-08 Mon 14:55]
:END:

#+BEGIN_SRC emacs-lisp
;; from https://writequit.org/org/
;; (defun my/dired-mode-hook ()
;;   (toggle-truncate-lines 1))

;; from https://writequit.org/org/
;; (use-package dired
;;   :bind ("C-x C-j" . dired-jump)
;;   :config
;;   (use-package dired-x
;;     :init (setq-default dired-omit-files-p t)
;;     :config
;;     (add-to-list 'dired-omit-extensions ".DS_Store"))
;;   (customize-set-variable 'diredp-hide-details-initially-flag nil)
;;   (use-package dired+)
;;   (use-package dired-aux
;;     :init (use-package dired-async))
;;   (put 'dired-find-alternate-file 'disabled nil)
;;   (setq ls-lisp-dirs-first t
;;         dired-recursive-copies 'always
;;         dired-recursive-deletes 'always
;;         dired-dwim-target t
;;         ;; -F marks links with @
;;         dired-ls-F-marks-symlinks t
;;         delete-by-moving-to-trash t
;;         ;; Auto refresh dired
;;         global-auto-revert-non-file-buffers t
;;         wdired-allow-to-change-permissions t)
;;   (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
;;   (define-key dired-mode-map (kbd "C-M-u") 'dired-up-directory)
;;   (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
;;   (define-key dired-mode-map (kbd "C-x C-q") 'wdired-change-to-wdired-mode)
;;   (bind-key "l" #'dired-up-directory dired-mode-map)
;;   (bind-key "M-!" #'async-shell-command dired-mode-map)
;;   (add-hook 'dired-mode-hook #'hl-line-mode)
;;   (add-hook 'dired-mode-hook #'my/dired-mode-hook))

#+END_SRC
****** NEXT Image-dired
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 21:26]
:ID:       c095c061-ffdc-4adb-a889-bb4e54b6a514
:END:

#+begin_src emacs-lisp
(use-package image-dired
  :config
  (unbind-key "o" image-map)
  (use-package meta-functions
    :config 
    (add-to-list 'meta-functions-meta-forward-alist '(image-dired-thumbnail-mode . image-dired-forward-image))
    (add-to-list 'meta-functions-meta-backward-alist '(image-dired-thumbnail-mode . image-dired-backward-image))
    (add-to-list 'meta-functions-meta-down-alist '(image-dired-thumbnail-mode . image-dired-next-line))
    (add-to-list 'meta-functions-meta-up-alist '(image-dired-thumbnail-mode . image-dired-previous-line))
    (meta-functions-update-function-definitions)))
#+end_src

****** open file in external app 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:55]
:ID:       61a29cb9-8c13-4e10-979d-144866c4d122
:END:
#+begin_src emacs-lisp
(defun xah-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2016-10-15"
  (interactive)
  (let* ((-file-list
	  (if (or (string-equal major-mode "dired-mode")
		  (string-equal major-mode "sr-mode")
		  )
	      (or (dired-get-marked-files)
		  (dired-get-filename)
		  )
	    (list (buffer-file-name))))
	 (-do-it-p (if (<= (length -file-list) 5)
		       t
		     (y-or-n-p "Open more than 5 files? "))))
    (when -do-it-p
      (cond
       ((string-equal system-type "windows-nt")
	(mapc (lambda (-fpath) (w32-shell-execute "open"
						  (replace-regexp-in-string "/" "\\" -fpath t t)))
	      -file-list))
       ((string-equal system-type "darwin")
	(mapc (lambda (-fpath) (shell-command (concat "open "
						      (shell-quote-argument -fpath))))
	      -file-list))
       ((string-equal system-type "gnu/linux")
	(mapc (lambda (-fpath) (let ((process-connection-type nil))
				 (start-process "" nil "xdg-open" -fpath)))
	      -file-list))))))
#+end_src
****** Async operations
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       06e9d624-67fe-42cb-acca-44c1e5e1fde1
:END:
#+BEGIN_SRC emacs-lisp
(use-package async
  :if init-flag
  :ensure t
  :config
  (use-package dired
    :defer t
    :config
    (use-package dired-async
      :config
      (dired-async-mode 1))))
#+END_SRC
****** Group files 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       18e2dd1e-dc25-4188-bad4-cdcdb76f506a
:END:
#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :if init-flag
  :ensure t
  :config
  (setq dired-filter-group-saved-groups '(("default"
					   ("Dirs"
					    (directory . nil))
					   ("Archives"
					    (extension "zip" "rar" "gz" "bz2" "tar"))
					   ("Documents"
					    (extension "org" "cfm" "pdf" "tex" "bib" "mobi" "fb2" "doc" "docx"))
					   ("Scripts"
					    (extension "gnuplot" "sh"))
					   ("Data"
					    (extension "txt" "hys" "xls" "xlsx"))
					   ("Images"
					    (extension "png" "jpg" "jpeg" "tiff" "tif"))
					   ("Videos"
					    (extension "avi" "mpeg" "mp4" "mkv"))
					   )))
  (add-hook 'dired-mode-hook 'dired-filter-group-mode))
#+END_SRC
****** Highlight files 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 22:09]
:ID:       45393002-d153-42bf-ae39-70b6e49b25b0
:END:
#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :if init-flag
  :ensure t
  :config
  (diredfl-global-mode 1))
#+END_SRC
****** TODO Follow symlink structure
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 15:42]
:ID:       3f656102-43d7-4a91-b245-92af4ffca9a6
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-23 Mon 15:45]
:END:
=dired-find-file= calls =find-file=, which calls =find-file-noselect=, which forces =abbreviate-file-name= to be applied. 
It makes entering symlink in =~/Dropbox/Org/->~/Org= go into "~/Org".
As a result, =dired-up-directory= goes to =~/= instead of =~/Dropbox=.

Hence, I avoid =abbreviate-file-name= in =dired-find-file=.
Same for =dired-noselect= (called by =dired=, which is called by =dired-up-directory=).

#+BEGIN_SRC emacs-lisp
(define-advice dired-find-file (:around (OLDFUN &rest args) disable-abbreviate-file-name)
  "Disable `abbreviate-file-name' in dired."
  (cl-flet ((abbreviate-file-name (filename) ""
			       (if (f-directory? filename)
				   (f-slash filename)
                                 filename)))
    (apply OLDFUN args)))
(advice-add 'dired-noselect :around #'dired-find-file@disable-abbreviate-file-name)
#+END_SRC
**** FTP
:PROPERTIES:
:CREATED:  [2018-12-07 Fri 14:58]
:ID:       54e5a53e-cebe-4449-a854-27bd586ca55d
:END:

#+begin_src emacs-lisp
(setq ange-ftp-dumb-unix-host-regexp "58\\.206\\.96\\.91")
#+end_src
*** NEXT Hyperbole
:PROPERTIES:
:CREATED:  [2019-03-21 Thu 13:52]
:ID:       40c2aac3-517c-45cd-bfe4-aa5465e4c3e6
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2019-03-21 Thu 13:52]
:END:

#+begin_src emacs-lisp
(use-package hyperbole
  :ensure t
  :disabled
  :config
  (bind-key* "<tab>" #'action-key)
  (bind-key* "<backtab>" #'assist-key)
  )
#+end_src
*** Org
:PROPERTIES:
:CREATED:  [2019-05-05 Sun 13:43]
:ID:       d5a656cb-42e1-4b90-881e-992561d803e2
:END:

#+begin_src emacs-lisp
(use-package helm-org-rifle
  :ensure t
  :bind (:map boon-goto-map
	      ("P" . helm-org-rifle))
  :init
  (setq helm-org-rifle-reverse-paths t
	helm-org-rifle-test-against-path t)
  (use-package boon))
#+end_src

** Editing
:PROPERTIES:
:ID:       6d0859b5-5d38-42a6-a676-aebec0867681
:END:
*** Boon - set =command state= from =insert state=
:PROPERTIES:
:ID:       94ed4714-1f9d-43f7-8ddc-74f855154b2c
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (bind-key "M-l" 'boon-set-command-state boon-insert-map))

#+end_src
*** Multiple cursors =insert state=
:PROPERTIES:
:ID:       8cbda343-0d1f-4abd-92d1-75a22b0b8d3c
:END:
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package multiple-cursors
    :defer t
    :bind (:map boon-command-map
		("C-V" . mc/edit-beginnings-of-lines))))
#+end_src
*** Open current line =insert state=
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 16:03]
:ID:       0d1d2022-e094-49b0-abc0-0957536690ee
:END:
#+BEGIN_SRC emacs-lisp
(use-package boon
  :defer t
  :config
  (bind-key "M-v" 'boon-open-line-and-insert boon-command-map))
#+END_SRC
*** Query replace
:PROPERTIES:
:ID:       1825c53a-1f53-4da8-a2b0-04ddea8cc43e
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package visual-regexp
    :init
    (use-package visual-regexp-steroids :ensure t)
    :bind (:map boon-command-map
		("?" . vr/query-replace)
		("M-?" . helm-regexp))))
#+end_src
*** Comment/uncomment
:PROPERTIES:
:ID:       957cd651-ad7a-467d-b6d5-ac8bf92d839d
:END:
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :if init-flag
  :ensure t
  :bind (:map prog-mode-map
	      ("M-;" . comment-dwim-2))) 
#+end_src
*** Indent region
:PROPERTIES:
:ID:       703f08dd-3ad9-4eba-a60e-2ad4de642375
:END:
#+begin_src emacs-lisp
(bind-key* "C-<tab>" 'indent-region)
#+end_src
*** Aggressive indent
:PROPERTIES:
:ID:       f3eaeebf-fe50-4ec6-81ed-f42e8b7b71c6
:END:
#+begin_src emacs-lisp
(use-package aggressive-indent
  :if init-flag
  :ensure t
  :diminish aggressive-indent-mode
  :config
  (global-aggressive-indent-mode t))
#+end_src
*** Delete backward key bindings
:PROPERTIES:
:ID:       c36d8b82-50ab-4097-a93a-56cbcf376cee
:END:
#+begin_src emacs-lisp
(bind-keys ("C-M-h" . backward-kill-word)
	   ("C-h" . backward-delete-char-untabify)
           :map isearch-mode-map
	   ("C-h" . isearch-delete-char)
           ("C-M-h" . isearch-delete-char))
(use-package boon
  :if init-flag
  :defer t
  :bind (:map boon-command-map
	      ("C-h" . backward-delete-char-untabify)))
#+end_src
*** Return key
:PROPERTIES:
:ID:       ce7df944-6c64-4a7d-8e11-136237250e3c
:END:
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-j") (kbd "<RET>"))

(use-package meta-functions
  :if init-flag
  :config
  (use-package boon
    :bind (:map boon-command-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line)
                :map boon-insert-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line))))


#+end_src
*** Do no yank with mouse, but use Shift-Ins to yank the primary selection
:PROPERTIES:
:ID:       88a3703a-21fe-47a1-9b8c-bce7fdb5d10a
:END:
#+begin_src emacs-lisp
;; (setq mouse-yank-at-point t)
(bind-key "<S-insert>" (lambda () (interactive)
			 (insert (gui-get-primary-selection))))
(bind-key "<mouse-2>" #'ignore)
#+end_src
*** Open files as root
:PROPERTIES:
:CREATED:  [2018-01-10 Wed 02:38]
:ID:       4229fb72-78fe-4848-b925-fb1f87f75fdf
:END:
:LOGBOOK:
- State "TODO"       from              [2018-01-10 Wed 02:41]
:END:
#+BEGIN_SRC emacs-lisp
(when init-flag
  ;; http://emacs.readthedocs.io/en/latest/file_management.html
  (defun yt/sudo-find-file (file-name)
    "Like find file, but opens the file as root."
    (interactive "FSudo Find File: ")
    (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
      (find-file tramp-file-name)))
  (use-package boon
    :defer t
    :bind (:map boon-forward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name))))
                :map boon-backward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name)))))))
#+END_SRC
*** Move lines, elements around
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 15:00]
:ID:       61ed40af-8165-4ffa-9412-96d802bb8e18
:END:
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :config
  (meta-functions-add-meta-function '(meta-move-line-right ignore "Move the line under cursor right.")
				    '(meta-move-line-left ignore "Move the line under cursor left.")
				    '(meta-move-line-up move-text-line-up "Move the line under cursor up.")
				    '(meta-move-line-down move-text-line-down "Move the line under cursor down.")
				    '(meta-move-element-right ignore "Move the element under cursor right.")
				    '(meta-move-element-left ignore "Move the element under cursor left.")
				    '(meta-move-element-down move-text-down "Move the element under cursor down.")
				    '(meta-move-element-up move-text-up "Move the element under cursor up."))
  (use-package move-text
    :if init-flag
    :ensure t
    :bind (:map boon-command-map
		("M-j" . meta-move-line-down)
		("M-k" . meta-move-line-up)
		("M-J" . meta-move-element-down)
		("M-K" . meta-move-element-up)
		("M-O" . meta-move-element-right)
		("M-I" . meta-move-element-left)
		("M-o" . meta-move-line-right)
		("M-i" . meta-move-line-left)))
  :init (use-package boon))
#+END_SRC
*** Org mode editing
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 18:45]
:ID:       184b97b2-df73-4961-9f8f-ad8a6b4e1db8
:END:

#+begin_src emacs-lisp
(use-package org
  :defer t
  :config
  (bind-keys* :map org-mode-map
	      ("C-c C-k" . org-cut-subtree)))
#+end_src

** Debugging
:PROPERTIES:
:ID:       749e7414-827f-45cb-9ee0-19637eb2274e
:END:
*** No visible bell
:PROPERTIES:
:ID:       83e9e494-8646-4118-a574-b35026acd582
:END:
#+begin_src emacs-lisp 
(setq visible-bell nil)
#+end_src
*** Debug on error
:PROPERTIES:
:ID:       1b3bb071-a145-43ef-826a-25dacb4c5cc2
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-12-19 Tue 08:53]
:END:
#+begin_src emacs-lisp 
(setq debug-on-error t)
(setq debug-on-quit nil)
(setq debug-ignored-errors '(beginning-of-line
			     beginning-of-buffer
			     end-of-line
			     end-of-buffer
			     end-of-file
			     buffer-read-only
			     quit
			     file-supersession
			     mark-inactive
			     user-error
                             search-failed
			     file-missing
                             file-date-error
			     "Attempt to delete the sole visible or iconified frame"
                             "No such page"
                             "use-package: :[a-z]+ wants"
                             "The mark is not set now, so there is no region"
                             "Search string not set"
			     "use-package: Unrecognized keyword"
			     "No more buttons"
                             "No command bound to"
			     )
      )
#+end_src
*** Debugger key bindings
:PROPERTIES:
:ID:       cbca9cd1-9225-45b5-aa88-43ff09f128e5
:END:
#+begin_src emacs-lisp
(use-package debug
  :if init-flag
  :config
  (bind-key "s" #'debugger-continue debugger-mode-map))
#+end_src
** Programming & emacsing
:PROPERTIES:
:ID:       e2ea50c3-b8da-433e-a5f9-74d8ef91d807
:END:
*** Help
**** Show the continuation of unfinished keybindings
:PROPERTIES:
:ID:       af18cad7-734f-491f-85a8-1fc817cf2dbd
:END:
#+begin_src emacs-lisp
(use-package which-key
  :if init-flag
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+end_src
**** Help buffer navigation
:PROPERTIES:
:ID:       2bc3b25c-9754-4bce-a885-8d8b1300b6cc
:END:
#+begin_src emacs-lisp 
(use-package boon
  :defer t
  :if init-flag
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-next-buffer-alist '(help-mode . help-go-forward))
    (add-to-list 'meta-functions-meta-previous-buffer-alist '(help-mode . help-go-back))))
#+end_src
**** Info buffer navigation
:PROPERTIES:
:CREATED:  [2018-07-11 Wed 14:55]
:ID:       924cdc83-3ddc-4ef1-ae8d-8ca57682d389
:END:

#+begin_src emacs-lisp 
(use-package boon
  :defer t
  :if init-flag
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(Info-mode . Info-forward-node))
    (add-to-list 'meta-functions-meta-up-element-alist '(Info-mode . Info-backward-node))
    (add-to-list 'meta-functions-meta-new-line-alist '(Info-mode . Info-follow-nearest-node))
    (add-to-list 'meta-functions-meta-previous-buffer-alist '(Info-mode . Info-history-back))
    (add-to-list 'meta-functions-meta-next-buffer-alist '(Info-mode . Info-history-forward))
    ))
#+end_src

**** Symbol&info lookup
:PROPERTIES:
:ID:       e48bff0a-518d-4499-a62d-7003d203077a
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :bind (("<f1> l" . helm-locate-library))
  :init
  (use-package helm-descbinds :ensure t)
  (use-package boon
    :defer t
    :config
    
    (bind-keys :map boon-goto-map
	       ("f" . helpful-function)
	       ("v" . helpful-at-point)
	       ("d" . helpful-variable)
	       ("s" . helpful-symbol)
	       ("b" . helm-descbinds)
	       ("h m" . woman)
	       ("h n" . tldr)
	       ("h i" . helm-info-elisp)
	       ("h o" . helm-info-org)
	       ("h e" . helm-info-emacs)
	       ("h t" . helm-info-auctex)
	       ("h T" . helm-info-texinfo))))
#+end_src
**** Man
:PROPERTIES:
:ID:       45d67bee-9fa3-4c00-8f48-2b41ed03ea46
:END:
#+begin_src emacs-lisp
(use-package woman
  :if init-flag
  :commands woman
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(woman-mode . Man-next-section))
    (add-to-list 'meta-functions-meta-up-element-alist '(woman-mode . Man-previous-section))))
#+end_src
**** TLDR - short practical version of man
:PROPERTIES:
:CREATED:  [2019-01-20 Sun 02:28]
:ID:       fd10055f-2a65-4c7e-a1e9-3d95e7d8ea72
:END:

#+begin_src emacs-lisp
(use-package tldr :ensure t)
#+end_src

**** Helpful - better help buffers
:PROPERTIES:
:CREATED:  [2018-03-29 Thu 23:16]
:ID:       00d36901-9a96-46c3-be8b-6fe5edd9c3c7
:END:
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :if init-flag
  :ensure t)
#+END_SRC
*** Execute current buffer (c++,python,bash,...)
:PROPERTIES:
:ID:       a57244bb-a617-44b4-a806-7cff82a86ac7
:END:
#+begin_src emacs-lisp 
(use-package quickrun
  :if init-flag
  :ensure t
  :bind (
	 ("<f10>" . quickrun)
	 ("<C-XF86Search>" . quickrun-with-arg)
	 ("<C-M-XF86Search>" . quickrun-shell)
	 ("<C-XF86Explorer>" . quickrun-region)
	 ("<C-M-XF86Explorer>" . quickrun-replace-region)
	 ("<f12>" . helm-quickrun)))
#+end_src
*** Improved interactive evaluation of elisp code
:PROPERTIES:
:CREATED:  [2018-07-14 Sat 00:42]
:ID:       08ca8dd5-a692-470f-97fd-5e46f8255a90
:END:
1. Evaluating Quoted Expressions
2. Evaluating Function Symbols
3. Redefining Variables
4. Default Expressions to Evaluate
5. Editing Default Expressions

[[https://github.com/rswgnu/rsw-elisp]]

#+BEGIN_SRC emacs-lisp
(use-package rsw-elisp
  :config
  (rsw-elisp-enable))
#+END_SRC

*** Gnuplot
:PROPERTIES:
:ID:       192254a2-dc90-4a29-a713-f43f794211f6
:END:
#+begin_src emacs-lisp
(use-package gnuplot
  :if (or init-flag org-export-flag)
  :ensure t
  :mode ("\\.\\(gp\\|gnuplot\\|plot\\)$" . gnuplot-mode))
#+end_src
** TODO LaTeX
:PROPERTIES:
:ID:       2fb97bdf-d310-4e5a-8266-d68a1ae10298
:END:
*** Use =pdf-tools= to view resulting pdf
:PROPERTIES:
:ID:       a0515bfd-07df-418a-90a2-5515b1a4deb3
:END:
#+begin_src emacs-lisp
(setq TeX-view-program-list '(("pdf tools refresh" (lambda() (pdf-tools-install)
						     (TeX-pdf-tools-sync-view)))))
(setq TeX-view-program-selection '((output-pdf "pdf tools refresh")))
(setq TeX-source-correlate-start-server t)

(add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
	  'TeX-revert-document-buffer)

(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)

(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(diminish 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'variable-pitch-mode)
(diminish 'buffer-face-mode)
#+end_src
** Ledger
:PROPERTIES:
:ID:       a0cacc17-641c-4b29-86b2-7dcf609cd803
:END:
#+begin_src emacs-lisp
(use-package ledger-mode
  :if init-flag
  :ensure t
  :bind (:map boon-goto-map
	      ("z" . open-finance)
	      :map ledger-mode-map
	      ("M-n" . nil)
	      ("M-p" . nil)
	      ("C-c C-a" . ledger-add-transaction-and-boonedit))
  :config
  (defun open-finance()
    "Open ledger file."
    (interactive)
    (find-file "~/Finance/Singapore-PhD/Ledger.dat"))
  (defun ledger-add-transaction-and-boonedit ()
    "Switch to boon insert state when adding transaction."
    (interactive) 
    (call-interactively 'ledger-add-transaction) 
    (boon-set-insert-like-state))
  (setq ledger-reports
	'(("bal" "ledger --pedantic -f %(ledger-file) bal not Equity")
	  ("balsg" "ledger --pedantic -f %(ledger-file) bal not Equity -X S$")
	  ("balcny" "ledger --pedantic -f %(ledger-file) bal not Equity -X CNY")
	  ("balall" "ledger --pedantic -f %(ledger-file) bal not Equity:Opening")
	  ("reg" "ledger --pedantic --pending -f %(ledger-file) reg not Equity")
	  ("payee" "ledger --pedantic -f %(ledger-file) reg @%(payee)")
	  ("account" "ledger --pedantic -f %(ledger-file) reg %(account)")
	  ("budget" "ledger --pedantic -f %(ledger-file) bal --budget")
          ("budgetcny" "ledger --pedantic -f %(ledger-file) bal --budget -X CNY")
	  ("budgetsg" "ledger --pedantic -f %(ledger-file) bal --budget -X S$"))
	ledger-report-auto-refresh t)
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(ledger-mode . ledger-navigate-next-xact-or-directive))
    (add-to-list 'meta-functions-meta-up-element-alist '(ledger-mode . ledger-navigate-prev-xact-or-directive))
    (meta-functions-update-function-definitions))
  )
#+end_src
*** Do not end the completions with string
:PROPERTIES:
:CREATED:  [2019-03-23 Sat 07:31]
:ID:       af89ed91-0fc7-4d03-b08a-478c08ad0558
:END:

#+begin_src emacs-lisp
(add-hook 'ledger-mode-hook (lambda () (setq-local pcomplete-termination-string "")))
#+end_src

** Wolfram Mathematica
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 17:37]
:ID:       fbacbe1c-3e5c-47f0-9e2d-e6e5bde1fa5c
:END:
#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :if init-flag
  :ensure t
  )
#+END_SRC
** TODO Pdf view
:PROPERTIES:
:ID:       201475d1-64b3-4e1d-8e78-d850c6067761
:END:
#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :ensure t
  :magic ("%PDF" . pdf-view-mode)
  :bind (:map pdf-view-mode-map
	      ("v w" . pdf-view-fit-width-to-window)
	      ("v h" . pdf-view-fit-height-to-window))
  :init
  (defun yant/pdf-view-down nil
    "Go down document in pdf-view."
    (interactive)
    (pdf-view-next-line-or-next-page 5))
  (defun yant/pdf-view-up nil
    "Go up document in pdf-view."
    (interactive)
    (pdf-view-previous-line-or-previous-page 5))
  (use-package pdf-annot)
  (use-package pdf-occur)
  (use-package pdf-history)
  (use-package pdf-links)
  (use-package pdf-outline)
  (use-package pdf-sync)
  (use-package pdf-isearch)
  (use-package pdf-cache)
  :config
  (pdf-tools-install)
  (add-hook 'pdf-view-mode-hook #'pdf-view-fit-width-to-window 'APPEND)
  (add-hook 'pdf-view-mode-hook #'pdf-tools-enable-minor-modes 'APPEND)
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-alist '(pdf-view-mode . yant/pdf-view-down))
    (add-to-list 'meta-functions-meta-up-alist '(pdf-view-mode . yant/pdf-view-up))
    (add-to-list 'meta-functions-meta-scroll-down-alist '(pdf-view-mode . pdf-view-scroll-down-or-previous-page))
    (add-to-list 'meta-functions-meta-scroll-up-alist '(pdf-view-mode . pdf-view-scroll-up-or-next-page))
    (add-to-list 'meta-functions-meta-down-alist '(pdf-annot-list-mode . tablist-next-line))
    (add-to-list 'meta-functions-meta-up-alist '(pdf-annot-list-mode . tablist-previous-line)))
  
  (defun yant/jump-to-file-bookmark ()
    "Jump to the bookmark names as `buffer-file-name'."
    (cond
     ;; ((eq major-mode 'pdf-view-mode)
     ;;  (pdf-view-bookmark-jump (list buffer-file-name (alist-get buffer-file-name bookmark-alist nil nil #'string=))))
     (t
      (bookmark-jump (list buffer-file-name (alist-get buffer-file-name bookmark-alist nil nil #'string=))))))
  
  (defun yant/save-file-bookmark ()
    "Save current file buffer position to bookmark with the name as `buffer-file-name'."
    (cond
     ;; ((eq major-mode 'pdf-view-mode)
     ;;  (pdf-view-bookmark-make-record))
     (t
      (when buffer-file-name
	(bookmark-set buffer-file-name)))))
  
  (add-hook 'pdf-view-mode-hook #'yant/jump-to-file-bookmark)

  (defun yant/save-bookmark-and-quit ()
    "Call `yant/save-file-bookmark' and quit."
    (interactive)
    (yant/save-file-bookmark)
    (quit-window 'KILL))
  
  (bind-keys :map pdf-view-mode-map
	     ("q" . yant/save-bookmark-and-quit))
  )
#+end_src
*** Pdf rotate
:PROPERTIES:
:ID:       0ec2a69c-4284-48f2-86cb-4bac1f0a3b3f
:END:
#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :init
  (use-package pdf-view :demand t)
  (defun pdf-view--rotate (&optional counterclockwise-p page-p)
    "Rotate PDF 90 degrees.  Requires pdftk to work.\n
       Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
       non-nil for the other direction.  Rotate the whole document by
       default; set PAGE-P to non-nil to rotate only the current page.
       \nWARNING: overwrites the original file, so be careful!"
    ;; error out when pdftk is not installed
    (if (null (executable-find "pdftk"))
	(error "Rotation requires pdftk")
      ;; only rotate in pdf-view-mode
      (when (eq major-mode 'pdf-view-mode)
	(let* ((rotate (if counterclockwise-p "left" "right"))
	       (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
	       (page   (pdf-view-current-page))
	       (pages  (cond ((not page-p)                        ; whole doc?
			      (format "1-end%s" rotate))
			     ((= page 1)                          ; first page?
			      (format "%d%s %d-end"
				      page rotate (1+ page)))
			     ((= page (pdf-info-number-of-pages)) ; last page?
			      (format "1-%d %d%s"
				      (1- page) page rotate))
			     (t                                   ; interior page?
			      (format "1-%d %d%s %d-end"
				      (1- page) page rotate (1+ page))))))
	  ;; empty string if it worked
	  (if (string= "" (shell-command-to-string
			   (format (concat "pdftk %s cat %s "
					   "output %s.NEW "
					   "&& mv %s.NEW %s")
				   file pages file file file)))
	      (pdf-view-revert-buffer nil t)
	    (error "Rotation error!"))))))
  (defun pdf-view-rotate-clockwise (&optional arg)
    "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
       entire document."
    (interactive "P")
    (pdf-view--rotate nil (not arg)))
  (defun pdf-view-rotate-counterclockwise (&optional arg)
    "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
       rotate entire document."
    (interactive "P")
    (pdf-view--rotate :counterclockwise (not arg))))
#+end_src
** Utils
:PROPERTIES:
:ID:       460ee9e2-32f5-4ad2-a535-69121b201bcf
:END:
*** TODO Shell
**** Invokation
:PROPERTIES:
:ID:       1bdbe0fd-07db-483b-bf04-c9a6813ee351
:END:
#+begin_src emacs-lisp 
(use-package shell-pop
  :if init-flag
  :ensure t
  :bind ("M-<f9>" . shell-pop)
  :init
  (setq shell-pop-shell-type '("ansi-term" "*ansi-term*" (lambda () (ansi-term shell-pop-term-shell)))) 
  (setq shell-pop-window-position "right")
  :config
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+end_src
**** Interaction with boon
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 20:43]
:ID:       6027fccc-5e96-4c55-9e5a-12194caadefd
:END:
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(term-mode . ignore))
  (add-to-list 'meta-functions-meta-new-line-alist '(term-mode . term-send-raw))
  (meta-functions-update-function-definitions))

#+END_SRC
*** Calc
:PROPERTIES:
:ID:       db607f5d-6270-4193-942a-c1f772a97ca6
:END:
#+begin_src emacs-lisp
(use-package calc
  :if init-flag
  :bind (:map boon-goto-map
	      ("c" . calc)))
#+end_src
*** Music
**** Mingus (mpd)
:PROPERTIES:
:ID:       dad9e1d1-308f-4706-900e-3ec546e6eb58
:END:
I usually run mingus in a new frame using global WM key binding.
Hence, delete frame instead of burying the mingus buffer.

#+begin_src emacs-lisp
(use-package mingus
  :if init-flag
  :ensure t
  :bind (:map mingus-playlist-map
	      ("q" . (lambda() (interactive) (mingus-git-out) (delete-frame)))))
#+end_src

When listening a new band/album, I usually go through all the songs and delete what I do no like until several song remain in the playlist. It is much more convenient to have a global command to delete currently playing song if I do not like it instead of opening mingus frame and doing it manually.

#+begin_src emacs-lisp
(use-package mingus
  :defer t
  :if init-flag
  :config
  (defun yant/mingus-delete-currently-playing ()
    "Remove currently playing song from playlist."
    (interactive)
    (when (and (get-buffer "*Mingus*")
	       (mingus-cur-song-number))
      (with-current-buffer "*Mingus*"
	(mingus-goto-current-song)
	(mingus-del)))))
#+end_src

**** Boon special mode bindings
     :PROPERTIES:
     :ID:       336d16e1-7a21-44c1-8469-15a8658871a3
     :END:
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 22:24]

:END:

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (add-to-list 'meta-functions-meta-move-line-down-alist '(mingus-playlist-mode . mingus-move-down))
  (add-to-list 'meta-functions-meta-move-line-up-alist '(mingus-playlist-mode . mingus-move-up))
  (add-to-list 'meta-functions-meta-new-line-alist '(mingus-playlist-mode . mingus-play))
  (add-to-list 'meta-functions-meta-new-line-alist '(mingus-browse-mode . mingus-down-dir-or-play-song))
  (add-to-list 'meta-functions-meta-up-element-alist '(mingus-browse-mode . mingus-open-parent))
  (meta-functions-update-function-definitions)
  )
#+end_src

*** Printing
:PROPERTIES:
:ID:       7e2f9ad8-6c30-40db-bdbd-9ba3acd70b2a
:END:
#+begin_src emacs-lisp
(setq lpr-command "gtklp")
(setq lpr-add-switches "-C \"emacs-print\"")
(setq pdf-misc-print-programm "gtklp")
(setq pdf-misc-print-programm-args '("-C \"emacs-print\""))
#+end_src
** News & email
:PROPERTIES:
:ID:       b53c6b66-4a7c-4eae-ab26-e010fdeb3534
:END:
*** Elfeed
:PROPERTIES:
:ID:       9bc385e2-0ed2-460b-875e-be9ad19144a3
:END:
#+begin_src emacs-lisp
(use-package elfeed
  :if init-flag
  :ensure t
  :bind (:map elfeed-search-mode-map
	      ("q" . delete-frame)
	      ("r" . elfeed-search-update--force)
	      ("R" . elfeed-search-fetch)
	      ("t" . elfeed-search-untag-all-unread)
              ("T" . elfeed-search-tag-all-unread)
              ("b" . yant/elfeed-capture-entry)
              ("B" . (lambda () (interactive)
		       (elfeed-search-tag-all 'opened)
		       (meta-up)
		       (elfeed-search-browse-url))))
  :init
  (use-package org-capture-pop-frame
    :defer t
    :config
    (define-advice ocpf--org-capture (:around (old-fun orig-fun &optional goto keys) suppress-pop-frame-maybe)
      "Suppress pop-up frame when ``yant/suppress-pop-frame'' is non nil."
      (if (bound-and-true-p yant/suppress-pop-frame)
	  (funcall orig-fun goto keys)
	(funcall old-fun orig-fun goto keys))))
  (defun yant/elfeed-capture-entry ()
    "Capture selected entries into inbox."
    (interactive)
    (elfeed-search-tag-all 'opened)
    (meta-up)
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
               do (elfeed-untag entry 'unread)
               when (elfeed-entry-link entry)
               do (flet ((raise-frame nil nil))
		    (let ((yant/suppress-pop-frame t))
		      (org-protocol-capture (list :template "B"
						  :url it
						  :title (format "%s: %s"
								 (elfeed-feed-title (elfeed-entry-feed entry))
								 (elfeed-entry-title entry)))))))
      (mapc #'elfeed-search-update-entry entries)
      (unless (use-region-p) (forward-line))))
  (setq elfeed-search-filter "+unread -video -science")
  (setq elfeed-sort-order 'ascending)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-date-format '("%d %b, %a, %H:%M" 20 :left))
  (unless (boundp 'elfeed-search-mode-hook) (setq elfeed-search-mode-hook nil))
  ;; (add-hook 'elfeed-search-mode-hook (lambda () (toggle-truncate-lines +1)))
  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Org/rss.org"))))
#+end_src
*** Notmuch
:PROPERTIES:
:ID:       f6ca2367-45c4-45bc-acec-49837cadc5ac
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :ensure t
  :config
  (use-package boon
    :config
    (defun yant/notmuch-show-view-html-part ()
      "Search and open html part of the message in the browser."
      (interactive)
      (notmuch-show-view-part))
    (use-package meta-functions
      :config
      (add-to-list 'meta-functions-meta-down-alist '(notmuch-search-mode . notmuch-search-next-thread))
      (add-to-list 'meta-functions-meta-up-alist '(notmuch-search-mode . notmuch-search-previous-thread))
      (add-to-list 'meta-functions-meta-down-element-alist '(notmuch-show-mode . notmuch-show-next-message))
      (add-to-list 'meta-functions-meta-up-element-alist '(notmuch-show-mode . notmuch-show-previous-message))
      (add-to-list 'meta-functions-meta-down-element-alist '(notmuch-search-mode . notmuch-search-show-thread))
      (add-to-list 'meta-functions-meta-up-element-alist '(notmuch-search-mode . ignore))
      (meta-functions-update-function-definitions)
      )
    (bind-keys :map notmuch-search-mode-map
	       ("r" . notmuch-refresh-this-buffer)
	       ("C-c C-u" . notmuch-search-unread)
	       ("C-c C-d" . notmuch-search-done)
               ("C-c C-a" . notmuch-search-hide)
               ("C-c C-f" . notmuch-search-nolist)
	       ("C-c C-S-d" . notmuch-search-delete)
	       :map notmuch-show-mode-map
	       ("v" . yant/notmuch-show-view-html-part)
	       ("J" . notmuch-show-next-message)
	       ("K" . notmuch-show-previous-message)
	       ("C-c C-u" . notmuch-show-unread)
	       ("C-c C-d" . notmuch-show-done)
               ("C-c C-a" . notmuch-show-hide)
               ("C-c C-f" . notmuch-show-nolist)
	       ("C-c C-S-d" . notmuch-show-delete))))
#+end_src
**** Sendmail setup
:PROPERTIES:
:ID:       48f4a6a2-a480-4d4f-9ad4-99da5667a15f
:END:
- multiple accounts
  #+begin_src emacs-lisp
(setq send-mail-function 'sendmail-send-it)
;;autochoose account name for msmtp
(defun cg-feed-msmtp ()
  (if (message-mail-p)
      (save-excursion
	(let* ((from (save-restriction
		       (message-narrow-to-headers)
		       (message-fetch-field "from")))
	       (account (cond
			 ;; I use email address as account label in ~/.msmtprc
			 ((string-match "yantar92@gmail.com" from) "yantar92@gmail.com")
			 ((string-match "ihor_radchenko@alumni.sutd.edu.sg" from) "ihor_radchenko@alumni.sutd.edu.sg"))))
	  (setq message-sendmail-extra-arguments (list '"-a" account)))))) ; the original form of this script did not have the ' before "a" which causes a very difficult to track bug --frozencemetery
(add-hook 'message-send-mail-hook 'cg-feed-msmtp)
(setq message-sendmail-envelope-from 'header)
(setq mail-specify-envelope-from 't)
(setq mail-envelope-from 'header)
(setq message-make-forward-subject-function 'message-forward-subject-fwd)
(setq notmuch-fcc-dirs '(("ihor_radchenko@alumni.sutd.edu.sg" . "Office365/Sent +sent -unread")
			 ("yantar92@gmail.com" . "Gmail/Sent +sent -unread")))
  #+end_src
- automatic email signing
  I have to skip signing for some email accounts, because the server appends some text to messages. Even though the resulting message is correct, but some email clients are not able to open these messages properly. They show the appended text and unreadable attachment.
  #+begin_src emacs-lisp
(setq mml-default-sign-method "pgp")
(setq notmuch-crypto-process-mime t)

(defvar yant/mml-do-not-sign-accounts-list '("ihor_radchenko@alumni.sutd.edu.sg" "yantar92@gmail.com")
  "List of accounts, where the messaged should not be signed.")

(defun yant/mml-secure-message-sign-pgpmime-maybe ()
  "Sign the message unless the sending account is in `yant/mml-do-not-sign-accounts-list'."
  (let ((from (save-restriction
		(message-narrow-to-headers)
                (message-fetch-field "from"))))
    (unless (-first (lambda (el) (string-match el from)) yant/mml-do-not-sign-accounts-list)
      (mml-secure-message-sign-pgpmime))))

(add-hook 'message-send-hook #'yant/mml-secure-message-sign-pgpmime-maybe)
  #+end_src
- async mail sending 
*************** TODO Make it work
*************** END

#+BEGIN_SRC emacs-lisp
;; (use-package async
;;   :if init-flag
;;   :ensure t
;;   :config
;;   (use-package smtpmail-async
;;     :ensure nil
;;     :config
;;     (setq message-send-mail-function 'message-send-mail-with-sendmail)))
#+END_SRC
**** Search via helm
:PROPERTIES:
:ID:       9d973bbc-f8ce-4c35-87e5-67c6a3bebe49
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :config
  (use-package helm-notmuch
    :ensure t))
#+end_src
**** Tagging of sent messages
:PROPERTIES:
:ID:       42f1433a-3c25-47d4-b81a-76579130a611
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (bind-key  "C-c C-c"
	     (lambda()
	       (interactive)
	       (notmuch-mua-send-and-exit)
	       (start-process "Update tags"
			      nil
			      "/home/yantar92/bin/notmuch-new-messages-list-silent.sh"))
	     notmuch-message-mode-map))
#+end_src
**** Tagging functions
:PROPERTIES:
:ID:       54d9479f-a0a4-456f-bf4b-7adc2812c17b
:END:
#+begin_src emacs-lisp
(defun notmuch-show-delete () 
  (interactive) 
  (notmuch-show-tag-message "+deleted" "-inbox" "-todo" "-listinbox"))
(defun notmuch-show-unread()
  (interactive)
  (notmuch-show-tag-message "+unread"))
(defun notmuch-show-nolist()
  (interactive)
  (notmuch-show-tag-message "+inbox" "-listinbox"))
(defun notmuch-show-done()
  (interactive)
  (notmuch-show-tag-message "-todo" "-inbox" "-listinbox"))
(defun notmuch-show-hide()
  (interactive)
  (notmuch-show-tag-message "-todo"))
(defun notmuch-search-hide()
  (interactive)
  (notmuch-search-tag '("-todo")))
(defun notmuch-search-delete () 
  (interactive) 
  (notmuch-search-tag '("+deleted" "-inbox" "-todo" "-listinbox")))
(defun notmuch-search-unread()
  (interactive)
  (notmuch-search-tag '("+unread")))
(defun notmuch-search-done()
  (interactive)
  (notmuch-search-tag '("-todo" "-inbox" "-listinbox")))
(defun notmuch-search-nolist()
  (interactive)
  (notmuch-search-tag '("+inbox" "-listinbox")))
#+end_src
**** Quit frame instead of bury buffer
:PROPERTIES:
:ID:       b87ec258-7b7e-4898-b828-ab8be4d474f9
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defvar-local notmuch-frame nil
    "Non nil means that frame was invoked from system (not from inside emacs).")
  (defadvice notmuch-refresh-this-buffer (around update-notmuch-frame activate)
    "Preserve `notmuch-frame' value after refresh."
    (let ((notmuch-frame-old notmuch-frame))
      ad-do-it
      (setq notmuch-frame notmuch-frame-old)))
  (bind-key "q" (lambda()
		  (interactive)
		  (if notmuch-frame
		      (delete-frame)
		    (notmuch-bury-or-kill-this-buffer)))
	    notmuch-search-mode-map)
  (bind-key  "q"
	     'notmuch-bury-or-kill-this-buffer
	     notmuch-show-mode-map))
#+end_src
**** Inline display
:PROPERTIES:
:ID:       47d58119-8dc4-48e2-b3c3-81cc955242fc
:END:
- inline view
- html renderer
  #+begin_src emacs-lisp
(custom-set-variables
 '(mm-external-terminal-program "urxvt")
 '(mm-inline-large-images-proportion 0.4)
 '(mm-inline-media-tests
   (quote
    (("image/p?jpeg" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote jpeg)
	 handle)))
     ("image/png" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote png)
	 handle)))
     ("image/gif" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote gif)
	 handle)))
     ("image/tiff" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote tiff)
	 handle)))
     ("image/xbm" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xbm)
	 handle)))
     ("image/x-xbitmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xbm)
	 handle)))
     ("image/xpm" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xpm)
	 handle)))
     ("image/x-xpixmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xpm)
	 handle)))
     ("image/bmp" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote bmp)
	 handle)))
     ("image/x-portable-bitmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote pbm)
	 handle)))
     ("text/plain" mm-inline-text identity)
     ("text/enriched" mm-inline-text identity)
     ("text/richtext" mm-inline-text identity)
     ("text/x-patch" mm-display-patch-inline identity)
     ("text/x-diff" mm-display-patch-inline identity)
     ("application/emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-shellscript" mm-display-shell-script-inline identity)
     ("application/x-sh" mm-display-shell-script-inline identity)
     ("text/x-sh" mm-display-shell-script-inline identity)
     ("application/javascript" mm-display-javascript-inline identity)
     ("text/dns" mm-display-dns-inline identity)
     ("text/x-org" mm-display-org-inline identity)
     ("text/html" mm-inline-text-html
      (lambda
	(handle)
	mm-text-html-renderer))
     ("text/x-vcard" mm-inline-text-vcard
      (lambda
	(handle)
	(or
	 (featurep
	  (quote vcard))
	 (locate-library "vcard"))))
     ("message/delivery-status" mm-inline-text identity)
     ("message/rfc822" mm-inline-message identity)
     ("message/partial" mm-inline-partial identity)
     ("message/external-body" mm-inline-external-body identity)
     ("text/.*" mm-inline-text identity)
     ("application/x-.?tar\\(-.*\\)?" ignore identity)
     ("application/zip" ignore identity)
     ("audio/wav" mm-inline-audio
      (lambda
	(handle)
	(and
	 (or
	  (featurep
	   (quote nas-sound))
	  (featurep
	   (quote native-sound)))
	 (device-sound-enabled-p))))
     ("audio/au" mm-inline-audio
      (lambda
	(handle)
	(and
	 (or
	  (featurep
	   (quote nas-sound))
	  (featurep
	   (quote native-sound)))
	 (device-sound-enabled-p))))
     ("application/pgp-signature" ignore identity)
     ("application/x-pkcs7-signature" ignore identity)
     ("application/pkcs7-signature" ignore identity)
     ("application/x-pkcs7-mime" ignore identity)
     ("application/pkcs7-mime" ignore identity)
     ("multipart/alternative" ignore identity)
     ("multipart/mixed" ignore identity)
     ("multipart/related" ignore identity)
     ("image/.*" mm-inline-image
      (lambda
	(handle)
	(and
	 (mm-valid-image-format-p
	  (quote imagemagick))
	 (mm-with-unibyte-buffer
	   (mm-insert-part handle)
	   (let
	       ((image
		 (ignore-errors
		   (if
		       (fboundp
			(quote create-image))
		       (create-image
			(buffer-string)
			(quote imagemagick)
			(quote data-p))
		     (mm-create-image-xemacs
		      (mm-handle-media-subtype handle))))))
	     (when image
	       (setcar
		(cdr handle)
		(list "image/imagemagick"))
	       (mm-image-fit-p handle)))))))
     ("audio/.*" ignore ignore)
     ("image/.*" ignore ignore)
     (".*" mm-inline-text mm-readable-p))))
 '(mm-inlined-types
   (quote
    ("text/calendar" "image/.*" "text/.*" "message/delivery-status" "message/rfc822" "message/partial" "message/external-body" "application/emacs-lisp" "application/x-emacs-lisp" "application/pgp-signature" "application/x-pkcs7-signature" "application/pkcs7-signature" "application/x-pkcs7-mime" "application/pkcs7-mime" "application/pgp")))
 '(mm-text-html-renderer (quote w3m))

 '(send-mail-function (quote sendmail-send-it))
 )
(setq mm-text-html-renderer-alist '((shr . mm-shr)
				    (w3 . mm-inline-text-html-render-with-w3)
				    (w3m . mm-inline-text-html-render-with-w3m)
				    (w3m-standalone . mm-inline-text-html-render-with-w3m-standalone)
				    (gnus-w3m . gnus-article-html)
				    (links mm-inline-render-with-file mm-links-remove-leading-blank "links" "-dump" file)
				    (lynx mm-inline-render-with-stdin nil "qutebrowser-call.sh")
				    (html2text mm-inline-render-with-function html2text)))
;; Inline images?
(setq mm-attachment-override-types '("image/.*"))
;; No HTML mail
(setq mm-discouraged-alternatives '("text/html" "text/richtext" "text/rtf" "application/zip" "image/vnd.djvu" "application/x-dvi" "application/postscript" ))
;; Don't start a browser for text/html only mail
(setq mm-automatic-display
      '("text/plain" "text/enriched"
	"image/.*" "message/delivery-status" "message/rfc822"
	"text/x-patch" "application/pgp-signature" "application/emacs-lisp"))
(setq mm-inline-large-images 'resize)
  #+end_src
**** Notmuch hello
:PROPERTIES:
:ID:       645a5628-289a-4373-9668-b79e10738215
:END:
#+begin_src emacs-lisp
(setq notmuch-hello-sections '(notmuch-hello-insert-header notmuch-hello-insert-saved-searches
                                                           notmuch-hello-insert-alltags)
      notmuch-saved-searches '((:name "todo" :query "tag:todo and tag:inbox" :sort-order newest-first)
			       (:name "work" :query "tag:todo or tag:inbox and not tag:private" :sort-order newest-first)
			       (:name "inbox" :query "tag:inbox" :key "i" :sort-order newest-first)
			       (:name "all mail" :query "*" :key "a")))
#+end_src
**** TODO Show accept/decline buttons for calendar invitations
:PROPERTIES:
:ID:       1735faf3-9249-43bd-ae32-8f30500210fe
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (use-package notmuch-calendar-x))
#+end_src
**** TODO Interaction with org
***** Capture mail to org task
:PROPERTIES:
:ID:       2d9b8481-b46c-47a9-9d19-6408c6a1e82d
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defun bh/capture-mail()
    "Capture mail to org mode."
    (interactive)
    (org-store-link nil)
    (org-capture nil "e")
    )
  (bind-key "t" 'bh/capture-mail notmuch-show-mode-map))
#+end_src
***** TODO Org mode list functionality when writing messages
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 16:16]
:ID:       119b23b6-1881-4446-847d-7baffbfc2c89
:END:
:LOGBOOK:
- State "TODO"       from              [2018-09-06 Thu 10:11]
:END:
Use =orgalist=.
#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :ensure org-plus-contrib
  :pin org
  :defer t
  :config
  (use-package orgalist :ensure t :init
	       (add-hook 'message-mode-hook 'orgalist-mode)))
#+end_src

** Org mode
:PROPERTIES:
:ID:       58045c39-ffd5-4ccc-bc9d-49048c437f42
:END:
This config is inspired by [[http://doc.norang.ca/org-mode.html][Bernt Hansen's config]].
*************** TODO Describe the workflow
:PROPERTIES:
:ID:       2b1456f8-c2fe-41ef-8d3d-99aa4adf362e
:END:
*************** END
#+begin_src emacs-lisp
(use-package org
  :if (or init-flag org-export-flag org-tangle-flag)
  :ensure org-plus-contrib
  :pin org
  :mode ("\\.org$" . org-mode)
  :config
#+end_src
*** Project management
:PROPERTIES:
:ID:       8cef1ba5-d5ea-4ad1-955b-932952c77b0c
:END:
I need to deal with many projects running at the same time in my work. Hence, I need some good structure for all these projects to keep track of deadlines, have all the notes to be able to recall what is going on in the project after some time. 
**** Tags
***** General org mode tags
:PROPERTIES:
:ID:       adc6f5ae-183f-4c5f-97e8-7bfe18f028d2
:END:
#+begin_src emacs-lisp
(setq org-tag-alist (quote (("COMMON" . ?c)
			    ("PhD" . ?p)
			    ("INBOX" . ?i)
			    ("TRACK" . ?t)
			    ("BOOKMARK" . ?b)
			    ("ORG" . ?o)
			    ("NOEXPORT" . ?n)
			    ("NODEADLINE" . ?d)
			    ("SKIP" . ?s)
                            ("NOARCHIVE" . ?a)
                            ("ARCHIVEALL" . ?A)
                            ("NOCLOCK" . ?k)
			    ("ignore" . ?g))))
#+end_src
- =COMMON= :: General task
- =PhD= :: Related to work/PhD
- =INBOX= :: Need to be processed (for new captured tasks)
- =TRACK= :: The link from this task/item should be monitored for changes in the internet
*************** TODO Need to add automatic handling of this
:PROPERTIES:
:ID:       27eb85b6-114f-437f-9424-b28d400f6aa9
:END:
*************** END
- =BOOKMARK= :: Contains link
- =ORG= :: if the task is not finished - include the org file linked during agenda creation if todo keyword is =NEXT=.
           The purpose of this tag is reduce the file size: I had a large database of books, which I've read/will read. The file with all the authors included was more than =2Mb=, which
           took forever to open and, more importantly, made my agenda view build/update time *few minutes*. So, I created separate project for different authors and kept the links to that
           projects with =ORG= tag assigned, so that I can add the author book list to file/agenda view if the project is =NEXT=.
*************** TODO add link management system
*************** TODO need to implement this (ORG tag)
:PROPERTIES:
:ID:       648e5339-0732-4464-80de-90a8f5f72467
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"       [2018-09-20 Thu 22:32]
:END:
Text properties: =modification-hooks=, =insert-in-front-hooks=, =insert-behind-hooks=
*************** END
- =NOEXPORT= :: Do not export an item
- =NODEADLINE= :: Do not show these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view 
- =SKIP= :: Some projects contains tasks, which can be done independently on each other. I want to see these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view even if the projects they belongs to has =NEXT= tasks.  
- =NOARCHIVE= :: Do not archive a task. This in not inherited.
- =ARCHIVE= :: Prevent task from unfolding (e.g. task contains bulky data, I do not want to see)
- =ARCHIVEALL= :: Do not archive individual tasks in the subtree. Only do it all together.
- =NOCLOCK= :: prevent entry from being clocked in automatically (after child task clock out [[id:d1afb1ae-a3a4-45b4-8186-8e7242e0edc1][Clocking & logging]]). This is not inherited.
- =DEFAULT= :: Do not list the task in GTD agenda
***** TODO Tags for everything
***** TODO try to implement multiple files/buffers in the same buffer via text properties like modification hooks |- (Special Properties - GNU Emacs Lisp Reference Manual) :BOOKMARK:
:PROPERTIES:
:CREATED:  [2018-02-12 Mon 00:51]
:Source:   https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html#Special-Properties
:END:
:LOGBOOK:
CLOCK: [2018-02-12 Mon 00:51]--[2018-02-12 Mon 00:52] =>  0:01
:END:
modified b
****** TODO may be useful |- (multifiles.el/multifiles.el at master · magnars/multifiles.el) :BOOKMARK:
:PROPERTIES:
:CREATED:  [2018-02-12 Mon 00:56]
:Source:   https://github.com/magnars/multifiles.el/blob/master/multifiles.el
:END:
fun create-or
**** Tasks
:PROPERTIES:
:ID:       d38441a2-1431-44db-b831-8cdec011b1dc
:END:
The task is any item with todo keyword and no subtask.
#+begin_src emacs-lisp
(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (member (org-get-todo-state) org-todo-keywords-1)
	    (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
#+end_src
- keywords for not done tasks: =TODO=, =NEXT=, =WAITING=, =HOLD=, =CANCELLED=, =DONE=, =FAILED=, =MERGED=
  #+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t!)" "NEXT(n!)" "|" "DONE(d!)" "FAILED(f!)" "MERGED(m!)" )
	      (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c!)" ))))
;; set the tags assigned to specific keywords. Not nesessary, but used by a lot of code for filtering later - hence why not
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
	      ("WAITING" ("WAITING" . t))
	      ("HOLD" ("WAITING") ("HOLD" . t))
	      (done ("WAITING") ("HOLD"))
	      ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("FAILED" ("WAITING") ("CANCELLED") ("HOLD"))
	      )))
  #+end_src
  - TODO(t) :: task which needs to be done
  - NEXT(n) :: Task which needs to be done next. If the task is scheduled it is most likely need to be done next. Though can change manually to =TODO= if needed. 
               #+begin_src emacs-lisp
(define-advice org-schedule (:after (&optional ARG TIME) change-todo-after-schedule-state-change) 
  "Make sure that task keyword is always TODO when it is not scheduled and NEXT if it is."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components))))
	(isscheduled (org-agenda-skip-entry-if 'scheduled)))
    (if (not isscheduled)
	(when (member mystate (list "NEXT"))
	  (org-todo "TODO"))
      (when (member mystate (list "TODO"))
	(org-todo "NEXT")))))
               #+end_src
  - WAITING(w) :: I am waiting for someone/something which does not depend on me to start the task (should add comment about reason) 
  - HOLD(h) :: I am not going to do this task for now due to reason explained in the comment
  - CANCELLED(c) :: I will never do this task because of what is in the comment
  - DONE(d) :: self explanatory
  - FAILED(f) :: there is some outcome and can mark done, but the outcome is not positive, though can get some conclusions out of it 
  - MERGED(m) :: become a part of other task. The link to the task is added to =MERGED-WITH= property. The motivation of adding this state is that I sometimes create a duplicate task, find out that it is duplicate, and confused which state to set. It is just faster to
                 set =MERGED= without deciding if it is =CANCELLED= (which is not really) or =DONE= (which is also not).
*************** TODO Prompt for the link to new task, default is clocked in task. Use helm search. Store link in property
*************** END
**** Inline tasks
:PROPERTIES:
:ID:       54ee8e08-0cb5-4104-94c2-948be5830c4e
:END:
I use inline tasks to add temporary todo state (instead of notes). It should be removed once done and placed into notes when archiving.
*************** TODO Implement this on inline task done
*************** END
#+begin_src emacs-lisp
(use-package org-inlinetask)
(setq org-inlinetask-default-state "TODO")
#+end_src

It seems that inline tasks interfers with =org-outline-regexp=.
Fix it:



#+begin_src emacs-lisp
(defun org-outline-regexp-no-inline ()
  "Return string matching an non-inline task heading.
The maximum number of levels is controlled by `org-inlinetask-min-level'."
  (let* ((org-inlinetask-min-level (- org-inlinetask-min-level 1))
	 (nstars (if org-odd-levels-only
		     (1- (* org-inlinetask-min-level 2))
		   org-inlinetask-min-level)))
    (format "^\\(\\*\\{1,%d\\}\\)[ \t]+" nstars)))
(define-advice org-back-to-heading (:around (oldfun &optional args) skip-inlinetasks)
  "Ignore preceding inline tasks when calling outline-back-to-heading."
  (if (org-inlinetask-in-task-p)
      (funcall oldfun args) ;; inside inlinetask - just go to heading
    (let ((outline-regexp (org-outline-regexp-no-inline)))
      (funcall oldfun args))))
#+end_src


**** TODO Task inheritance
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 06:10]
:ID:       d982166c-a450-4625-8211-ded63dc03f2d
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 17:59]
:END:
Some of the tasks cannot be done until some condition is met. Before that, it does not make too much sense to show it in agenda. 
I use [[http://www.nongnu.org/org-edna-el/][org-edna]] for managing dependencies. On top of blocked tasks management, it allows to schedule tasks on trigger. It introduces two new properties: =TRIGGER= and =BLOCKER= (see [[id:598c2b16-2eb8-404a-b7e9-00969a1c4d72][Properties]] for details)
#+BEGIN_SRC emacs-lisp
(use-package org-edna
  :ensure t
  :config
  (org-edna-load))
#+END_SRC
Also, the projects require all the children to be done by default.
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src
**** Habits
:PROPERTIES:
:ID:       fa036b84-f68e-485b-943c-d5d9ad79c516
:END:
Habits are regular tasks which are treated specially in agenda to show if I missed it.
#+begin_src emacs-lisp
(use-package org-habit)
(setq org-habit-graph-column 120)
#+end_src
Allow checklists to be reset in recurring tasks when =:RESET_CHECK_BOXES:= is =t=
#+begin_src emacs-lisp
(use-package org-checklist
  :config
  (add-to-list 'org-default-properties "RESET_CHECK_BOXES"))
#+end_src
**** Projects
:PROPERTIES:
:ID:       3edce153-2927-4a2d-8b45-87d9a6151913
:END:
The project is an item with todo keyword and subtask.
#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (member (org-get-todo-state) org-todo-keywords-1)
	    (setq has-subtask t))))
      (and is-a-task has-subtask))))
#+end_src
This approach is useful in the case if I place some todo under the wrong item during refiling. It will appear in the project list in such a case. Project cannot be =DONE= if any of subtasks is =TODO=, =NEXT=, =WAITING= or =HOLD= (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
***** Top level project
:PROPERTIES:
:ID:       aa2f80d5-d05c-418f-ac41-e1c6a138afcb
:END:
The project without parent projects.
#+begin_src emacs-lisp
(defun bh/find-project-task ()
  "Move point to the parent (project) task if any."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))
(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
			      (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
	  nil
	t))))
#+end_src

***** Sub-project
:PROPERTIES:
:ID:       32faf7a0-7af7-4bd9-973b-814549420e07
:END:
The project with parent projects.
#+begin_src emacs-lisp
(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
	(is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq is-subproject t))))
    (and is-a-task is-subproject)))
#+end_src
- if any task below is =NEXT= and the project is =TODO= then need to change to =NEXT= (it means that we need to do some task from this sub-project next) 
  #+begin_src emacs-lisp
(defun yant/mark-todo-parent-tasks-next ()
  "Visit each parent task and change TODO states to NEXT."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components)))))
    (when (member mystate (list "NEXT"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	    (unless (string= (org-get-todo-state) "NEXT")
	      (org-todo "NEXT"))))))
    (when (member mystate (list "TODO"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) (list "DONE"))
	    (org-todo "TODO")))))))
(add-hook 'org-after-todo-state-change-hook 'yant/mark-todo-parent-tasks-next 'append)
  #+end_src
***** TODO Standard projects
*** NEXT Journal
SCHEDULED: <2019-02-02 Sat>
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 18:19]
:ID:       46346e6b-4ed8-4570-bf4c-05639c125046
:END:
:LOGBOOK:
- State "NEXT"       from              [2018-10-23 Tue 18:50]
:END:

Sometimes, I do some trial tasks for my projects or just try random things with programming.
These things are unlikely to go into my actual notes or projects files. 
Not always though. 
It is always frustrating when I remember trying something and want to move it to actual notes of project file, but lose what I did. 

Journal seems to be a good solution for it. 
I can dump all kind of staff there instead of having it spread over the bash history or just lost.
I can write notes, run shell commands, calculations, etc without loosing what I have done. 
I may not even need to run terminal in such a case! 

#+begin_src emacs-lisp
#+end_src

*** TODO Files
:PROPERTIES:
:ID:       f1be655e-5fc4-44b5-8197-22ce9457e489
:END:
- TODO.org :: store new entries, general home and work entries, want todo some time entries
              #+begin_src emacs-lisp
(defun gtd-open ()
  (interactive)
  (find-file "~/Org/TODO.org"))
              #+end_src
- notes.org :: all kind of generally useful information
               #+begin_src emacs-lisp
(defun notes-open ()
  (interactive)
  (find-file "~/Org/notes.org"))
               #+end_src
- articles.org :: notes on research articles
- rss.org :: rss entries for [[id:9bc385e2-0ed2-460b-875e-be9ad19144a3][Elfeed]]
- *contacts.org* :: my contacts /via/ =org-contacts=
- *.org :: project specific entries
- all of it is in =agenda_files=
- we can add new org files and remove existing
#+begin_src emacs-lisp
(defun add-buffer-to-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (end-of-buffer)
	  (newline)
	  (insert file_name)
	  (message "%S is added to agenda_files" file_name)
	  )
	(when pos
	  (message "%S is already in agenda_files" file_name))
	)
      )
    )
  )
(defun add-current-buffer-to-agenda-files ()
  (interactive)
  (add-buffer-to-agenda-files (current-buffer))
  )
(defun remove-buffer-from-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (message "%S is not in agenda_files" file_name))
	(when pos
	  (beginning-of-buffer)
	  (delete-matching-lines file_name)
	  (message "%S is deleted from agenda_files" file_name)
	  )
	)
      )
    )
  )
(defun remove-current-buffer-from-agenda-files ()
  (interactive)
  (remove-buffer-from-agenda-files (current-buffer))
  )
#+end_src
*** Links
:PROPERTIES:
:ID:       7122dce7-7d3e-4167-a444-8811d588db42
:END:
**** NEXT Link description function
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:27]
:ID:       bd43272d-9ef4-45a6-85ab-bebbef75c18b
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2019-05-07 Tue 10:34]
:END:

*************** NEXT [#A] Probably request feature of :desk link property, similar to :complete property
SCHEDULED: <2019-05-11 Sat>
:PROPERTIES:
:SHOWFROMDATE: 2019-05-08 18:00
:END:
*************** END

#+begin_src emacs-lisp
(defun yant/org-make-link-description-function (link desk)
  "Return description of the link LINK according to :desk link property.
Return DESK if :desk is not set."
  (let ((fun (org-link-get-parameter (car (split-string link ":")) :desk)))
    (if (functionp fun)
	(funcall fun link desk)
      desk)))

(setq org-make-link-description-function #'yant/org-make-link-description-function)
#+end_src


**** External
:PROPERTIES:
:ID:       e74697d9-3d3e-4db4-8a4c-e9cad8f73d23
:END:
***** External apps
:PROPERTIES:
:ID:       2fe2cfaf-3ad4-4b87-99b1-2897e7c0bf20
:END:
Adjust some of the external application programs
#+begin_src emacs-lisp
(setq org-file-apps '((directory . emacs)
		      ("\\.mm\\'" . default)
		      ("\\.x?html?\\'" . default)
		      ("\\.pdf\\'" . default)
		      ("\\.mp4\\'" . "mpv %s")
		      ("\\.tiff?\\'" . "/home/yantar92/bin/feh-open %s")
		      ("\\.png?\\'" . "/home/yantar92/bin/feh-open %s")
		      )
      )
#+end_src
***** =Pdf-view= links
:PROPERTIES:
:ID:       f6b6301d-6ccb-4ee1-a454-ca6f5af845ea
:END:
Store links to pages in pdf
#+begin_src emacs-lisp
(use-package org-pdfview
  :if init-flag
  :ensure t)
(add-to-list 'org-file-apps '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))
#+end_src
***** Inkscape links
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 14:05]
:ID:       824be892-df30-4c07-bf02-93a234fb7885
:END:
Open and preview inkscape svg files.
Copy paste from https://github.com/jkitchin/scimax/blob/master/scimax-inkscape.el
#+BEGIN_SRC emacs-lisp
(use-package scimax-inkscape)
#+END_SRC

***** Links to attached files
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 21:46]
:ID:       1460419f-52b8-4687-955c-936a1f99ae7c
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-04-24 Wed 17:15]
- State "TODO"       from              [2018-07-23 Mon 15:33]
- State "TODO"       from              [2018-07-10 Tue 22:49]
CLOCK: [2018-07-09 Mon 21:47]--[2018-07-09 Mon 23:02] =>  1:15
- State "TODO"       from              [2018-07-09 Mon 21:47]
:END:

I have symlinks to the attached files stored in the directory tree mimicking org file structure (see [[id:9361bc68-010b-45f1-bddd-4638d6344758][Store files in folder structure, following my org tree structure]])
However, they can be moved upon refiling. 
Hence, it is better to avoid =file= links to the attached files.
Therefore, I define a new link type to the attached files of the current entry.

#+BEGIN_SRC emacs-lisp
(setq org-link-file-path-type 'relative)

(defun yant/process-att-abbrev (arg)
  "Return `org-attach-dir' for the current entry."
  (s-concat (let ((org-attach-dir-suppress-extra-checks t)) (org-attach-dir 'CREATE)) arg))

(add-to-list 'org-link-abbrev-alist (cons "att" "file:%(yant/process-att-abbrev)"))

(defun org-att-link-complete (&optional arg)
  "Completion function for att: link."
  (let* ((ref-dir (org-attach-dir 'CREATE))
	 (filelink (let ((default-directory ref-dir))
		     (org-file-complete-link)))
	 (filepath (apply #'s-concat (cdr (s-split ":" filelink)))))
    (format "att:%s" filepath)))

(org-link-set-parameters "att" 
			 :complete #'org-att-link-complete)
#+END_SRC

Just links to the current entry are not always sufficient. I sometimes want to link a file from another entry. 

#+begin_src emacs-lisp
(defun yant/process-att-id-abbrev (arg)
  "Return `org-attach-dir' for the entryin att-id: link type."
  (let ((id (car (s-split ":" arg)))
        (file (cadr (s-split ":" arg))))
    (s-concat (let ((org-attach-dir-suppress-extra-checks t))
		(org-with-point-at (org-id-find id 'marker)
		  (org-attach-dir 'CREATE)))
	      file)))

(add-to-list 'org-link-abbrev-alist (cons "att-id" "file:%(yant/process-att-id-abbrev)"))

(defun org-att-id-skip-function ()
  "Test if an entry contains attachments. Move point to next candidate location."
  (if (yant/org-task-has-attachments-p)
      't
    (and (search-forward org-attach-auto-tag nil 'noerror)
	 (beginning-of-line)
         (backward-char))))

(defvar org-att-id-history nil
  "ID completion history for att-id: link type.")

(defvar org-att-id-cache nil
  "ID completion cache for att-id: link type.")

(defun org-att-id-prompt-id ()
"Prompt for the id during completion of att-id: link."
(let ((org-refile-history org-att-id-history)
      (org-refile-cache org-att-id-cache)
      (org-refile-target-verify-function #'org-att-id-skip-function))
  (let ((prompt-ans (org-refile-get-location "Link to attachment from")))
    (prog1
	(org-id-get (seq-find #'markerp
			      prompt-ans))
      (setq org-att-id-history org-refile-history)
      (setq org-att-id-cache org-refile-cache)))))


(defun org-att-id-link-complete (&optional arg)
  "Completion function for att-id: link."
  (let* ((id (org-att-id-prompt-id))
	 (ref-dir (org-with-point-at (org-id-find id 'marker)
		    (org-attach-dir 'CREATE)))
	 (filelink (let ((default-directory ref-dir))
		     (org-file-complete-link)))
	 (filepath (apply #'s-concat (cdr (s-split ":" filelink)))))
    (format "att-id:%s:%s" id filepath)))

(org-link-set-parameters "att-id" 
			 :complete #'org-att-id-link-complete)

(org-link-set-parameters "id" 
			 :complete #'org-id-prompt-id)

#+end_src

**** Internal
:PROPERTIES:
:ID:       5aebc1b8-8d85-4254-b177-c216c053e8f3
:END:
***** Links by ID
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:05]
:ID:       0f7c34bc-bc56-4bbf-954e-b0e03e5240a2
:END:

#+begin_src emacs-lisp
(use-package org-id)
(setq org-id-method (quote uuidgen))
(setq org-id-link-to-org-use-id 't)
#+end_src
***** =id:= link completion
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:05]
:ID:       ffb27a1a-735e-4398-b230-a71fc4df0023
:END:

#+begin_src emacs-lisp
(defvar org-id-history nil
  "ID completion history for id: link type.")

(defvar org-id-cache nil
  "ID completion cache for id: link type.")

(defun org-id-prompt-id ()
  "Prompt for the id during completion of att-id: link."
  (let ((org-refile-history org-id-history)
	(org-refile-cache org-id-cache)
	(org-refile-target-verify-function nil))
    (let ((prompt-ans (org-refile-get-location "Select org entry")))
      (prog1
	  (or (org-id-get (seq-find #'markerp
				    prompt-ans)
			  'create)
              (user-error "Cannot find ID of the entry: %s" prompt-ans))
	(setq org-id-history org-refile-history)
	(setq org-id-cache org-refile-cache)))))


(defun org-id-link-complete (&optional arg)
  "Completion function for id: link."
  (let* ((id (org-id-prompt-id)))
    (format "id:%s" id)))

(defun org-id-link-desk (link desk)
  "Description function for id: link."
  (let ((id (cadr (split-string link ":"))))
    (org-with-point-at (org-id-find id 'marker)
      (s-replace "||" "/" (yant/task-fulltitle)))))

(org-link-set-parameters "id" 
			 :complete #'org-id-link-complete
                         :desk #'org-id-link-desk)

#+end_src

***** TODO Footnotes
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 21:45]
:ID:       343d5ae5-613f-4c1e-998d-91e5cd325053
:END:
:LOGBOOK:
- State "TODO"       from              [2018-10-23 Tue 21:45]
:END:

#+begin_src emacs-lisp
(setq org-footnote-section nil)
#+end_src
***** Src block links
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 14:37]
:ID:       b1ca3ea7-39ec-4489-8a67-8a01d4d61398
:END:

The links to run src blocks.
Useful if I want to run an src block when working on entry. 
Having a link, which runs blocks, allows to simply =C-c C-o= on the heading to follow this link.

#+begin_src emacs-lisp
(defun org-link-babel-follow (name &optional return-info)
  "Run src block NAME from babel:name link.
The NAME is parsed as in #+CALL: specification.
The src block should be in the same org file."
  (let* ((call (with-temp-buffer
		 (interactive)
		 (org-mode)
		 (insert "#+CALL: " (format "%s" (org-link-unescape name)) "\n")
		 (beginning-of-buffer)
		 (org-element-babel-call-parser (point-max) (list (point-min)))
		 ))
	 (info (org-babel-lob-get-info call)))
    (if return-info
	info
      (flet ((org-babel-insert-result (result &optional result-params info hash lang) nil))
	(org-babel-execute-src-block nil info)))))

  (defun org-link-babel-complete ()
    "Complete babel: link at point."
    (let* ((name (completing-read "Source block name: " (org-babel-src-block-names)))
	   (block-info (org-link-babel-follow (format "%s()" name) 'return-info))
           (block-lang (car block-info))
           (block-default-params (nth 2 block-info))
           (block-params (nth 2 (org-link-babel-follow (format "%s()" name) 'return-info))) ;; call again to make a new sequence
           (lang-headers-var (intern (concat "org-babel-header-args:" block-lang)))
           (lang-headers (when (boundp lang-headers-var) (eval lang-headers-var t)))
	   (headers-w-values (org-babel-combine-header-arg-lists
			      org-babel-common-header-args-w-values lang-headers))
           (headers (mapcar (apply-partially #'format ":%s") (mapcar #'symbol-name (mapcar #'car headers-w-values))))
           params)
      (while (not params)
	(setq params (org-completing-read "Header Arg: " (cons (format "Default: %s" block-params) headers)))
	(unless (string= params (format "Default: %s" block-params))
	  (let* ((args (cdr (assoc (intern (substring params 1)) headers-w-values)))
		 (args (if (listp args) args nil))
		 (arg (org-completing-read
		       (format "%s: " params)
		       (append (and args (mapcar #'symbol-name (apply #'append args)))
			       (list (alist-get (intern params) block-params))))))
            (setf (alist-get (intern params) block-params) arg)
            (setq params nil))))
      (setq params (seq-difference block-params block-default-params))
      (let ((var-params (alist-get :var params)))
	(setq params (seq-difference params (list (cons :var (alist-get :var params)))))
	(when params (setq params (s-join " " (mapcar (lambda (el) (format "%s %s" (car el) (cdr el))) params))))
	(when var-params (setq var-params (format "%s" var-params)))
	(format "babel:%s[%s](%s)" name (or params "") (or var-params "")))))

  (org-link-set-parameters "babel" 
			   :follow #'org-link-babel-follow
                           :complete #'org-link-babel-complete)
  
#+end_src
**** NEXT Org-ref
:PROPERTIES:
:ID:       f944c2c8-f1fa-49ea-ab24-bf1b018013f1
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-10-10 Wed 11:43]
- State "TODO"       from              [2018-03-12 Mon 18:04]
:END:
#+begin_src emacs-lisp
(use-package org-ref
  :if init-flag
  :ensure t
  :init
  (use-package lv :ensure t)
  :config
  (setq org-latex-prefer-user-labels t)
  (setq org-ref-show-broken-links nil) ;; it makes typing very slow if 't
  (use-package org-ref-pdf)
  (use-package org-ref-url-utils)
  (setq org-ref-bibliography-notes "~/Books/articles/articles.org"
	bibtex-completion-notes-path "~/Books/articles/articles.org"
	org-ref-default-bibliography '("~/Books/References.bib")
	org-ref-pdf-directory "~/Books/articles/_symlinks/"
        bibtex-completion-library-path org-ref-pdf-directory
	org-ref-note-title-format "** TODO [%A] %t\n    :PROPERTIES:\n    :Custom_ID: %k\n    :AUTHOR: %9a\n    :JOURNAL: %j\n    :YEAR: %y\n    :VOLUME: %v\n    :PAGES: %p\n    :DOI: %D\n    :URL: %U\n    :END:\n    ")
  (setq reftex-default-bibliography (quote ("~/Books/References.bib")))
  (bind-key* "C-c ]" #'org-ref-helm-insert-cite-link)
  (bind-keys :map org-mode-map
	     ("C-c [" . org-ref-helm-insert-ref-link))
  (bind-keys :map bibtex-mode-map ("C-c [" . helm-bibtex))
  (bind-keys :map pdf-view-mode-map ("C-c [" . org-ref-pdf-to-bibtex)))
#+end_src 
***** NEXT search in article pdfs
SCHEDULED: <2018-10-10 Wed>
:PROPERTIES:
:CREATED:  [2018-10-10 Wed 11:37]
:SHOWFROMDATE: 2018-10-11 18:00
:ID:       160da641-39cb-4ce9-b41f-da015d2fd0e8
:END:
:LOGBOOK:
CLOCK: [2018-10-10 Wed 12:30]--[2018-10-10 Wed 12:40] =>  0:10
:END:

- need to modify the lib to show abstracts (recollq -A)

#+BEGIN_SRC emacs-lisp
(use-package helm-recoll
  :config
  (helm-recoll-create-source "docs" "~/.recoll")
  (bind-key* "C-c }" 'helm-recoll-docs))
#+END_SRC
*** TODO Properties
:PROPERTIES:
:ID:       598c2b16-2eb8-404a-b7e9-00969a1c4d72
:END:
#+begin_src emacs-lisp 
(setq org-use-property-inheritance 't)
#+end_src
- =:SHOWFROMTIME:= (always inheriting) :: The purpose of this is to be able to assign specific projects for different days of week or, say, show the home items only in the evening of weekdays and not annoy it at work when I cannot do it any way. Hence, I can focus on the items I really need to do now in this agenda. 
     #+begin_src emacs-lisp
     (add-to-list 'org-default-properties "SHOWFROMTIME")
(defun org-agenda-skip-before-SHOWFROMTIME-property ()
  "Skip agenda item if :SHOWFROMTIME: property is set and time of day is before it"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (let ((showfromtime (parse-time-string (or (org-entry-get (point) "SHOWFROMTIME" 'inherit)
						 "00:00:01")))
	    (currenttime (parse-time-string (format-time-string "%T"))))
	(if (< (nth 2 currenttime) (nth 2 showfromtime))
	    next-headline
	  (if (< (nth 1 currenttime) (nth 1 showfromtime))
	      next-headline
	    (if (< (nth 0 currenttime) (nth 0 showfromtime))
		next-headline
	      nil)))))))
     #+end_src
- =:SHOWFROMDATE:= :: The purpose of this is to be able to postpone the scheduled tasks for future if I cannot do it. The property is formatted as an org date.
     This property is especially useful if there is something more pressing, so that there is a temptation to reschedule less pressing event to another day. If the more pressing task is done earlier than expected, the postponed tasks can be still find in normal agenda view (not in the [[id:ff70b03f-3876-4b2b-9aab-c3209bd31cb8][focused]] one).
     #+begin_src emacs-lisp
     (add-to-list 'org-default-properties "SHOWFROMDATE")
(bind-key "C-c C-f" #'org-command-set-SHOWFROMDATE-property org-mode-map)
(bind-key "C-c C-f" #'org-command-set-SHOWFROMDATE-property org-agenda-mode-map)
(add-to-list 'org-agenda-bulk-custom-functions '(?F org-command-set-SHOWFROMDATE-property))

(defun org-command-set-SHOWFROMDATE-property ()
  "Command to set :SHOWFROMDATE property for the org entry at point.
  If NOT-IN-AGENDA is not nil, do not check whether we are in agenda now."
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
	(org-agenda-check-no-diary)
	(let* ((marker (or (org-get-at-bol 'org-marker)
			   (org-agenda-error)))
	       (buffer (marker-buffer marker))
	       (pos (marker-position marker))
	       (inhibit-read-only t)
	       ts)
	  (org-with-remote-undo buffer
	    (with-current-buffer buffer
	      (widen)
	      (goto-char pos)
	      (org-show-context 'agenda)
	      (call-interactively 'org-command-set-SHOWFROMDATE-property)
              (setq ts (org-entry-get (point) "SHOWFROMDATE")))
            (org-agenda-show-new-time marker ts " P"))))
    (let ((property "SHOWFROMDATE"))
      (let ((value (org-read-property-value property))
	    (fn (cdr (assoc-string property org-properties-postprocess-alist t))))
	(setq org-last-set-property property)
	(setq org-last-set-property-value (concat property ": " value))
	;; Possibly postprocess the inserted value:
	(when fn (setq value (funcall fn value)))
	(unless (equal (org-entry-get nil property) value)
	  (org-entry-put nil property value))))))

(defun org-set-SHOWFROMDATE-property (PROMPT &rest args)
  "Read :SHOWFROMDATE: property."
  (org-read-date 'with-time nil nil PROMPT))

(add-to-list 'org-property-set-functions-alist '("SHOWFROMDATE" . org-set-SHOWFROMDATE-property))

(defun org-agenda-skip-before-SHOWFROMDATE-property ()
  "Skip agenda item if :SHOWFROMDATE: property is set and the day is before it"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (let ((showfromdate (org-read-date 't 't (or (org-entry-get (point) "SHOWFROMDATE")
						   "")))
	    (currenttime (org-read-date 't 't "")))
	(if (time-less-p currenttime showfromdate)
	    next-headline
	  nil)))))
     #+end_src
- =:SHOWDATES:= (always inheriting) :: It contains dairy =sexps= to set when the project should be shown. For example, I may want to work on Saturday once or twice, but the working items should not be shown on weekend normally. Hence, I can define it. Or some things can only be done on specific dates (say, going to some shop, which is open few days a week only) 
     #+begin_src emacs-lisp
     (add-to-list 'org-default-properties "SHOWDATES")
(defun org-agenda-skip-noshowdates()
  "Skip agenda item if :SHOWDATES: property sexp is not matching today"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	  (entry (org-entry-get (point) "SHOWDATES" 'inherit))
	  (date (diary-make-date (nth 4 (decode-time)) (nth 3 (decode-time)) (nth 5 (decode-time)))))
      (let ((result (and entry (pcase (eval (car (read-from-string entry)))
				 ((and (pred listp) res)
				  (cdr res))
				 (res res)))))
	(if (and entry (not result))
	    next-headline
	  nil)))))

(defun yant/daysofweek (&rest days)
  "Return 't if any of the listed weekdays (Mon, Tue, Wed, Thu, Fri, Sat, Sun) is today. Work only in the context of :SHOWDATES: property."
  (let ((data (list
	       (if (member "Mon" days) '(7 7 24 2017) nil)
	       (if (member "Tue" days) '(7 7 25 2017) nil)
	       (if (member "Wed" days) '(7 7 26 2017) nil)
	       (if (member "Thu" days) '(7 7 27 2017) nil)
	       (if (member "Fri" days) '(7 7 28 2017) nil)
	       (if (member "Sat" days) '(7 7 29 2017) nil)
	       (if (member "Sun" days) '(7 7 30 2017) nil))))
    (some #'(lambda (&rest args) (apply #'diary-cyclic (car args))) (remove nil data))))
     #+end_src
- =:CREATED:= :: Entry creation time. Inserted for all the new headings.
		 #+BEGIN_SRC emacs-lisp
   (defun yant/insert-heading-created-property (&optional time)
     "Add :CREATED: property to the task at point and set it to current time.
The property is set to TIME if it is supplied."
     (org-set-property "CREATED" (with-temp-buffer (org-insert-time-stamp time t t))))
   (add-hook 'org-insert-heading-hook 'yant/insert-heading-created-property 'append)
   #+END_SRC
- =:BLOCKER:= :: Conditions to be met before allowing the entry to be
                 marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]]) 
- =:TRIGGER:= :: Actions to be done when the item is marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
- =:MERGED-WITH:= :: If the task is marked =MERGED=, contains a link to the new task  
- =:SOURCE:= :: The link to the file/URL, which this task refers to
*** NEXT Attach
:PROPERTIES:
:ID:       bb8263f5-8ef4-4444-941c-9ffbb338185d
:END:
:LOGBOOK:
CLOCK: [2019-04-24 Wed 15:43]--[2019-04-24 Wed 15:46] =>  0:03
- State "NEXT"       from "TODO"       [2018-09-20 Thu 22:31]
- State "TODO"       from "NEXT"       [2018-09-20 Thu 22:17]
:END:
#+begin_src emacs-lisp
(use-package org-attach
  :config
#+end_src
**** Default attachment directory
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 16:12]
:ID:       3a0ca96a-3ce5-4f72-ba38-16990342fb5a
:END:

I try to store every possibe file in an attachment dir. 
The new files are usually coming from my Downloads (=yant/org-attach-default-source)= directory. 

#+BEGIN_SRC emacs-lisp
(defvar yant/org-attach-default-source "~/Downloads/"
  "Default directory to attach the files from.")

(define-advice org-attach-attach (:around (oldfun &rest args) start-from-default-directory)
  "Look for new attachments from `yant/org-attach-default-source' directory instead of `default-directory'."
  (interactive
   (list
    (directory-file-name (read-file-name "File to keep as an attachment:"
					 (or (progn
					       (require 'dired-aux)
					       (dired-dwim-target-directory))
					     (and yant/org-attach-default-source
						  (f-slash yant/org-attach-default-source))
					     default-directory)))
    current-prefix-arg
    nil))
  (apply oldfun args))
#+END_SRC

**** Make it possible to attach directories (not only files)
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 16:37]
:END:

The default =org-attach-attach= function does not allow to attach directories. 
I made it so in the interactive specification in [[id:3a0ca96a-3ce5-4f72-ba38-16990342fb5a][Default attachment directory]].

**** NEXT Store files in folder structure, following my org tree structure
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:11]
:ID:       9361bc68-010b-45f1-bddd-4638d6344758
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"          [2018-01-01 Mon 13:17]
:END:

I usually have a huge numbers of files, related to my projects. I would like to use attach to associate the files with the proper entry, but searching them later in my Dropbox is a pain because of the way Org saves the attachments. 
It makes more sense for me to make attachments follow the org tree structure in the project by default (unless I change the attach folder to something else). 

This can be done if we make attachment by creating a symbolic link to the attach folder in the place, according to the headline path.
This way allows to keep all the file attached to the project accessible with relative paths.

*************** TODO I do not handle the situation when the entry uid is being changed.. 
Try to look in symlinks?
*************** END

For the implementation, the idea is keeping all the actual attachments in a common folder for all the org files according to their uuid. As a result, I can safely refile tasks between different org files without worrying about moving the attachments around (assuming that there is not change in the task ids).

#+begin_src emacs-lisp
(setq org-attach-method 'mv)
(setq org-attach-store-link-p 't)
(setq org-attach-directory "~/.data/")
(require 'f)
(setq org-id-locations-file
      (f-join org-attach-directory ".org-id-locations"))
#+end_src

The above does not follow the task hierarchy of the tasks.
To implement this, for each task, I store the symlinks to the child tasks in the task's attachment directory.
Therefore, apart from the attachments, I have =yant/org-attach-symlinks-directory= folder in the task's attach dir.
This folder contains a back reference to the attachment dir (if there are attachments) =yant/org-attach-attachments-symlink-directory= and symlinks to the corresponding symlink folders of the children with attachments somewhere down the hierarchy.

Now, it is trivial to create the attachment hierarchy for any org file. I just make folders pointing to the =yant/org-attach-symlinks-directory== of the top level tasks either in the same folder with the org file or in =yant/org-attach-file-symlink-path= (file local).

#+BEGIN_SRC emacs-lisp
(setq org-attach-file-list-property nil)

(defvar-local yant/org-attach-file-symlink-path nil
  "Path to directory where the symlink hierarchy is created for the current org buffer.
It is intended to be set as a file-local variable.
Use `default-directory' if nil.")
(put 'yant/org-attach-file-symlink-path 'safe-local-variable 'stringp)

(defvar yant/org-attach-attachments-symlink-directory "_data"
  "Name of the symlink to the attach file folder.")
(defvar yant/org-attach-symlinks-directory ".org.symlinks"
  "Name of the folder containing symlinks to the entry children attach folders.")

(define-advice org-attach-file-list (:filter-return (filelist) remove-boring-files)
  "Remove local variable file and boring symlinks from the attachment file list."
  (let ((symlinks-directory yant/org-attach-symlinks-directory))
    (remove "flycheck_.dir-locals.el" ;; not sure where this constant is defined
	    (remove dir-locals-file
		    (remove symlinks-directory
			    filelist)))))

(defun yant/outline-get-next-sibling (&optional subtree-end)
  "A faster version of `outline-get-next-sibling'.
Bound search by SUBTREE-END if non nil."
  (let* ((level (funcall outline-level))
	 (sibling-regex (concat "^\\*\\{" (format "%d" level) "\\}[^*]"))
         (bound (or subtree-end (point-max))))
    (re-search-forward sibling-regex bound 'noerror)))

(defun yant/org-entry-name-cleanup-for-dir ()
  "Format entry name to make a directory. Return nil if the entry name is empty."
  (org-with-wide-buffer
   (let* ((entry-name (replace-regexp-in-string "[/<>|:&/]" "-" ;; make sure that entry title can be used as a directory name
						(org-get-heading 'NO-TAGS 'NO-TODO 'NO-PRIORITY 'NO-COMMENT)))
          (entry-name (replace-regexp-in-string " +\\[.+\\]$" "" ;; remove statistics cookies
						entry-name
						))
          (entry-name (replace-regexp-in-string org-bracket-link-analytic-regexp "\\5" ;; only leave the link names
						entry-name
						)))
     (unless (seq-empty-p entry-name) ;; prevent empty folders
       (set-text-properties 0 (length entry-name) nil entry-name)
       entry-name))))

(defun yant/org-subtree-has-attachments-p ()
  "Return non nil if the subtree at point has an attached file."
  (org-with-wide-buffer
   (when (eq major-mode 'org-mode) (org-back-to-heading))
   (let ((subtree-end (save-excursion (org-end-of-subtree))))
     (re-search-forward (format "^\\*+ +.*?[ 	]+.*?:%s:.*?$" org-attach-auto-tag) subtree-end 'noerror))))

(defun yant/org-task-has-attachments-p ()
  "Return non nil if the task at point has an attached file."
  (org-with-wide-buffer
   (when (eq major-mode 'org-mode) (org-back-to-heading))
   (member org-attach-auto-tag (org-get-tags nil t))))

(defvar yant/--processed-entry-ids nil
  "Variable used to store processed entry ids in `org-attach-dir@yant/org-attach-ensure-attach-dir-symlink'")

(define-advice org-attach-dir (:filter-return (dir) yant/org-attach-ensure-attach-dir-symlink)
  "Make sure that the attach DIR for the current entry has a link in the org structure based directory structure.
The DIR is ensured to be in the symlink mirror dir structure for the entry.
Do nothing if `org-attach-dir-suppress-extra-checks' is non-nil."
  (prog1
      (and dir
	   (f-slash dir))

    (when (and (equal major-mode 'org-mode)
	       dir
	       (not (bound-and-true-p org-attach-dir-suppress-extra-checks)) ;; an option to make `org-attach-dir' faster if needed
	       (f-exists-p dir)
	       (f-dir-p dir))
      (let* ((attach-path dir)
	     (symlinks-directory (f-slash (f-join dir
						  yant/org-attach-symlinks-directory)))
	     (attachments-symlink-directory (f-slash (f-join symlinks-directory
							     yant/org-attach-attachments-symlink-directory)))
	     (org-id (org-id-get nil 'create))
	     (entry-name (yant/org-entry-name-cleanup-for-dir))
	     (attach-dir-inherited-p (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
					  (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil)))) ;; only consider if the entry is the child
	     ;; (processed-entry-ids (when (boundp 'processed-entry-ids) processed-entry-ids)) ; keep track of the processed entries to avoid infinite recursion
	     (org-attach-dir-recursive-p (bound-and-true-p org-attach-dir-recursive-p))) ;; keep track if this is the initial call of the function
	(unless org-attach-dir-recursive-p (setq yant/--processed-entry-ids nil))
	(unless (member org-id yant/--processed-entry-ids)
	  (add-to-list 'yant/--processed-entry-ids org-id)
	  (unless attach-dir-inherited-p
	    (when (f-file-p symlinks-directory)
	      (error (format "File exist in place of dir: %s" symlinks-directory)))
	    (when (and (f-exists-p attachments-symlink-directory)
		       (not (f-symlink-p (directory-file-name attachments-symlink-directory))))
	      (error (format "Not a symlink: %s" attachments-symlink-directory)))

	    ;; update dirs
	    (unless (f-exists-p symlinks-directory)
	      (f-mkdir symlinks-directory))
	    (unless (or (f-exists-p attachments-symlink-directory)
			(not (yant/org-task-has-attachments-p)))
	      (f-symlink attach-path (directory-file-name attachments-symlink-directory)))
	    (when (and (f-exists-p attachments-symlink-directory)
		       (not (yant/org-task-has-attachments-p)))
	      (f-delete (directory-file-name attachments-symlink-directory)))

	    ;; add to parent entry attachment dir
	    (unless (seq-empty-p entry-name) ;; prevent empty folder names
	      (org-with-wide-buffer
	       (let ((entry-symlink-name (if (org-up-heading-safe)
					     (directory-file-name (f-join (let ((org-attach-dir-recursive-p t))
									    (org-attach-dir 'CREATE))
									  yant/org-attach-symlinks-directory
									  entry-name))
					   (or yant/org-attach-file-symlink-path (hack-local-variables))
					   (directory-file-name (f-join (or yant/org-attach-file-symlink-path
									    default-directory)
									entry-name)))))
		 (if (not (f-exists-p entry-symlink-name))
		     (f-symlink symlinks-directory entry-symlink-name)
		   (unless (f-symlink-p entry-symlink-name)
		     (error (format "File exists: %s" entry-symlink-name)))))))
	    
	    ;; check children
            (when (yant/org-subtree-has-attachments-p)
	      (let ((dirs (delete (directory-file-name attachments-symlink-directory)
				  (f-directories symlinks-directory))))
		(org-with-wide-buffer
		 (org-back-to-heading)
		 (let ((subtree-end (save-excursion (org-end-of-subtree))))
		   (forward-line 1)
		   (when (re-search-forward org-heading-regexp subtree-end t)
		     (while (< (point) subtree-end)
		       (when (yant/org-entry-name-cleanup-for-dir)
			 (let ((child-dir (f-join symlinks-directory (yant/org-entry-name-cleanup-for-dir))))
			   (when (yant/org-subtree-has-attachments-p)
			     (unless (member child-dir dirs)
			       (org-attach-dir 'create) ; call recursively
			       )
			     (setq dirs (delete child-dir dirs)))))
		       (or (yant/outline-get-next-sibling subtree-end)
			   (goto-char subtree-end))))))
		(mapc (lambda (d)
			(let ((dir (f-long d)))
			  (when (f-symlink-p (directory-file-name dir))
			    (f-delete dir) ; delete the dirs, which do not point to children
			    )))
		      dirs)))))))))
#+END_SRC

Now, when I have the mirror attach folder structure, it make sense to open this structure on =org-attach-reveal= instead of opening the actual attach dirs. 

#+BEGIN_SRC emacs-lisp  
(defun org-attach-dir-symlink (&optional create-if-not-exists-p no-data-dir)
  "Return symlink based path to the attach dir of current entry.
Do not append symlink to data directory if NO-DATA-dir is not nil."
  (let* ((entry-name (yant/org-entry-name-cleanup-for-dir))
	 (attach-dir-inherited-p (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
				      (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))));; only consider if the entry is the child
         (entry-path (and entry-name
			  (f-join entry-name (if no-data-dir "" yant/org-attach-attachments-symlink-directory)))))
    (if attach-dir-inherited-p
	(org-with-wide-buffer
         (org-up-heading-safe) ;; if this is false, something went really wrong
	 (org-attach-dir-symlink))
      (unless (seq-empty-p entry-name) ;; prevent empty folders
	(org-with-wide-buffer
	 (if (org-up-heading-safe)
	     (let ((head-path (org-attach-dir-symlink 'create 'no-data-dir)))
	       (when head-path (f-join head-path entry-path)))
           (f-join (or yant/org-attach-file-symlink-path
		       default-directory)
		   entry-path)))))))

(define-advice org-attach-reveal (:around (OLDFUN &optional if-exists) reveal-symlink)
  "Go to symlink attach dir structure instead of an actual attach dir."
  (let ((dir (org-attach-dir (not if-exists)))
	(attach-dir-inherited-p (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
				     (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))));; only consider if the entry is the child
	)
    (org-attach-sync)
    (letf (((symbol-function 'org-attach-dir) (if (yant/org-task-has-attachments-p)
						  #'org-attach-dir-symlink
						(lambda (&rest args)
                                                  (if (yant/org-subtree-has-attachments-p)
                                                      (org-attach-dir-symlink 't 't)
                                                    dir
                                                    )))))
      (when attach-dir-inherited-p (org-attach-tag 'off))
      (funcall OLDFUN if-exists))))

(define-advice org-attach-reveal-in-emacs (:around (OLDFUN &rest args) reveal-symlink)
  #'org-attach-reveal@reveal-symlink)
#+END_SRC



Files, out of the folder structure, will appear in my agenda to attach them to the relevant project (unless explicitly specified in special variable). 

***** TODO handle cases when we need files in the same dir with the org file [[id:9dc72877-1e7b-4084-a262-6e39b08ced49][LaTeX class]]
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 12:40]
:END:
:LOGBOOK:
CLOCK: [2018-07-09 Mon 12:40]--[2018-07-09 Mon 12:41] =>  0:01
:END:
***** TODO honor inherit export directory
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 13:01]
:END:
***** NEXT in org-attach, put the attachments directly into symlink if no children of the entry
SCHEDULED: <2019-02-02 Sat>
:PROPERTIES:
:CREATED:  [2018-08-26 Sun 22:40]
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-08-27 Mon 08:39]
:END:
**** Saving web pages into notes
:PROPERTIES:
:CREATED:  [2017-12-30 Sat 22:20]
:ID:       8e1af85e-3e47-40c3-9b33-34a5e848b483
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2018-09-06 Thu 20:53]
- State "TODO"       from              [2017-12-30 Sat 22:20]
:END:

Sometimes, I want to save certain interesting online articles to disk to make sure that all the content and comments are preserved regardless of the website changes. 

***** DONE [#A] org-webtools
CLOSED: [2019-04-24 Wed 15:43] SCHEDULED: <2019-04-24 Wed>
:PROPERTIES:
:CREATED:  [2019-04-23 Tue 23:44]
:ID:       f8a52437-48d9-418a-a00d-c1af5680c230
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2019-04-24 Wed 15:43]
CLOCK: [2019-04-24 Wed 15:23]--[2019-04-24 Wed 15:43] =>  0:20
- State "NEXT"       from "TODO"       [2019-04-23 Tue 23:45]
:END:

With =org-webtools=, I can download and attach web pages to an entry or even insert them converted into org format.

#+begin_src emacs-lisp
(use-package org-web-tools
  :if init-flag
  :ensure t
  :bind (:map org-mode-map
	      ("C-c C-S-u a" . org-web-tools-archive-attach)
              ("C-c C-S-u o" . org-web-tools-archive-view)
              ("C-c C-S-u i" . org-web-tools-insert-web-page-as-entry))
  :init
  (setq org-web-tools-pandoc-sleep-time 1.0)
  )
#+end_src
**** =_epilogue=
:PROPERTIES:
:ID:       fdd42cf4-96cb-4c9f-b855-3fb8437f9d9c
:END:
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** Agenda & scheduling
:PROPERTIES:
:ID:       ff70b03f-3876-4b2b-9aab-c3209bd31cb8
:END:
#+begin_src emacs-lisp
(require 'org-agenda)
(setq org-agenda-restore-windows-after-quit t)
(setq org-agenda-window-setup 'only-window)
(setq org-agenda-todo-list-sublevels t)
(setq org-agenda-show-inherited-tags nil)
(setq org-directory "~/Org")
(setq org-agenda-files "~/Org/agenda_files")
(setq org-deadline-warning-days 30)
(setq org-agenda-span 'day)
(setq org-agenda-sorting-strategy '((agenda deadline-down time-up habit-up priority-down timestamp-down category-keep)
				    (todo priority-down category-keep)
				    (tags priority-down category-keep)
				    (search category-keep)))
(setq org-agenda-tags-todo-honor-ignore-options t)
(setf org-agenda-sticky t)
(setq org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)
(setq org-habit-show-habits-only-for-today t) ; do not show habits in future if scheduled withing agenda time range. E.g. do not show future habits in week view/calendar
#+end_src
- I use several agenda views
  - Focused daily agenda :: When we mark the item scheduled, it means that we need to start working on it from that day. However, it leads to a situation when there are so many items being active in agenda that it is useful to focus on what we need to do during the day. That's why I need an additional agenda which focuses on what I really need to do today, but not what I need to start today and what I have started to do which is the case for default daily agenda. 
  - Normal daily agenda :: Standard agenda with minor tweaks.
  - Full agenda for GTD self-check :: see below.
  - List of projects agenda :: List of all active projects.
  - *Agenda view for captured tasks* :: tasks, which needs to be refiled (with =:INBOX:= tag)
- I use different skip functions here in agenda to filter the agenda. Some of them are used, some of them are just kept here for future if I need them. 
  #+begin_src emacs-lisp
  (defun bh/skip-non-stuck-projects-and-non-next-subprojects ()
    "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
					;      (if (bh/is-project-p)
	(if (and (bh/is-project-p)
		 (or (not (bh/is-subproject-p))
		     (member (org-get-todo-state) (list "NEXT"))))
	    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
		   (has-next ))
	      (save-excursion
		(forward-line 1)
		(while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
		  (unless (member "WAITING" (org-get-tags nil t))
		    (setq has-next t))))
	      (if has-next
		  next-headline
		nil)) ; a stuck project, has subtasks but no next task
	  next-headline))))
(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
;; (bh/list-sublevels-for-projects-indented)
  ;;  (if (save-restriction (bh/skip-non-stuck-projects-and-non-next-subprojects))
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((and (bh/is-project-p) (not (bh/is-subproject-p)))
	nil)
       (t
	subtree-end)))
    ))
(defun bh/skip-non-tasks ()
  "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
	nil)
       (t
	next-headline)))))
(defun bh/skip-subprojects ()
  "Show non-subproject tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((not (bh/is-subproject-p))
	nil)
       (t
	next-headline)))))

(defun yant/org-is-habit-p (&optional subtree-end pom)
  "Faster implementation of `org-is-habit-p'.
Returns t if entry at POM is habit.
SUBTREE-END is used as end of the entry if not nil."
  (save-excursion
    (and pom (goto-char pom))
    (re-search-forward "^ *:STYLE: +habit"
		       (or subtree-end
			   (save-excursion (or (outline-next-heading) (point-max))))
		       t)))

(defun bh/skip-habits ()
  "Skip habits"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (yant/org-is-habit-p next-headline)
	  next-headline
	nil))))

(defun bh/skip-nohabits ()
  "Skip not habits."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (yant/org-is-habit-p next-headline)
	  nil
	next-headline))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
	next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
	     (member "WAITING" (org-get-tags nil t)))
	next-headline)
       ((bh/is-project-p)
	next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
	next-headline)
       (t
	nil)))))
(defun zin/org-agenda-skip-tag (tag &optional others)
  "Skip all entries that correspond to TAG.
      If OTHERS is true, skip all entries that do not correspond to TAG."
  (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	(current-headline (or (and (org-at-heading-p)
				   (point))
			      (save-excursion (org-back-to-heading)))))
    (if others
	(if (not (member tag (org-get-tags current-headline)))
	    next-headline
	  nil)
      (if (member tag (org-get-tags current-headline))
	  next-headline
	nil))))
  #+end_src
  #+begin_src emacs-lisp
  (defvar bh/hide-scheduled-and-waiting-next-tasks 't)
(setq org-agenda-skip-function nil)
(define-advice org-agenda-skip (:before (&rest args) make-sure-right-org-environment)
  ""
  )
(setq org-agenda-custom-commands
      (quote (("a" nil
	       agenda "-HOLD-WAITING/!"
	       ((org-agenda-skip-function '(or (org-agenda-skip-before-SHOWFROMDATE-property)
					       (org-agenda-skip-before-SHOWFROMTIME-property)
					       (org-agenda-skip-noshowdates)))))
	      ("p" "Projects" tags-todo "-CANCELLED/!"
	       ((org-agenda-overriding-header "Project list")
		(org-agenda-prefix-format "%?-12t")
		(org-agenda-skip-function 'bh/skip-non-projects)
		(org-agenda-sorting-strategy
		 '(todo-state-down effort-up category-keep))))
	      ("d" "Focus daily agenda" agenda ""
	       ((org-agenda-skip-function 'yant/org-agenda-skip-nofocus)))
	      ("i" "Inbox items"
	       ((tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "Inbox")
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notscheduled)))
		       (org-agenda-prefix-format "S\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notdeadline)))
		       (org-agenda-prefix-format "D\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'scheduled 'deadline)))
		       (org-agenda-prefix-format "\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))))
	      (" " "Agenda"
	       ((agenda ""
			((org-agenda-prefix-format "%-12s\t%-12:c\t%?-12t")
			 (org-agenda-skip-function '(zin/org-agenda-skip-tag "HOLD"))))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "Inbox")
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))
			    (org-agenda-prefix-format "S\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
			    (org-agenda-prefix-format "D\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))
			    (org-agenda-prefix-format "\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "-CANCELLED-WAITING-HOLD/!"
			   ((org-agenda-overriding-header "Stuck Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-stuck-projects-and-non-next-subprojects)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(category-keep))))
		(tags-todo "-CANCELLED+WAITING|HOLD/!"
			   ((org-agenda-overriding-header (concat "Waiting and Hold Tasks" ""))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-use-tag-inheritance nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
			    (org-tags-match-list-sublevels nil)
			    (org-agenda-sorting-strategy
			     '(todo-state-down))))
		(tags-todo "-CANCELLED-HOLD-WAITING/!NEXT"
			   ((org-agenda-overriding-header (concat "Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))
		(tags "/"
		      ((org-agenda-overriding-header "Tasks to Archive")
		       (org-agenda-prefix-format "%-12:c\t%?-12t")
		       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		       (org-tags-match-list-sublevels nil)))
		(tags-todo "-CANCELLED/!"
			   ((org-agenda-overriding-header "Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-projects)
			    (org-agenda-sorting-strategy
			     '(todo-state-down effort-up category-keep))))
		(tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT/!"
			   ((org-agenda-overriding-header "All other active tasks")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits)))))))
	       nil))))
  #+end_src
**** Focused daily agenda
:PROPERTIES:
:ID:       a6054643-449e-48d7-afff-4155465efc19
:END:
This agenda show the items for the current day and time.
+ all the items with deadline, according =org-deadline-warning-days=, unless the item is scheduled. If the item is scheduled, it is shown from the scheduled day.
  #+begin_src emacs-lisp
(defun org-agenda-skip-deadlines-before-schedule ()
  "Skip tasks, with deadline and scheduled in future and tasks without deadline."
  (require 'org-agenda)
  (save-restriction
    (let* ((tmp-deadline-time (flet ((org-back-to-heading (&rest args) t)) ; we should be at heading already and it consumes too much times otherwise
				(org-get-deadline-time (point))))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-deadline (time-to-days tmp-deadline-time))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (when (or
	     (not tmp-deadline-time)
	     (and
	      tmp-scheduled-time
	      tmp-deadline-time
	      (> tmp-cur-schedule tmp-cur-day)
	      ;;(> tmp-cur-deadline tmp-cur-day)
	      ))
	(re-search-forward (org-get-limited-outline-regexp) nil 'noerror)
	(point)))))
  #+end_src
  
+ all [#A] priority items, with matching =:SHOWDATES:= and =:SHOWFROMTIME:=, unless they are scheduled in the future
  #+begin_src emacs-lisp
(defun org-agenda-skip-nonurgent ()
  (save-excursion
    (let* ((cur-priority (org-entry-get (point) "PRIORITY"))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (unless (and (string-equal cur-priority "A")
		   (or (not tmp-scheduled-time)
		       (<= tmp-cur-schedule tmp-cur-day)))
	(unless (re-search-forward "^\\*.+\\[#A\\]" nil 'noerror)
	  (re-search-forward (org-get-limited-outline-regexp) nil 'noerror))
	(point)))))

(defun org-agenda-skip-nonurgent-fast ()
  (save-excursion
    (let ((element (org-element-at-point)))
      (unless (or (eq (car element) 'inlinetask)
		  (eq (car element) 'headline))
        (org-back-to-heading)
        (setq element (org-element-at-point)))
      (let* ((cur-priority (string (or (org-element-property :priority element)
				       org-default-priority)))
             (tmp-scheduled-time-element (org-element-property :raw-value
							       (org-element-property :scheduled
										     element)))
             (tmp-scheduled-time (and tmp-scheduled-time-element (org-parse-time-string tmp-scheduled-time-element)))
	     (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	     (tmp-cur-day (time-to-days (apply #'encode-time
					       (append '(0 0 0)
						       (list (nth 1 org-agenda-current-date))
						       (list (nth 0 org-agenda-current-date))
						       (list (nth 2 org-agenda-current-date)))))))
	(unless (and (string-equal cur-priority "A")
		     (or (not tmp-scheduled-time)
			 (<= tmp-cur-schedule tmp-cur-day)))
	  (unless (re-search-forward "^\\*.+\\[#A\\]" nil 'noerror)
	    (re-search-forward (org-get-limited-outline-regexp) nil 'noerror))
	  (point))))))
  #+end_src

*************** NEXT [#A] debug org-agenda-skip-nonurgent-fast
SCHEDULED: <2019-05-05 Sun>
:PROPERTIES:
:SHOWFROMDATE: 2019-05-11
:END:
:LOGBOOK:
CLOCK: [2019-05-06 Mon 12:49]--[2019-05-06 Mon 14:14] =>  1:25
CLOCK: [2019-05-06 Mon 11:34]--[2019-05-06 Mon 11:53] =>  0:19
- State "NEXT"       from "TODO"       [2019-05-05 Sun 18:42]
:END:
*************** END


+ none of [#C] priority items
#+BEGIN_SRC emacs-lisp
(defun org-agenda-skip-lowpriority ()
  (save-restriction
    (widen)
    (let* (
	   (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (cur-priority (org-entry-get (point) "PRIORITY")))
      (if (string-equal cur-priority "C")
	  next-headline
	nil))))
#+END_SRC
+ all the items scheduled for today and matching =:SHOWFROMTIME:=
  #+begin_src emacs-lisp
  (defun org-agenda-skip-not-today ()
    "Skip items which a not scheduled today."
    (save-restriction
      (widen)
      (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	     (scheduleddate (subseq (decode-time (org-get-scheduled-time (point))) 3 6))
	     (currentdate	(list (nth 1 org-agenda-current-date) (nth 0 org-agenda-current-date) (nth 2 org-agenda-current-date)))
	     )
	(if (equal scheduleddate currentdate) nil next-headline))))
  #+end_src
+ items from diary/with timestamps (shown by default in org)
+ habits
  #+begin_src emacs-lisp
(defun yant/org-agenda-skip-nofocus()
  "Filter tasks for focus agenda."
  (and
   (or
    (and
     (org-agenda-skip-nonurgent) ; show urgent items
     (bh/skip-nohabits) ; and habits
     )
					;  if day and time are appropriate
    (org-agenda-skip-before-SHOWFROMTIME-property)
    (org-agenda-skip-before-SHOWFROMDATE-property)
    (org-agenda-skip-noshowdates))
   (or
    (org-agenda-skip-not-today) ; and items, scheduled for today
    (org-agenda-skip-before-SHOWFROMTIME-property) ; if time is appropriate (day is, since it is scheduled)
    (org-agenda-skip-before-SHOWFROMDATE-property)
    (org-agenda-skip-lowpriority) ;; and the priorty is not [#C]
    )
   (or (org-agenda-skip-deadlines-before-schedule) ; always show deadlines, unless scheduled in future
       (org-agenda-skip-before-SHOWFROMTIME-property)
       (org-agenda-skip-before-SHOWFROMDATE-property)
       )))
  #+end_src
**** Normal daily agenda
:PROPERTIES:
:ID:       f50074e7-42b2-4da5-9421-04ec9deccf07
:END:
This is a standard org mode agenda showing deadlines, schedules, diary items and items with timestamps.
#+begin_src emacs-lisp
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-include-inactive-timestamps nil)
#+end_src
**** GTD self-check
:PROPERTIES:
:ID:       d110dae9-f563-48bb-8293-a10b1afbe772
:END:
1. Full daily agenda without hold tasks
2. =INBOX= items to refile to other places
   - scheduled
   - with deadline
   - not scheduled
3. Next tasks which are not yet scheduled
4. Done tasks to archive, unless have =:NOARCHIVE:= tag.
5. Project list
6. Waiting and hold tasks, which are not scheduled
7. Other tasks which are not part of project or has =SKIP= tag. Useful to catch wrong refiles and look for the new things to do. Blocked tasks are not shown here.

**** Captured items, which should be refiled
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 22:28]
:ID:       18a47cca-2dfa-4e27-9814-a2edfd54a9f4
:END:
These items should have =:INBOX:= tag. Also, if both project and subproject have =:INBOX:= tag, only topmost project should be refiled.
#+BEGIN_SRC emacs-lisp
(defun yant/org-agenda-inbox-items ()
  "Only show items with INBOX tag, which parents does not have this tag."
  (save-excursion
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point)))
	    (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	    result)
	(if (not (member "INBOX" (org-get-tags)))
	    next-headline
	  (while (and (not result)
		      (org-up-heading-safe))
	    (when (member "INBOX" (org-get-tags))
	      (setq result next-headline)))
	  result)))))
#+END_SRC

Since my org files are really very large, it usually takes a lot of time to rebuild agenda. In the case of refiling, the =org-agenda-refile= rebuilds the agenda after each refiling, which really slows down my refile workflow. Hence, I disable redoing the current agenda after running =org-agenda-refile= or =org-agenda-bulk-action=.

#+begin_src emacs-lisp
(defun yant/org-agenda-refile (&optional arg)
  (interactive "P")
  (funcall-interactively #'org-agenda-refile arg nil 'no-update))

(bind-key "C-c C-w" #'yant/org-agenda-refile org-agenda-mode-map)
(bind-key "C-c w" #'yant/org-agenda-refile org-agenda-mode-map)

(define-advice org-agenda-bulk-action (:around (oldfun &optional arg) disable-org-agenda-redo)
  "Disable `org-agenda-redo' for all the bulk actions."
  (flet ((org-agenda-redo () "" nil))
    (funcall oldfun)))
#+end_src

**** TODO Ever standing project list
**** =CalFW=
:PROPERTIES:
:ID:       1d03f6e7-0f52-4aad-926e-a6762cd2d7dc
:END:
Agenda is excellent for short term planning, however it is not very useful if I need to schedule something, say, for 3 month later. I prefer something like normal calendar with short summary of the scheduled tasks to plan the task being scheduled.
#+begin_src emacs-lisp
(use-package calfw
  :if init-flag
  :ensure t
  :config
  (use-package calfw-org
    :ensure t
    :config
    (setq calendar-week-start-day 1)
    (defun cfw:open-calendar ()
      (interactive)
      (let ((cp
	     (cfw:create-calendar-component-buffer
	      :view 'week
	      :contents-sources
	      (list 
	       (cfw:org-create-source)))))
	(switch-to-buffer (cfw:cp-get-buffer cp))))
    (use-package boon
      :config
      (bind-key "A" 'cfw:open-calendar 'boon-goto-map))
    (custom-set-faces
     '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
     '(cfw:face-header ((t (:foreground "#d0bf8f" :weight bold))))
     '(cfw:face-sunday ((t :foreground "#cc9393" :background "grey10" :weight bold)))
     '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "grey10" :weight bold)))
     '(cfw:face-holiday ((t :background "grey10" :foreground "#8c5353" :weight bold)))
     '(cfw:face-grid ((t :foreground "DarkGrey")))
     '(cfw:face-default-content ((t :foreground "#bfebbf" :height 0.7)))
     '(cfw:face-periods ((t :foreground "cyan")))
     '(cfw:face-day-title ((t :background "grey10")))
     '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
     '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
     '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
     '(cfw:face-today-title ((t :background "#7f9f7f" :weight bold)))
     '(cfw:face-today ((t :background: "grey10" :weight bold)))
     '(cfw:face-select ((t :background "#2f2f2f")))
     '(cfw:face-toolbar ((t :foreground "Steelblue4" :background "Steelblue4")))
     '(cfw:face-toolbar-button-off ((t :foreground "Gray10" :weight bold)))
     '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold))))
    ;; Unicode characters
    (setq cfw:fchar-junction ?╋
	  cfw:fchar-vertical-line ?┃
	  cfw:fchar-horizontal-line ?━
	  cfw:fchar-left-junction ?┣
	  cfw:fchar-right-junction ?┫
	  cfw:fchar-top-junction ?┯
	  cfw:fchar-top-left-corner ?┏
	  cfw:fchar-top-right-corner ?┓)))
#+end_src
**** TODO =Gcal= - sync with Google calendar
:PROPERTIES:
:ID:       b66193fa-9189-4822-b68f-87f5bc30c3fd
:END:
:LOGBOOK:
- State "TODO"       from              [2019-05-10 Fri 00:23]
:END:
***** General setup
:PROPERTIES:
:ID:       9eda87f8-8e84-4b3d-b5a6-876ba287c7bb
:END:
#+begin_src emacs-lisp
(use-package org-gcal
  :if init-flag
  :ensure t
  :config
  (setq org-gcal-down-days 360)
  (setq org-gcal-sync-idle-secs (* 60 20)) ; 20 min
  (defun org-gcal-sync-enable ()
    "Enable gcal idle sync."
    (interactive)
    (setq org-gcal-sync-timer
	  (run-with-idle-timer org-gcal-sync-idle-secs t
			       'org-gcal-sync)))
  (defun org-gcal-sync-disable ()
    "Disable mobile org idle sync."
    (interactive)
    (cancel-timer org-gcal-sync-timer))
  (org-gcal-sync-enable))
#+end_src
***** TODO Avoid duplicates in agenda for gcal entries and other entries
Usually, I have some events scheduled locally in my computer and some are scheduled in Google calendar. Of course, I want to see both. It is easy - just add my gcal org file to agenda. However, the problem appears when I want to see locally scheduled events in Google Calendar (for mobile notifications). In such a case I need to copy the entries from my local org files to GCal. In such a case, these entries appears in my local agenda twice, which is annoying.
***** Suppress =libnotify= notifications
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 21:18]
:ID:       a818576a-f55a-428b-86e9-0df97ae445c1
:END:
#+BEGIN_SRC emacs-lisp
(define-advice org-gcal--notify (:around (OLDFUN &rest args) org-gcal-force-message-notifications)
  "Force org-gcal to use message area notifications, not libnotify (it is too spammy)."
  (let ((alert-default-style 'message))
    (apply OLDFUN args)))
#+END_SRC
**** Handling different time zones in time stamps :ARCHIVE:
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 18:36]
:END:
It is sometimes very annoying when org mode assumes that all the time
stamps are in local time zone. Foe example, I have a round flight, and
want to schedule it to not forget coming back ;). But the timing will
be shifted for return flight if I go to different time zone. Hence I
would like to have some way to fix the time zone of time stamp. I do
it by defining time stamp like =<YYYY-MM-DD HH:MM #TIMEZONE#>=, where
=TIMEZONE= is time zone as in =/usr/share/zoneinfo=.
It is implemented by wrapping the hook to correct the time around
=org-parse-time-string=, which seems to be enough to correct org mode
behavior. The stamps without time are not parsed (how?).
*************** NEXT [#A] Make sure it works
SCHEDULED: <2017-12-23 Sat>
:LOGBOOK:
CLOCK: [2017-12-24 Sun 15:55]--[2017-12-24 Sun 17:52] =>  1:57
CLOCK: [2017-12-24 Sun 15:24]--[2017-12-24 Sun 15:54] =>  0:30
CLOCK: [2017-12-24 Sun 15:00]--[2017-12-24 Sun 15:24] =>  0:24
CLOCK: [2017-12-24 Sun 11:51]--[2017-12-24 Sun 13:15] =>  1:24
CLOCK: [2017-12-24 Sun 09:26]--[2017-12-24 Sun 10:12] =>  0:46
CLOCK: [2017-12-24 Sun 08:23]--[2017-12-24 Sun 09:26] =>  1:03
CLOCK: [2017-12-24 Sun 08:01]--[2017-12-24 Sun 08:09] =>  0:08
:END:
- agenda does not use =org-parse-time-string= to find displayed string
  in timeline, even though task will be shown/not shown respecting time zone
*************** END
#+begin_src emacs-lisp :tangle no
;; force matching of time zone formatted time stamps
(setf org-scheduled-time-hour-regexp (concat "\\<" org-scheduled-string
					     " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(setf org-deadline-time-hour-regexp (concat "\\<" org-deadline-string
					    " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-parse-timezone)
  "Convert time stamp to local time if time zone information is present.
Do not handle time stamps without time.
Time zone is located like '<YYYY-MM-DD HH:MM #TIMEZONE#>'.
TIMEZONE is according to system timezone format (as accepted by `current-time-zone')."
  (let ((return-val (funcall oldfun s NODEFAULT)))
    (if (and (string-match org-ts-regexp0 s)
	     (not NODEFAULT))
	(if (string-match "#\\([^#]+\\)#" s)
	    (let ((result (decode-time (- (float-time (apply 'encode-time
							     return-val))
					  (- (car (current-time-zone nil (match-string 1 s)))
					     (car (current-time-zone)))))))
	      (setf (car result) 0)
              (append (butlast result 3) '(nil nil nil)))
	  return-val)
      return-val)))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-convert-atpm-to-24)
  "Honor am/pm format by `org-parse-time-string'."
  (let* ((match (string-match " *#[^#]+#" s)) ; avoid infinite recursion loop with time zone parsing in `org-get-time-of-day'
	 (timeofday (org-get-time-of-day (if match
					     (replace-match "" nil nil s)
					   s)
					 'string)))
    (if (or (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *" s)
	    (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *" s))
	(funcall oldfun (replace-match timeofday nil nil s) NODEFAULT)
      (funcall oldfun s NODEFAULT))))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-timestamp-parse-no-date)
  "Make `org-parse-time-string' work with time stamps without date (just consider today)."
  (when (and (not (string-match "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}" s))
	     (or (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *\\)" s)
		 (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *\\)" s)))
    (setf s (replace-match (concat (format-time-string "%Y-%m-%d %a " (org-matcher-time "<today>"))
				   "\\&")
			   nil nil s)))
  (funcall oldfun s NODEFAULT))

(define-advice org-get-time-of-day (:around (oldfun s &optional string mod24) org-timestamp-convert-to-local-timezone)
  "Convert time stamp with #TIMEZONE# to time stamp in local time zone."
  (if (string-match "#[^#]+#" s)
      (funcall oldfun (format-time-string "%Y-%m-%d %k:%M"
					  (apply #'encode-time
						 (org-parse-time-string s)))
	       string mod24)
    (funcall oldfun s string mod24)))
#+end_src
Unfortunately, =org-agenda-get-scheduled= has hard coded setting to
calculate time of the entry and not respecting =org-parse-timestring= or
=org-get-time-of-day=. Hence, I need to rewrite it just for sake of
changing =(concat (substring s (match-beginning 1)) " "))= into =(concat
(org-get-time-of-day s t) " ")).= 
#+begin_src emacs-lisp :tangle no
(defun org-agenda-get-scheduled (&optional deadlines with-hour)
  "Return the scheduled information for agenda display.
Optional argument DEADLINES is a list of deadline items to be
displayed in agenda view.  When WITH-HOUR is non-nil, only return
scheduled items with an hour specification like [h]h:mm."
  (let* ((props (list 'org-not-done-regexp org-not-done-regexp
		      'org-todo-regexp org-todo-regexp
		      'org-complex-heading-regexp org-complex-heading-regexp
		      'done-face 'org-agenda-done
		      'mouse-face 'highlight
		      'help-echo
		      (format "mouse-2 or RET jump to Org file %s"
			      (abbreviate-file-name buffer-file-name))))
	 (regexp (if with-hour
		     org-scheduled-time-hour-regexp
		   org-scheduled-time-regexp))
	 (today (org-today))
	 (todayp (org-agenda-today-p date)) ; DATE bound by calendar.
	 (current (calendar-absolute-from-gregorian date))
	 (deadline-pos
	  (mapcar (lambda (d)
		    (let ((m (get-text-property 0 'org-hd-marker d)))
		      (and m (marker-position m))))
		  deadlines))
	 scheduled-items)
    (goto-char (point-min))
    (while (re-search-forward regexp nil t)
      (catch :skip
	(unless (save-match-data (org-at-planning-p)) (throw :skip nil))
	(org-agenda-skip)
	(let* ((s (match-string 1))
	       (pos (1- (match-beginning 1)))
	       (todo-state (save-match-data (org-get-todo-state)))
	       (donep (member todo-state org-done-keywords))
	       (show-all (or (eq org-agenda-repeating-timestamp-show-all t)
			     (member todo-state
				     org-agenda-repeating-timestamp-show-all)))
	       ;; SCHEDULE is the bare scheduled date, i.e., without
	       ;; any repeater if non-nil, or last repeat if SHOW-ALL
	       ;; is nil.  REPEAT is the closest repeat after CURRENT,
	       ;; if all repeated time stamps are to be shown, or
	       ;; after TODAY otherwise.  REPEAT only applies to
	       ;; future dates.
	       (schedule (if show-all (org-agenda--timestamp-to-absolute s)
			   (org-agenda--timestamp-to-absolute
			    s today 'past (current-buffer) pos)))
	       (repeat (cond ((< current today) schedule)
			     (show-all
			      (org-agenda--timestamp-to-absolute
			       s current 'future (current-buffer) pos))
			     (t
			      (org-agenda--timestamp-to-absolute
			       s today 'future (current-buffer) pos))))
	       (diff (- current schedule))
	       (warntime (get-text-property (point) 'org-appt-warntime))
	       (pastschedp (< schedule today))
	       (habitp (and (fboundp 'org-is-habit-p) (org-is-habit-p)))
	       (suppress-delay
		(let ((deadline (and org-agenda-skip-scheduled-delay-if-deadline
				     (org-entry-get nil "DEADLINE"))))
		  (cond
		   ((not deadline) nil)
		   ;; The current item has a deadline date, so
		   ;; evaluate its delay time.
		   ((integerp org-agenda-skip-scheduled-delay-if-deadline)
		    ;; Use global delay time.
		    (- org-agenda-skip-scheduled-delay-if-deadline))
		   ((eq org-agenda-skip-scheduled-delay-if-deadline
			'post-deadline)
		    ;; Set delay to no later than DEADLINE.
		    (min (- schedule
			    (org-agenda--timestamp-to-absolute deadline))
			 org-scheduled-delay-days))
		   (t 0))))
	       (ddays
		(cond
		 ;; Nullify delay when a repeater triggered already
		 ;; and the delay is of the form --Xd.
		 ((and (string-match-p "--[0-9]+[hdwmy]" s)
		       (> current schedule))
		  0)
		 (suppress-delay
		  (let ((org-scheduled-delay-days suppress-delay))
		    (org-get-wdays s t t)))
		 (t (org-get-wdays s t)))))
	  ;; Display scheduled items at base date (SCHEDULE), today if
	  ;; scheduled before the current date, and at any repeat past
	  ;; today.  However, skip delayed items and items that have
	  ;; been displayed for more than `org-scheduled-past-days'.
	  (unless (and todayp
		       habitp
		       (bound-and-true-p org-habit-show-all-today))
	    (when (or (and (> ddays 0) (< diff ddays))
		      (> diff org-scheduled-past-days)
		      (> schedule current)
		      (and (< schedule current)
			   (not todayp)
			   (/= repeat current)))
	      (throw :skip nil)))
	  ;; Possibly skip done tasks.
	  (when (and donep
		     (or org-agenda-skip-scheduled-if-done
			 (/= schedule current)))
	    (throw :skip nil))
	  ;; Skip entry if it already appears as a deadline, per
	  ;; `org-agenda-skip-scheduled-if-deadline-is-shown'.  This
	  ;; doesn't apply to habits.
	  (when (pcase org-agenda-skip-scheduled-if-deadline-is-shown
		  ((guard
		    (or (not (memq (line-beginning-position 0) deadline-pos))
			habitp))
		   nil)
		  (`repeated-after-deadline
		   (>= repeat (time-to-days (org-get-deadline-time (point)))))
		  (`not-today pastschedp)
		  (`t t)
		  (_ nil))
	    (throw :skip nil))
	  ;; Skip habits if `org-habit-show-habits' is nil, or if we
	  ;; only show them for today.  Also skip done habits.
	  (when (and habitp
		     (or donep
			 (not (bound-and-true-p org-habit-show-habits))
			 (and (not todayp)
			      (bound-and-true-p
			       org-habit-show-habits-only-for-today))))
	    (throw :skip nil))
	  (save-excursion
	    (re-search-backward "^\\*+[ \t]+" nil t)
	    (goto-char (match-end 0))
	    (let* ((category (org-get-category))
		   (inherited-tags
		    (or (eq org-agenda-show-inherited-tags 'always)
			(and (listp org-agenda-show-inherited-tags)
			     (memq 'agenda org-agenda-show-inherited-tags))
			(and (eq org-agenda-show-inherited-tags t)
			     (or (eq org-agenda-use-tag-inheritance t)
				 (memq 'agenda
				       org-agenda-use-tag-inheritance)))))
		   (tags (org-get-tags-at nil (not inherited-tags)))
		   (level
		    (make-string (org-reduced-level (org-outline-level)) ?\s))
		   (head (buffer-substring (point) (line-end-position)))
		   (time
		    (cond
		     ;; No time of day designation if it is only
		     ;; a reminder.
		     ((and (/= current schedule) (/= current repeat)) nil)
		     ((string-match " \\([012]?[0-9]:[0-9][0-9]\\)" s)
		      (concat (org-get-time-of-day s t) " "))
		     (t 'time)))
		   (item
		    (org-agenda-format-item
		     (pcase-let ((`(,first ,next) org-agenda-scheduled-leaders))
		       (cond
			;; If CURRENT is in the future, don't use past
			;; scheduled prefix.
			((> current today) first)
			;; SHOW-ALL focuses on future repeats.  If one
			;; such repeat happens today, ignore late
			;; schedule reminder.  However, still report
			;; such reminders when repeat happens later.
			((and (not show-all) (= repeat today)) first)
			;; Initial report.
			((= schedule current) first)
			;; Subsequent reminders.  Count from base
			;; schedule.
			(t (format next (1+ diff)))))
		     head level category tags time nil habitp))
		   (face (cond ((and (not habitp) pastschedp)
				'org-scheduled-previously)
			       (todayp 'org-scheduled-today)
			       (t 'org-scheduled)))
		   (habitp (and habitp (org-habit-parse-todo))))
	      (org-add-props item props
		'undone-face face
		'face (if donep 'org-agenda-done face)
		'org-marker (org-agenda-new-marker pos)
		'org-hd-marker (org-agenda-new-marker (line-beginning-position))
		'type (if pastschedp "past-scheduled" "scheduled")
		'date (if pastschedp schedule date)
		'ts-date schedule
		'warntime warntime
		'level level
		'priority (if habitp (org-habit-get-priority habitp)
			    (+ 99 diff (org-get-priority item)))
		'org-habit-p habitp
		'todo-state todo-state)
	      (push item scheduled-items))))))
    (nreverse scheduled-items)))
#+end_src
**** Agenda bulk actions
:PROPERTIES:
:CREATED:  [2018-11-05 Mon 10:44]
:ID:       daa2a040-cd9e-4b07-be86-d549d566b42f
:END:

I routinely use the agenda feature to mark multiple tasks and perform an action on all of them.

For example, my typical archiving workflow involves going through archive candidates in my Full agenda for GTD self-check (see [[id:85dadb9c-2a7e-47cf-ba98-a0e73377653d][Archiving]]) using agenda follow mode and 
I archive some of the tasks and mark some with :NOARCHIVE: tag (see [[id:adc6f5ae-183f-4c5f-97e8-7bfe18f028d2][General org mode tags]]).

By default, marking a task does not result in updated agenda follow buffer, so I fix it below.
#+begin_src emacs-lisp
(define-advice org-agenda-bulk-mark (:after (&rest args) update-follow-mode)
  "Update follow mode buffer after marking."
  (org-agenda-do-context-action))
(advice-add 'org-agenda-bulk-unmark :after #'org-agenda-bulk-mark@update-follow-mode)
#+end_src

*************** TODO send to mail list
*************** END


*** TODO Contacts
:PROPERTIES:
:CREATED:  [2018-09-05 Wed 06:39]
:ID:       8074623d-bc14-43c7-908c-28213b2b6149
:END:
#+BEGIN_SRC emacs-lisp
(use-package org-contacts
  :init
  (setq org-contacts-files '("/home/yantar92/Org/contacts.org"))
  :config
  (use-package helm-org-contacts)
  )
#+END_SRC
*** TODO Column mode
:PROPERTIES:
:ID:       0d6d40dd-e4cb-4297-8695-6b66f2a1a706
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Sometimes, I forget what was happening with a task when I did it last time. Notes are useful in such a case.
However, I do not find it comfortable to look into notes (which are stored in drawer) every time I come back to the task. Instead, I use column mode to show the last stored note.
#+begin_src emacs-lisp
;; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%TODO %40ITEM(Task) %40SUMMARY(Summary)")

(defvar yant/last-note-taken ""
  "Text of the last note taken.")

(define-advice org-store-log-note (:before (&rest args) yant/org-store-last-note)
  "Store the last saved note into `yant/last-note-taken'."
  (let ((txt (buffer-string)))
    (while (string-match "\\`# .*\n[ \t\n]*" txt)
      (setq txt (replace-match "" t t txt)))
    (when (string-match "\\s-+\\'" txt)
      (setq txt (replace-match " " t t txt)))
    (when (string-match "\n" txt)
      (setq txt (replace-match " " t t txt)))
    (if (not (seq-empty-p txt))
	(setq yant/last-note-taken txt))))

(define-advice org-store-log-note (:after (&rest args) yant/org-save-last-note-into-summary-prop)
  "Save the last saved note into SUMMARY property."
  (when (and (not org-note-abort)
	     (boundp 'org-mode))
    (org-set-property "SUMMARY" (or yant/last-note-taken ""))))

#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       0de5d1d1-568f-4991-a627-e1b46b4e481f
:END:
#+begin_src emacs-lisp
)
#+end_src
*** TODO Auto sort
:PROPERTIES:
:ID:       aa092c63-f695-4c03-8639-b34fa262d5fe
:END:
#+begin_src emacs-lisp 
(use-package org-autosort)
(setq org-autosort-todo-cmp-order '("WAITING" "NEXT" "HOLD" "TODO" "MERGED" "FAILED" "DONE" "CANCELLED"))
(bind-key "C-c C-S-s" 'org-autosort-sort-entries-at-point org-mode-map)
(add-to-list 'org-default-properties "SORT")
#+end_src
*** Clocking & logging
:PROPERTIES:
:ID:       d1afb1ae-a3a4-45b4-8186-8e7242e0edc1
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
The main purpose of clocking for me is to control the time I spend for important projects and for other staff (like configuring Emacs ;)). Hence, it is important to do a continuous tracking of the tasks, which I can choose to do or not to do (e.g. it is useless to keep track of how much time I spend brushing my teeth in the morning - anyway, I have to do it). 
A lot of time, the task I am doing is not useful to add to my org files explicitly (e.g. initial checks on some side project, which may or may not work; routine work). I use special tasks for all kinds of such activity: 
- Organization :: related to work, general
- Check TORead ... :: related to home, browsing, reading fiction, etc I start the activity from clocking in one of these tasks. Later, I clock in the task, which I am doing at the moment. Once it's done, clocking automatically comes back to higher level task (unless it is marked =:NOCLOCK=, see [[id:adc6f5ae-183f-4c5f-97e8-7bfe18f028d2][General org mode tags]]) or to one of the tasks above when I clocked out top level project.  
     Captures are also clocked, but once done, clocking comes back to previously active task, if any, or to default task otherwise.
*************** TODO The default task is not being saved if I restart emacs
*************** END
*************** TODO Clock out from subtask from home is wrongly activating home task
*************** END
     #+begin_src emacs-lisp
(setq org-duration-format '(("h" . h:mm) ("min" . h:mm)))
(setq org-clock-out-remove-zero-time-clocks t)
(setq org-clock-out-when-done t)
(setq org-clock-in-resume t)
(setq org-clock-persist t)
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
(setq org-clock-persist-query-resume nil)
(org-clock-persistence-insinuate)

(defvar bh/keep-clock-running nil
  "Continue in default task if no task is clocked in.")
(defvar bh/organization-task-id "Organization"
  "ID of default usefull work task.")
(defvar yant/home-task-id "Homedef"
  "ID of default useless activity task.")

(defun yant/punch-in-organization ()
  "Clock in Organization task."
  (interactive)
  (setq bh/keep-clock-running 'yant/punch-in-organization)
  (org-with-point-at (org-id-find bh/organization-task-id
				  'marker)
    (org-clock-in '(16))))

(defun yant/punch-in-home ()
  "Clock in home (random activity) task."
  (interactive)
  (setq bh/keep-clock-running 'yant/punch-in-home)
  (org-with-point-at (org-id-find yant/home-task-id
				  'marker)
    (org-clock-in '(16))))

(defun yant/punch-out nil
  "Set `org-clock-default-task' to nil and clock out."
  (save-excursion
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and does not have local tag NOCLOCK and clock in."
  (let ((parent-task))
    (save-mark-and-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (and (member (nth 2 (org-heading-components)) org-todo-keywords-1)
		     (not (member "NOCLOCK" (org-get-tags nil 'LOCAL))))
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (if bh/keep-clock-running
              (bh/clock-in-default-task)
            (org-clock-out)))))))

(defun yant/clock-out-maybe nil
  "Clock out and clock in to default task if `bh/keep-clock-running' is not nil."
  (when (and bh/keep-clock-running
	     (not org-clock-clocking-in)
	     (marker-buffer org-clock-default-task)
	     (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'yant/clock-out-maybe 'append)
(add-hook 'org-clock-in-hook (lambda () (setq bh/keep-clock-running t)))
     #+end_src

     Once I keep all my time tracked, I can calculate the estimated balance of my time. The idea is that I assign the weight to each task/project (=:TIMEWEIGHT:=), which is positive for useful tasks I
     do not want to do, and negative for fun tasks (they may be useful, but the purpose is to force myself doing what I do not like to do). All I need to do now, is to keep this balance
     positive. 
*************** TODO Implement this (current month summary)
*************** END
**** Agenda log mode & clock report
:PROPERTIES:
:ID:       104927a5-4dea-4ee0-91d7-36afc6b15c7f
:END:
Reviewing previously clocked task is important to keep track of mistakes and clashes during clocking. I do it once per week. 
#+begin_src emacs-lisp
(setq org-clock-report-include-clocking-task t)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src
- set up consistency checks (do not show too short clocking gaps)
  #+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      (plist-put org-agenda-clock-consistency-checks
		 :max-gap "2:00"))
  #+end_src
**** Logging clocking data
:PROPERTIES:
:ID:       973d6eff-3d91-48f0-a3b5-b438feccf28f
:END:
#+begin_src emacs-lisp
(setq org-log-into-drawer t)
(setq org-log-done 'time)
(setq org-clock-into-drawer t)
#+end_src
- Do not create empty drawers
  #+begin_src emacs-lisp
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))
(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
  #+end_src
  - Relative to my [[id:d38441a2-1431-44db-b831-8cdec011b1dc][todo keyword structure]], it make sense that clock task is always =NEXT=
  #+begin_src emacs-lisp
(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (when (and (member (org-get-todo-state) (list "TODO" "DONE"))
	       (bh/is-task-p))
      "NEXT")))
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  #+end_src
**** Display clocked in entry
:PROPERTIES:
:ID:       13012cf7-322e-4433-a22c-e81b7c5feda0
:END:
I do not show current task in Emacs, instead I use =awesome wm= widget. Hence need to save current task in file. The widget shows clocked time and full path to the clocked tasks (i.e. =[hh:mm] Project/Subproject/Subsubproject/.../task=) or =[hh:mm] Capturing ...= for capturing (the title is being edited there and it does not make sense to keep that updated in widget as well). 
#+begin_src emacs-lisp
(setq org-clock-mode-line-total (quote today))
(setq org-clock-clocked-in-display nil)
(defvar yant/org-clocking-info-file "~/.org-clock-in"
  "File to save current clocking info.\nIt will be overwriten!")

(defun yant/task-fulltitle ()
  "Construct full path for the task at point."
  (when (fboundp 'org-mode)
    (save-mark-and-excursion
      (save-restriction
	(org-back-to-heading)
	(mapconcat #'identity (org-get-outline-path 'with-self 'cache) "||")))))

(defun yant/clocked-fulltitle ()
  "Construct string, describing currently clocked entry time and full path to this entry."
  (use-package org-clock)
  (if org-capture-mode
      (concat "Capturing " (plist-get org-capture-plist :description) "...")
    (yant/task-fulltitle)))
(setq org-clock-heading-function 'yant/clocked-fulltitle)

(defun yant/save-noclock ()
  "Save info, that there is no clocked in entry."
  (use-package org-clock)
  (save-current-buffer
    (save-mark-and-excursion
      (let ((buf (find-file-noselect yant/org-clocking-info-file)))
	(set-buffer buf)
	(erase-buffer)
	(insert (format "\"No clocked in task\"\n%s" org-time-balance))
	(save-buffer)
	(kill-buffer)))))

(defun yant/save-clocked ()
  "Save current clocked state into file."
  (if (org-clock-is-active)
      (save-mark-and-excursion
	(save-restriction
	  (let* ((buf yant/org-clocking-info-file)
		 (str (org-clock-get-clock-string))
                 (org-time-multiplier org-clock-multiplier)
                 (time-balance org-time-balance))
	    (with-temp-file buf (insert (format "%s\n%s\n%s" str time-balance org-time-multiplier))))))
    (yant/save-noclock))
  (async-start-process "Update balance widget" "/home/yantar92/bin/balance-monitor.sh" #'ignore))

(add-hook 'org-clock-in-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-out-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-cancel-hook 'yant/save-clocked 'append)
#+end_src
**** Clocking history
:PROPERTIES:
:ID:       9e2c7a88-8a56-4213-b458-ccebcd59812a
:END:
Sometimes I need to jump to some urgent task. After it is done, I hate searching for the last task buffer and start clocking it again. Hence, I use clocking history and quick key combination to clock in task from recent clocked in tasks. 
#+begin_src emacs-lisp
(setq org-clock-history-length 23)
(use-package boon
  :config
  (use-package helm-org
    :bind (:map boon-goto-map
		("p" . yant/resume-orcall-helm-org-agenda-files-headings))
    :init
    (defun yant/resume-orcall-helm-org-agenda-files-headings ()
      "Try to resume `helm-org-agenda-files-headings' session or call a new one if not exists."
      (interactive)
      (let ((buffer-name "*helm org headings*"))
	(if (bufferp (get-buffer buffer-name))
	    (helm-resume buffer-name)
          (helm-org-agenda-files-headings))))
    :config
    (defun dfeich/helm-org-clock-in (marker)
      "Clock into the item at MARKER"
      (with-current-buffer (marker-buffer marker)
	(goto-char (marker-position marker))
	(org-clock-in)))
    (nconc helm-org-headings-actions
           (list
            (cons "Clock into task" #'dfeich/helm-org-clock-in)))
    (bind-key "C-c i" #'dfeich/helm-org-clock-in helm-org-headings-map)
    (setq helm-org-format-outline-path t
	  helm-org-show-filename t
          helm-org-ignore-autosaves t)
    ))
#+end_src
**** Pomodoro technique
:PROPERTIES:
:ID:       ee371af1-c478-49d1-9814-1eb78242a341
:END:
Sometimes I need to do important task, but I just hate it. I tend to do anything, but not that freaking task. In this case, =pomodoro= works for me - I just switch between the task and something I like. 
About: [[https://habrahabr.ru/post/323576/][habr]]
#+begin_src emacs-lisp
(use-package pomidor
  :ensure t
  :bind (([f7] . pomidor))
  :config
  (setq alert-default-style 'libnotify))
#+end_src
**** Bonus/penalty based time management
:PROPERTIES:
:CREATED:  [2018-07-21 Sat 16:40]
:ID:       38d9103d-a969-4c69-ae0e-a9a50912fba0
:END:
The idea is to assign time bonus/penalty during working on different tasks, so that the total balanced time spent under all the tasks (=org-time-balance=) is kept positive.
Similar concept is described [[id:8a2ae3c3-69b0-495b-b796-9c9916dc40c6][here]]. 
 
I calculate the effective time by setting =ORG-TIME-BALANCE-MULTIPLIER= property for various tasks.
If the value is positive then the task is useful. Otherwise, it is negative and I do not want to spend too much time doing such tasks. 
The property can be different for various classes of tasks allowing to avoid/promote doing various tasks.
Setting =ORG-TIME-BALANCE-MULTIPLIER= for every single task is annoying, so I make it inherited during calculation.

It does not make sense to set =ORG-TIME-BALANCE-MULTIPLIER= for tasks like buying something in the shop. 
I just do not clock them in. 
Instead, I use =ORG-TIME-BONUS-ON-DONE= property to add fixed extra time for finishing the task (only =DONE= keyword is considered).

=org-time-balance= is calculated for the last month only at the initial calculation to avoid counting old tasks and projects, which were not [[id:85dadb9c-2a7e-47cf-ba98-a0e73377653d][archived]].
The initial calculation is a time consuming procedure (=org-map-entries=) and =org-time-balance= is updated in the =org-clock-in/out= hooks/advises.
The resulting value of =org-time-balance= contains the balanced time from *one month before its initial value calculation* till the current moment of time.

*************** TODO The bonus is not calculated correctly for the habits now. Fix it.
*************** END


#+begin_src emacs-lisp 
(defvar org-time-balance nil
  "Weighted time spent for all the tasks in agenda files.")
(defvar org-time-balance-persistant-p t
  "Non nil means that `org-time-balance' is saved between emacs sessions.")
(defvar org-time-balance-save-time nil
  "Time of the last save of `org-time-balance'.")
(defvar org-time-balance-update-time nil
  "Time of the last update of `org-time-balance'.")
(use-package savehist
:config
  (add-to-list 'savehist-additional-variables 'org-time-balance)
  (add-to-list 'savehist-additional-variables 'org-time-balance-save-time))

(defun org-load-time-balance-session ()
  "Save the current org-time-balance if `org-time-balance-persistant-p' is non nil."
  (when org-time-balance-persistant-p
    (unless (and (boundp 'savehist-mode)
		 savehist-mode)
      (savehist-mode +1))
    (savehist-load)))

(defun org-save-time-balance-session ()
  "Save the current org-time-balance if `org-time-balance-persistant-p' is non nil."
  (when (and org-time-balance-persistant-p
	     org-time-balance
             org-time-balance-update-time)
    (setq org-time-balance-save-time org-time-balance-update-time)
    (savehist-save)))

(defun org-get-time-balance-multiplier-at-point ()
  "Get value of :ORG-TIME-BALANCE-MULTIPLIER property of an item at point or return 1."
  (save-excursion
    (save-restriction
      (let  ((multiplier (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)))
	(if (seq-empty-p multiplier)
	    1
	  (string-to-number multiplier))))))

(defun org-get-org-time-bonus-on-done-at-point ()
  "Get value of :ORG-TIME-BONUS-ON-DONE: property of an item at point or return 0."
  (save-excursion
    (save-restriction
      (let  ((bonus (org-entry-get (point) "ORG-TIME-BONUS-ON-DONE")))
	(if (seq-empty-p bonus)
	    0
	  (string-to-number bonus))))))

(defun org-get-org-time-bonus-at-point ()
  "Get time bonus on done for an item at point.
Return the value of :ORG-TIME-BONUS: property and,
if the item has DONE keyword, add :ORG-TIME-BONUS-ON-DONE:.
Increment :ORG-TIME-BONUS: for habits, if nesessary."
  (save-excursion
    (save-restriction
      (let*  ((bonus (org-entry-get (point) "ORG-TIME-BONUS"))
	      (bonus (if (seq-empty-p bonus)
			 0
		       (string-to-number bonus)))
              (extra (if (string= (org-get-todo-state) "DONE")
			 (org-get-org-time-bonus-on-done-at-point)
                       0)))
	(+ bonus extra)))))

(defun org-accumulate-weighted-time (&optional return)
  "Aggregate `org-time-balance' counter at point from the last save of for a month.
Use :ORG-TIME-BALANCE-MULTIPLIER: property to set the weight.
Just return the value at point if RETURN is not nil."
  (when org-time-balance
    (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
	   (a-month-ago (* 60 60 24 (+ daynr 1)))
	   (last-month (time-subtract (current-time) (seconds-to-time a-month-ago)))
           (value-at-point (* (org-clock-sum-current-item (or org-time-balance-save-time
							      last-month))
                              (org-get-time-balance-multiplier-at-point))))
      (setq value-at-point (+ value-at-point (org-get-org-time-bonus-at-point)))
      (if return
	  value-at-point
	(setq org-time-balance (+ org-time-balance value-at-point))))))

(defun org-get-total-weighted-time (&optional force)
  "Calculate total weighted time clocked in all agenda files.
Ignore current value of `org-time-balance' if FORCE is not nil.
If FORCE is non nil recalculate the time in all the agenda files
ignoring the previously saved values."
  (when (or force (not org-time-balance))
    (setq org-time-balance 0)
    (setq org-time-balance-save-time nil)
    (unless force (org-load-time-balance-session))
    (cl-loop for file in (org-agenda-files) do
	     (with-current-buffer (find-file-noselect file)
               (goto-char (point-min))
               (cl-loop until (eobp)
			do (when (outline-next-heading)
			     (org-accumulate-weighted-time)))))
    (setq org-time-balance-update-time (current-time))
    (org-save-time-balance-session))
  org-time-balance)

(define-advice org-clock-out (:around (OLDFUN &rest args) yant/org-increment-weighted-time)
  "Add the current clock time to `org-time-balance'."
  (save-excursion ; Do not replace this with `with-current-buffer'.
    (with-no-warnings (set-buffer (org-clocking-buffer)))
    (save-restriction
      (widen)
      (use-package org-clock)
      (goto-char org-clock-marker)
      (let ((old-time-at-point (org-accumulate-weighted-time 'return))
	    (old-org-time-balance org-time-balance))
	(apply OLDFUN args)
	(setq org-time-balance-update-time (current-time))
	(setq org-time-balance (+ old-org-time-balance
				  (- (org-accumulate-weighted-time 'return)
                                     old-time-at-point)))))))

(define-advice org-todo (:around (OLDFUN &optional arg) yant/org-increment-weighted-time)
  "Probably add the current item time bonus to `org-time-balance'."
  (let ((old-time-at-point (org-accumulate-weighted-time 'return))
	(old-org-time-balance org-time-balance))
    (when (and (string= (org-entry-get (point) "STYLE") "habit")
	       (string= (format "%s" arg) (org-entry-get (point) "REPEAT_TO_STATE"))
               (string= "DONE" (org-get-todo-state))
	       (org-set-property "ORG-TIME-BONUS" (format "%s" (org-get-org-time-bonus-at-point)))))
    (apply OLDFUN (list arg))
    (setq org-time-balance-update-time (current-time))
    (setq org-time-balance (+ old-org-time-balance
			      (- (org-accumulate-weighted-time 'return)
				 old-time-at-point))))
  (yant/save-clocked))


(defvar org-clock-multiplier 0
  "Multiplier of the currently clocked entry.")

(defun org-clock-save-clock-multiplier ()
  "Save value of :ORG-TIME-BALANCE-MULTIPLIER: of the item at point to `org-clock-multiplier'."
  (org-with-wide-buffer
   (org-get-total-weighted-time)
   (setq org-clock-multiplier (or (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)
				  1))))

(add-hook 'org-clock-in-hook #'org-clock-save-clock-multiplier)

(add-to-list 'org-default-properties "ORG-TIME-BALANCE-MULTIPLIER")
(add-to-list 'org-default-properties "ORG-TIME-BONUS-ON-DONE")
#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       e26ec668-12c9-41f1-ad8a-a3dd96007f5c
:END:
#+begin_src emacs-lisp
)
#+end_src
*** Capture
:PROPERTIES:
:ID:       fbb770b4-2232-431d-b2e5-75d001ff49b0
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
Capturing is an important part of my workflow. It allows me to quickly note down the task or thought for future consideration and continue the current task. 
This should be done quickly, and from any place (not only from inside emacs):
- system wide key combination for capturing allows to capture from anywhere
- open new frame for capturing
- use capture templates for most common types of quick captures
There is also one more use case when I prefer to use capture - creating a new big projects. The reason to use capture here is that common types of projects require some set of needed actions, which I tend to forget. Capture templates here allows to remind necessary project tasks to myself.
**** System wide capture 
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:49]
:ID:       0702c999-0ee5-494c-a1d7-1bb4024c43f7
:END:
#+begin_src emacs-lisp
(use-package org-protocol)
#+end_src
*************** TODO Include system scripts here
CLOSED: [2018-09-23 Sun 17:36]
:LOGBOOK:
- State "DONE"       from              [2018-09-23 Sun 17:36]
:END:
*************** END
New frame for capturing. The frame should only have capture buffer in it.
#+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :ensure t
  :config
  (defadvice org-capture-place-template (after delete-windows activate) (delete-other-windows))
  (defadvice org-capture-select-template (around delete-capture-frame activate)
    "Advise org-capture-select-template to close the frame on abort.  From https://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection#23517820"
    (unless (ignore-errors ad-do-it t)
      (setq ad-return-value "q"))
    (if (and (equal "q" ad-return-value)
	     (equal "org-capture-pop-frame" (frame-parameter nil 'name)))
	(delete-frame))))
#+end_src

*************** TODO report bug
*************** END

Currently =org-capture-pop-frame= resets the line truncation state, which is rather annoying. Denying it:
#+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :if init-flag 
  :defer t
  :init
  (defun ocpf--org-capture (orig-fun &optional goto keys)
    "Create a new frame and run org-capture."
    (interactive)
    (let ((frame-window-system
           (cond ((eq system-type 'darwin) 'ns)
		 ((eq system-type 'gnu/linux) 'x)
		 ((eq system-type 'windows-nt) 'w32)))
          (after-make-frame-functions
           #'(lambda (frame)
               (progn
		 (select-frame frame)
		 ;; (setq word-wrap nil)
		 ;; (setq truncate-lines nil)
		 (funcall orig-fun goto keys)
		 (setq header-line-format
                       (list "Capture buffer. "
                             (propertize (substitute-command-keys "Finish \\[org-capture-finalize], ")
					 'mouse-face 'mode-line-highlight
					 'keymap
					 (let ((map (make-sparse-keymap)))
                                           (define-key map [header-line mouse-1] 'org-capture-finalize)
                                           map))
                             (propertize (substitute-command-keys "abort \\[org-capture-kill]. ")
					 'mouse-face 'mode-line-highlight
					 'keymap
					 (let ((map (make-sparse-keymap)))
                                           (define-key map [header-line mouse-1] 'org-capture-kill)
                                           map))))))))
      (make-frame
       `((window-system . ,frame-window-system)
	 ,@ocpf-frame-parameters)))))
#+end_src

**** Capture templates
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:51]
:ID:       e3d02bee-a924-4808-9a2f-fe577065038d
:END:
All these templates generally record the creation time in =:CREATED:=
- TODO item :: Normal TODO item.
- singular TODO item :: Normal TODO item with time bonus on done (60 minutes) - used for the items, which are unlikely to be time tracked.
- Habit :: Habit. I default it to no logging.
- Meeting/Event :: Scheduled event. It is saved to =org-gcal= org file.
- Project :: I need literature review, reports and ideas in most of the cases.
- Conference presentation/poster :: I mark this with =conference= tag. Typical workflow here is:
     1. Write an abstract
     2. Revise abstract (habit, since it is multiple times most likely)
     3. Submit abstract
     4. Get accepted
     5. Handle finance
	- Apply for funding
	- Book flight
	- Book hotel
	- Register for conference
     6. Make presentation/poster
     7. Do trial + further revisions (habit)
     8. Print poster if it is poster
     9. Present
     10. Reimburse money
- Research publication :: I mark this with =publication= tag. Typical workflow here is:
     1. Write outline
	1. Introduction
	2. Methodology
	3. Results
	4. Discussion
	5. Conclusions
	6. Abstract
     2. Revise (habit)
     3. Write cover letter
     4. Submit
     5. Revise according to comments (habit)
     6. Get accepted
     7. Publish in ArXiv before journal take over the copyright
     8. Publish in journal
     9. Add to publication list
- Link from browser :: It has =:SOURCE:= with URL of the page and page title in headline. =:SOURCE:= is the only place, where the URL is shown. I tag the entry with tag =BOOKMARK= to make it clear.
- Generic link :: Same as link from browser, but silent (don't raise the capture buffer)
- Selection from browser :: Same as previous, but selection is used as headline 
- Link to email :: It has =:EMAIL-SOURCE:= with link to =notmuch= email (more about working with emails in [[id:e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326][Notmuch interaction]]). I also mark with tag =EMAIL=. 
		   #+begin_src emacs-lisp
(setq org-capture-templates
      '(("n" "TODO item" entry (file "~/Org/inbox.org")
	 "* TODO %? %a\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-in t :clock-resume t)
        ("m" "singular TODO item" entry (file "~/Org/inbox.org")
	 "* TODO %? %a\n:PROPERTIES:\n:CREATED: %U\n:ORG-TIME-BONUS-ON-DONE: 60\n:END:\n" :clock-in t :clock-resume t)
	("p" "Conference presentation/poster" entry (file "~/Org/inbox.org")
	 "* NEXT [presentation/poster] %^{Title of presentation/poster} :conference:NOARCHIVE:\n:PROPERTIES:\n:CREATED: %U\n:END:\n** NEXT Write an abstract\n** TODO Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Submit abstract\nDEADLINE: %^t\n** TODO Get accepted\n** TODO Finance matters\n*** TODO Apply for conference funding\n*** TODO Book a flight\n*** TODO Book accomodation\n*** TODO Register for a conference\n** TODO Make presentation/poster\n** TODO Trial presentation\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Print poster/slides\n** TODO Present\n** TODO Submit the claim\n** Get reimbursement\n" :clock-in t :clock-resume t)
	("j" "Journal publication" entry (file "~/Org/inbox.org")
	 "* NEXT [paper] %^{Aproximate title of the paper} :publication:NOARCHIVE:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%^{Short description}\n** TODO Outline\nDEADLINE: %^t\n*** NEXT Abstract\n*** TODO Introduction\n*** TODO Methods\n*** TODO Results\n*** TODO Discussion\n*** TODO Conclusions\n** TODO Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Cover letter\n** TODO Submit\n** Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Get accepted\n** TODO Publish on ArXiv\n** TODO Get published\n** TODO Add to pub list\n" :clock-in t :clock-resume t)
	("P" "Research project" entry (file "~/Org/inbox.org")
	 "* TODO %^{Project title} :%^G:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%?\n** TODO Literature review\n** TODO Summary\n** TODO Reports\n** Ideas\n" :clock-in t :clock-resume t)
	("e" "Email" entry (file "~/Org/inbox.org")
	 "* TODO %? email |- %:from: %:subject :EMAIL:\n:PROPERTIES:\n:CREATED: %U\n:EMAIL-SOURCE: %l\n:END:\n%U\n" :clock-in t :clock-resume t)
	("b" "Link from browser" entry (file "~/Org/inbox.org")
	 "* TODO %? |- (%:description) :BOOKMARK:\n:PROPERTIES:\n:CREATED: %U\n:Source: %:link\n:END:\n%i\n" :clock-in t :clock-resume t)
	("B" "Generic link" entry (file "~/Org/inbox.org")
	 "* TODO url |- (%:description) :BOOKMARK:\n:PROPERTIES:\n:CREATED: %U\n:Source: %:link\n:END:\n%i\n" :immediate-finish t)
	("s" "Selection from browser" entry (file "~/Org/inbox.org")
	 "* TODO %? :BOOKMARK:\n%(replace-regexp-in-string \"\n.*\" \"\" \"%i\")\n:PROPERTIES:\n:CREATED: %U\n:Source: %:link\n:END:\n%i\n" :clock-in t :clock-resume t)
	("h" "Habit" entry (file "~/Org/inbox.org")
	 "* NEXT %?\nSCHEDULED: <%<%Y-%m-%d %a .+1d>>\n:PROPERTIES:\n:CREATED: %U\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:LOGGING: DONE(!)\n:ARCHIVE: %%s_archive::* Habits\n:END:\n%U\n")
	("M" "Scheduled event/Meeting" entry (file "~/Org/schedule.org")
	 "* %?\n")
	("C" "Contacts" entry (file "~/Org/contacts.org")
	 "* %(org-contacts-template-name)
:PROPERTIES:
:EMAIL: %(org-contacts-template-email)
:PHONE:
:ALIAS:
:NICKNAME:
:IGNORE:
:ICON:
:NOTE:
:ADDRESS:
:BIRTHDAY:
:END:")))
		   #+end_src
		   #+begin_src emacs-lisp
)
		   #+end_src


*** Refile
:PROPERTIES:
:ID:       c048269c-57b9-434a-a19b-6da8d70e5e0f
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Once capturing is done and I have some time, the captured notes should be scheduled and moved to the appropriate places (refiled). All the captured tasks are tagged =:INBOX:= (default tag in =inbox.org=) and can be viewed in special agenda view. The agenda has 3 groups of tasks: with deadline, scheduled, not scheduled without deadline.
First, I schedule/set deadline for all the tasks, where needed. Secondly, I set the priorities (=#A= will be always shown focused agenda). Lastly, I refile the tasks into the right projects.

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-cache t)
(setq org-refile-targets (quote ((nil :maxlevel . 9)
				 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)
					; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC

The most time consuming part of refiling is selecting the right subtree. Yes, I use helm, but it is not enough - there are too many things in my org files. Hence, I limit the refile targets to projects, which are not finished.

Occasionally, I need to add subtask to the existing task, which is not a project.

*************** TODO Change global binding in =helm-map=, it does not make sense in place, other than org mode completion
*************** END

#+begin_src emacs-lisp
(defvar refile-to-tasks nil
  "Non nil means, that single tasks will be included into refile candidates.")

(defun yant/toggle-refile-to-tasks ()
  "Toggle refiling into single tasks."
  (interactive)
  (setq refile-to-tasks (not refile-to-tasks))
  (setq org-refile-cache nil); reset refile cache
  (if refile-to-tasks (message "Refiling to tasks") (message "Not refiling to tasks")))

(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-mode-map)
(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-agenda-mode-map)
(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks helm-map)

(defun yant/verify-refile-target ()
  "Exclude tasks and todo keywords with a done state from refile targets."
  (and (or refile-to-tasks
	   (not (bh/is-task-p)))
       (not (member (nth 2 (org-heading-components)) org-done-keywords))))

(setq org-refile-target-verify-function 'yant/verify-refile-target)
#+end_src

*************** TODO Integrate with helm refile
*************** END


**** =__epilogue=
:PROPERTIES:
:ID:       2e6f7380-707a-4ff9-992c-4992377ae1ee
:END:
#+begin_src emacs-lisp
)
#+end_src
*** TODO Export
:PROPERTIES:
:ID:       24d7f8cf-7729-4a05-a09d-bac24ab101b5
:END:
- I do regular export in separate script since it takes a lot of time and hangs Emacs.
- Do not run babel blocks during export
  #+begin_src emacs-lisp
(setq org-export-default-inline-image-rule '(("file" . "\\.\\(gif\\|jp\\(?:e?g\\)\\|p\\(?:bm\\|gm\\|ng\\|pm\\)\\|tiff?\\|x\\(?:[bp]m\\)\\)\\'")))
  #+end_src
  #+begin_src emacs-lisp
(setq org-export-use-babel t)
(setf (alist-get :eval org-babel-default-header-args) "never-export") 
  #+end_src
**** Ignore some headlines in a sense that it will not be exported as =\section=. 
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:17]
:ID:       e345057c-cd79-4e89-8ecc-ed81473804f1
:END:
Sometimes, I want to have a headline, but do not want it to be exported as a section, while its text should still be exported.
It is especially useful when writing papers.
I mark such a headlines with =:ignore:= tag.
The subheadings below such a headlines are promoted up *1 level*.

#+BEGIN_SRC emacs-lisp
(use-package ox-extra
  :ensure nil
  :config
  (ox-extras-activate '(ignore-headlines)))

;; (defun yant/org-export-suppress-some-sections (data backend channel)
;;   "Do not put \\section for headlines with :NOSECEXPORT: tag."
;;   (let* ((parent (get-text-property (- (string-match "$" data) 2) :parent data))
;; 	 (headline (and parent (cadr parent)))
;;          (tags (and headline (plist-get headline :tags))))
;;     (when (and (member "NOSECEXPORT" tags)
;; 	       (not (member "SPECIALSECEXPORT" tags)))
;;       (replace-regexp-in-string "\\`.*$" "" data))))

;; (add-to-list 'org-export-filter-headline-functions 'yant/org-export-suppress-some-sections)
#+END_SRC
**** pdf
:PROPERTIES:
:ID:       6fb7a08a-ed44-46e5-aee3-82f76003de4a
:END:
#+begin_src emacs-lisp
(setq org-export-exclude-tags '("NOEXPORT"))
(setq org-latex-pdf-process
      (quote
       ;; ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ("latexmk -shell-escape -bibtex -f -pdf -output-directory=%o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ))
(setq org-export-with-timestamps nil)
(setq org-export-in-background nil)
#+end_src
***** Default settings
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:16]
:ID:       1bf4b848-2cac-4d11-a23d-a9b7cf4bcacb
:END:
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-header
      "
        \\documentclass{article}
        \\usepackage[usenames]{color}
        [PACKAGES]
        [DEFAULT-PACKAGES]
        \\pagestyle{empty}             % do not remove
        % The settings below are copied from fullpage.sty
        \\setlength{\\textwidth}{\\paperwidth}
        \\addtolength{\\textwidth}{-3cm}
        \\setlength{\\oddsidemargin}{1.5cm}
        \\addtolength{\\oddsidemargin}{-2.54cm}
        \\setlength{\\evensidemargin}{\\oddsidemargin}
        \\setlength{\\textheight}{\\paperheight}
        \\addtolength{\\textheight}{-\\headheight}
        \\addtolength{\\textheight}{-\\headsep}
        \\addtolength{\\textheight}{-\\footskip}
        \\addtolength{\\textheight}{-3cm}
        \\setlength{\\topmargin}{1.5cm}
        \\addtolength{\\topmargin}{-2.54cm}
        ")
(setq org-latex-classes
      (quote
       (("beamer" "\\documentclass[presentation]{beamer}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("article" "\\documentclass[11pt]{article}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	 ("\\paragraph{%s}" . "\\paragraph*{%s}")
	 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
	("report" "\\documentclass[11pt]{report}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("book" "\\documentclass[11pt]{book}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))))
(setq org-latex-default-packages-alist
      (quote
       (("utf8" "inputenc" t)
	("T1" "fontenc" t)
	("" "longtable" nil)
	("" "float" nil)
	("" "wrapfig" nil)
	("" "rotating" nil)
	("normalem" "ulem" t)
	("" "amsmath" t)
	("" "textcomp" t)
	("" "marvosym" t)
	("" "wasysym" t)
	("" "amssymb" t)
	("" "hyperref" nil)
	("" "graphicx" t)
	("" "underscore" t)
	("russian" "babel" t)
	("" "epstopdf" t)
	("extendedchars" "grffile" t)
	"
      	 \\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 `dirname #1`/`basename #1`.tif`-tif-converted-to.png}
      	 \\AppendGraphicsExtensions{.tif}
      	 \\usepackage{enumitem}
      	 \\setlistdepth{10}
      	 \\setlist[itemize,1]{label=$\\bullet$}
      	 \\setlist[itemize,2]{label=$\\bullet$}
      	 \\setlist[itemize,3]{label=$\\bullet$}
      	 \\setlist[itemize,4]{label=$\\bullet$}
      	 \\setlist[itemize,5]{label=$\\bullet$}
      	 \\setlist[itemize,6]{label=$\\bullet$}
      	 \\setlist[itemize,7]{label=$\\bullet$}
      	 \\setlist[itemize,8]{label=$\\bullet$}
      	 \\setlist[itemize,9]{label=$\\bullet$}
      	 \\setlist[itemize,10]{label=$\\bullet$}
      	 \\renewlist{itemize}{itemize}{10}
      	 \\setlist[enumerate,1]{label=$\\bullet$}
      	 \\setlist[enumerate,2]{label=$\\bullet$}
      	 \\setlist[enumerate,3]{label=$\\bullet$}
      	 \\setlist[enumerate,4]{label=$\\bullet$}
      	 \\setlist[enumerate,5]{label=$\\bullet$}
      	 \\setlist[enumerate,6]{label=$\\bullet$}
      	 \\setlist[enumerate,7]{label=$\\bullet$}
      	 \\setlist[enumerate,8]{label=$\\bullet$}
      	 \\setlist[enumerate,9]{label=$\\bullet$}
      	 \\setlist[enumerate,10]{label=$\\bullet$}
      	 \\renewlist{enumerate}{enumerate}{10}
      	 "
	"\\tolerance=1000"
	)))

#+END_SRC
**** html
:PROPERTIES:
:ID:       cc464b8f-4be1-4463-99bc-9f1d1c9a138f
:END:
#+begin_src emacs-lisp
(setq org-html-inline-image-rules '(("file"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|tif\\)\\'")
				    ("http"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")
				    ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")))
#+end_src
**** md
:PROPERTIES:
:ID:       51a2db82-731b-4daf-bea9-dbcca50bc4e8
:END:
#+begin_src emacs-lisp 
(use-package ox-md)
#+end_src
*** Archiving
:PROPERTIES:
:ID:       85dadb9c-2a7e-47cf-ba98-a0e73377653d
:END:
I usually archive =DONE= tasks, which were done last month or earlier. They are shown in my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view. These are usually small tasks like =TODO Contact someone=. There is no need to keep them.

In the case if I want to keep the task and notes, I just add =:NOARCHIVE:= tag to it.
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::datetree/* Archived Tasks")
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving."
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (subtree-end (save-excursion (org-end-of-subtree t)))
           (next-item (if (member "ARCHIVEALL" (org-get-tags))
			  subtree-end ; do not archive subtasks
			next-headline)))
      (if (member "NOARCHIVE" (org-get-tags))
	  subtree-end
	(if (member (org-get-todo-state) org-done-keywords)
	    (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
		   (a-month-ago (* 60 60 24 (+ daynr 1)))
		   (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
		   (this-month (format-time-string "%Y-%m-" (current-time)))
		   (subtree-is-current (save-excursion
					 (forward-line 1)
					 (and (< (point) subtree-end)
					      (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
	      (if subtree-is-current
		  next-item ; Has a date in this month or last month, skip it
		nil))  ; available to archive
	  next-item)))))
#+end_src

Inline tasks cannot be archived for now ([2017-12-29 Fri]), so, I override standard archiving function to make them archivable (into separate location =org-inlinetask-archive-location=)
#+BEGIN_SRC emacs-lisp
(defvar org-inlinetask-archive-location "%s_archive::datetree/* Archived inline tasks"
  "Where to archive inline tasks.")
(defvar org-inlinetask-max-level 100
  "Maximum level for inline task to be archived.")

(define-advice org-archive-subtree (:around (oldfunc &rest args) org-archive-inline-task)
  "Archive inline tasks according to `org-inlinetask-archive-location'."
  (if (boundp 'org-inlinetask-min-level)
      (let* ((org-inlinetask-min-level-real org-inlinetask-min-level)
	     (at-inline-task (org-inlinetask-in-task-p))
	     (org-inlinetask-min-level (if at-inline-task
					   org-inlinetask-max-level
					 org-inlinetask-min-level))
	     (org-archive-location (if at-inline-task
				       org-inlinetask-archive-location
				     org-archive-location))
	     (org-archived-inlinetask-point (point)))
	(apply oldfunc args))
    (apply oldfunc args)))

;; It is needed to cut inlinetask properly (remove trailing "***... END")
(add-hook 'org-archive-hook (lambda () (when (boundp 'org-inlinetask-min-level-real)
					 (setq org-inlinetask-min-level org-inlinetask-min-level-real))))

(define-advice org-archive-subtree (:after (&rest args) org-archive-inline-task-keep-point)
  "Keep the point after archiving inline task."
  (when (boundp 'org-archived-inlinetask-point)
    (goto-char org-archived-inlinetask-point)))
#+END_SRC

Sometimes, I have a small projects, where I do not want to decide whether I want to archive every single subtask or not. I tag them =:ARCHIVEALL:=.

Thanks God, I do not need to open my archive file frequently - my =TODO.org_archive= is =>1Mba= and takes forever to open. I am not sure if I need to do something with it.
*************** HOLD Speed up opening large org files                     :HOLD:
:LOGBOOK:
- State "HOLD"       from "TODO"          [2017-12-22 Fri 22:01] \\
  Consider it if it becomes annoying
:END:
*************** END

If a task being archived contains attachments, it is better to delete them.
Otherwise, I'd rather keep the task in place to avoid hanging files.

#+begin_src emacs-lisp
(setq org-attach-archive-delete 'query)

;; redefining to show the list of attachments in the query
(defun org-attach-archive-delete-maybe ()
  "Maybe delete subtree attachments when archiving.
This function is called by `org-archive-hook'.  The option
`org-attach-archive-delete' controls its behavior."
  (when (and (org-at-heading-p)
	     (member org-attach-auto-tag (org-get-tags nil t));; do not ask if no attachments
	     )
    (when (if (eq org-attach-archive-delete 'query)
	      (yes-or-no-p (format "%s: Delete all attachments? " (s-truncate 20 (org-get-heading
										  'notags 'notodo 'nopriority 'nocomment))))
	    org-attach-archive-delete)
      (org-attach-delete-all t))))

#+end_src

*** Preview
:PROPERTIES:
:ID:       a85d2993-1d90-40b3-b69a-52cf7d6bd18b
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
Preview images and latex formulas.
#+begin_src emacs-lisp
(setq org-image-actual-width '(400))
(setq org-latex-create-formula-image-program 'imagemagick)
(setq org-format-latex-options
      (quote
       (:foreground default :background default :scale 2.0 :justify center :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers
		    ("begin" "$1" "$" "$$" "\\(" "\\["))));; 2x height of formulas
(setq org-latex-inline-image-rules
      (quote
       (("file" . "\\.\\(jpeg\\|jpg\\|png\\|eps\\|tikz\\|pgf\\|svg\\|bmp\\|tif\\)\\'"))))
#+end_src
Justify and number the formulas
#+begin_src emacs-lisp
;; from https://github.com/jkitchin/scimax/blob/master/scimax-org.el
(use-package ov
  :ensure t
  :config
  (defun org-latex-fragment-justify (justification)
    "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
    (interactive
     (list (intern-soft
            (completing-read "Justification (left): " '(left center right)
                             nil t nil nil 'left))))

    (let* ((ov (ov-at))
	   (beg (ov-beg ov))
	   (end (ov-end ov))
	   (shift (- beg (line-beginning-position)))
	   (img (overlay-get ov 'display))
	   (img (and (and img (consp img) (eq (car img) 'image)
			  (image-type-available-p (plist-get (cdr img) :type)))
		     img))
	   space-left offset)
      (when (and img
		 ;; This means the equation is at the start of the line
		 (= beg (line-beginning-position))
		 (or
		  (string= "" (s-trim (buffer-substring end (line-end-position))))
		  (eq 'latex-environment (car (org-element-context)))))
	(setq space-left (- (window-max-chars-per-line) (car (image-size img)))
	      offset (floor (cond
			     ((eq justification 'center)
			      (- (/ space-left 2) shift))
			     ((eq justification 'right)
			      (- space-left shift))
			     (t
			      0))))
	(when (>= offset 0)
	  (overlay-put ov 'before-string (make-string offset ?\ ))))))

  (defun org-latex-fragment-justify-advice (beg end image imagetype)
    "After advice function to justify fragments."
    (org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))

  (advice-add 'org--format-latex-make-overlay :after 'org-latex-fragment-justify-advice)

  ;; ** numbering latex equations

  ;; Numbered equations all have (1) as the number for fragments with vanilla
  ;; org-mode. This code injects the correct numbers into the previews so they
  ;; look good.
  (defun org-renumber-environment (orig-func &rest args)
    "A function to inject numbers in LaTeX fragment previews."
    (let ((results '())
	  (counter -1)
	  (numberp))

      (setq results (loop for (begin .  env) in
			  (org-element-map (org-element-parse-buffer) 'latex-environment
			    (lambda (env)
			      (cons
			       (org-element-property :begin env)
			       (org-element-property :value env))))
			  collect
			  (cond
			   ((and (string-match "\\\\begin{equation}" env)
				 (not (string-match "\\\\tag{" env)))
			    (incf counter)
			    (cons begin counter))
			   ((string-match "\\\\begin{align}" env)
			    (prog2
				(incf counter)
				(cons begin counter)
			      (with-temp-buffer
				(insert env)
				(goto-char (point-min))
				;; \\ is used for a new line. Each one leads to a number
				(incf counter (count-matches "\\\\$"))
				;; unless there are nonumbers.
				(goto-char (point-min))
				(decf counter (count-matches "\\nonumber")))))
			   (t
			    (cons begin nil)))))

      (when (setq numberp (cdr (assoc (point) results)))
	(setf (car args)
	      (concat
	       (format "\\setcounter{equation}{%s}\n" numberp)
	       (car args)))))

    (apply orig-func args))

  (advice-add 'org-create-formula-image :around #'org-renumber-environment)

  (defun org-inject-latex-fragment (orig-func &rest args)
    "Advice function to inject latex code before and/or after the equation in a latex fragment.
You can use this to set \\mathversion{bold} for example to make it bolder."
    (setf (car args)
	  (concat
	   (or (plist-get org-format-latex-options :latex-fragment-pre-body) "")
	   (car args)
	   (or (plist-get org-format-latex-options :latex-fragment-post-body) "")))
    (apply orig-func args))

  (advice-add 'org-create-formula-image :around #'org-inject-latex-fragment )
  )
#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       153a637e-68b2-40fd-b75f-5fea92bcc071
:END:
#+begin_src emacs-lisp
)
#+end_src
*** Babel
:PROPERTIES:
:ID:       b11124c4-3bad-445e-b8d1-8f2a61471da5
:END:

Babel is a great way to combine source code and text.
The source code editing is usually done in a new buffer. However, I do not like the default binding =C-c C-'=. I use =C-c C-b= instead.

#+begin_src emacs-lisp
(bind-key "C-c C-b" 'org-edit-special org-mode-map)
(bind-key "C-c C-b" 'org-edit-src-exit org-src-mode-map)
(defun poly-org-edit-special ()
  "Run `org-edit-special' from poly-org."
  (interactive)
  (polymode-with-current-base-buffer #'funcall-interactively #'org-edit-special))
(use-package poly-org
  :config
  (bind-key "C-c C-b" #'poly-org-edit-special poly-org-mode-map))
#+end_src

For convenience, add =header-args= property to completion 

,#+begin_src emacs-lisp
(add-to-list 'org-default-properties "header-args")
#+end_src

**** Structure templates
:PROPERTIES:
:CREATED:  [2018-10-18 Thu 21:24]
:ID:       c9773614-0fec-4d7d-8ee3-72155d16d91c
:END:

I can just type =<el<TAB>= to enter elisp code block. 
It can be done using =org-tempo=.

#+begin_src emacs-lisp
(use-package org-tempo
  :config
  (push (cons "el" "src emacs-lisp") org-structure-template-alist))
#+end_src

However, =org-tempo= does not allow much customization. I prefer to enter source block editing mode right after expanding the template. I redefine =org-tempo-add-block= to enter edit mode after expanding.
Since I use [[id:e90d8071-a7ed-4aba-a694-a78aa5fded78][Boon navigation & search]], I also switch to insert state after running =org-edit-special=.


#+begin_src emacs-lisp
(use-package org-tempo
  :if init-flag
  :init
  (define-advice org-tempo-complete-tag (:filter-return (return) yant/org-tempo-enter-src-edit)
    "Run `org-edit-special' and switch to `boon-insert' state after completion."
    (when return
      (org-edit-special)
      (boon-set-insert-state))))
#+end_src

**** Source block editing functions from scimax
:PROPERTIES:
:CREATED:  [2018-10-22 Mon 20:55]
:ID:       6d452ed8-ddb4-4252-b66e-8609866d0fe1
:END:

#+begin_src emacs-lisp
(bind-keys :map boon-command-map
	   ("S" . scimax-split-src-block)
           ("Z" . scimax-insert-src-block))

;; from https://github.com/jkitchin/scimax/blob/master/scimax-ob.el
(defun scimax-insert-src-block (&optional below)
  "Insert a src block above the current point.
With prefix arg BELOW, insert it below the current point.
If point is in a block, copy the header to the new block"
  (interactive "P")
  (if (org-in-src-block-p)
      (let* ((src (org-element-context))
	     (start (org-element-property :begin src))
	     (end (org-element-property :end src))
	     (lang (org-element-property :language src))
	     (switches (or (org-element-property :switches src) ""))
	     (parameters (or (org-element-property :parameters src) ""))
	     location)
	(if below
	    (progn
	      (goto-char start)
	      (setq location (org-babel-where-is-src-block-result nil nil))
	      (if (not  location)
		  (goto-char end)
		(goto-char location)
		(goto-char (org-element-property :end (org-element-context))))
	      (insert (format "\n#+BEGIN_SRC %s %s %s
,#+END_SRC\n\n" lang switches parameters))
	      (forward-line -3))
	  ;; after current block
	  (goto-char (org-element-property :begin (org-element-context)))
	  (insert (format "\n#+BEGIN_SRC %s %s %s
,#+END_SRC\n\n" lang switches parameters))
	  (forward-line -3)))

    ;; Not in a src block, just insert a block
    (beginning-of-line)
    (insert (format "\n#+BEGIN_SRC %s
,#+END_SRC\n" (completing-read "Language: " (mapcar 'car org-babel-load-languages))))
    (forward-line -1)))


(defun scimax-split-src-block (&optional above)
  "Split the current src block with point in between the blocks."
  (interactive "P")
  (let* ((el (org-element-context))
	 (p (point))
	 (language (org-element-property :language el))
	 (switches (org-element-property :switches el))
	 (parameters (org-element-property :parameters el)))

    (beginning-of-line)
    (insert (format "#+END_SRC
,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))
    (forward-line -1)
    (insert "\n")
    (forward-line -1)))
#+end_src
**** TODO Change major mode in the source blocks
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 17:28]
:ID:       b9c7a2cd-ef10-4add-aefd-ecc1987ecc69
:END:
:LOGBOOK:
- State "TODO"       from "TODO"       [2018-10-24 Wed 18:18]
- State "TODO"       from              [2018-10-24 Wed 18:17]
:END:
It is always annoying that I need switch to separate window to edit source blocks even when it is a one liner.

=Polymode= allows having multiple major modes depending on cursor position in the buffer.
I use it to activate alternative major modes in source blocks.

#+begin_src emacs-lisp
(use-package polymode
  :ensure t
  :init
  (use-package poly-org
    :ensure t
    :init
    (setq poly-lock-allow-fontification nil)
    (defun org-source-block-major-mode ()
      "Return the name of major mode for the org source block at point."
      (when (re-search-forward "#\\+begin_src +\\([^ \t\n]+\\)")
        (if (string-match "\\(bash\\|sh\\|shell\\)" (match-string 1))
            "sh"
          (format "%s" (match-string 1)))))
    (setq pm-inner/org
	  (pm-inner-auto-chunkmode :name "org"
				   :mode 'host
				   :head-mode 'host
				   :tail-mode 'host
				   :head-matcher "^[ \t]*#\\+begin_src .*\n"
				   :tail-matcher "^[ \t]*#\\+end_src"
				   :head-adjust-face nil
				   :mode-matcher #'org-source-block-major-mode
				 :indent-offset org-edit-src-content-indentation))
    ))
#+end_src

=mmm-mode= also allows having multiple major modes depending on cursor position in the buffer. 
However, it does not fully replace major mode locally. 
This mode is only taking care about keymap, menu, local variables, font-lock, and indentation.
It does not really take care about the minor modes and does not run the =submode= hooks either. 
It is not acceptable for me and it is not easy to re-implement by myself.
Leaving the code below for reference.

#+begin_src emacs-lisp :tangle no
  (use-package mmm-mode
    :ensure t
    :disabled
    :init
    (setq mmm-global-mode 'auto
	  mmm-submode-decoration-level 2)
    (custom-set-faces '(mmm-declaration-submode-face ((t :background "#D1D4D9"))))
    :config
    (defun mmm-here-org-block-get-mode (heading)
      "Detect the submode to be used with the current org source block."
      (string-match "%\\#\\+begin_src +\\([^ ]+\\)" heading)
      (let ((lang (match-string-no-properties 1)))
	(if lang
	    (org-src--get-lang-mode lang)
	  (signal 'mmm-no-matching-submode nil))))
  
    (mmm-add-classes '((org-mode-block
			:face mmm-declaration-submode-face
			:front "^\\#\\+begin_src +\\([a-zA-Z-]+\\).*$"
			:front-offset (end-of-line 1)
			:back "^\\#\\+end_src$"
			:back-offset (beginning-of-line)
			:match-submode mmm-here-org-block-get-mode
			:delimiter-mode nil
			)))
    (mmm-add-mode-ext-class 'org-mode nil 'org-mode-block)
    )
#+end_src

**** Backends	
:PROPERTIES:
:ID:       397b6a12-0a2f-4d05-9c76-9735314434fa
:END:
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "~/.emacs.d/site-lisp/ditaa.jar")
(setq org-babel-mathematica-command "~/bin/MathematicaScript -script")

(org-babel-do-load-languages 'org-babel-load-languages
			     '(
			       (shell .t)
			       (emacs-lisp . t)
			       (org . t)
			       (perl . t)
			       (python .t)
			       (C . t)
			       (ditaa . t)
			       (gnuplot . t)
			       (calc . t)
			       (dot . t)
			       (latex . t)
			       (mathematica . t)
			       ))
(use-package wolfram-mode
  :if init-flag
  :defer t
  :init
  (add-to-list 'org-src-lang-modes '("mathematica" . "wolfram")))
#+end_src
**** Default arguments
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:58]
:ID:       27e1a878-35c8-4023-8881-645393db0274
:END:
- =Noweb= is useful, I'd rather enable it everywhere than set it every time to run the code
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args '((:session . "none")
				      (:results . "replace")
                                      (:exports . "code")
                                      (:cache . "no")
                                      (:noweb . "yes")
                                      (:hlines . "no")
                                      (:tangle . "no")
                                      (:comments . "link")
                                      (:eval . "never-export")))
(setq org-babel-default-header-args:shell '((:results output)))
#+END_SRC
- Show stderr in the shell output ([[https://github.com/novoid/dot-emacs/blob/master/config.org][Source]])
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:sh
      '((:prologue . "exec 2>&1") (:epilogue . ":"))
      )
#+END_SRC
**** TODO Evaluation
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:03]
:ID:       49900f8e-cde9-4e41-944a-904852ad92b9
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-11 Wed 09:19]
:END:
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
I hate when org is cluttering org file directory with generated files (=:file=). It is better to save everything inside hidden entry's attachment folder instead. I just redefine =default-directory= before
=org-babel-execute-src-block=, so that =:dir= or =:output-dir= can be still set if needed.

*************** TODO we cannot do it using default-directory because expand-file-name is going recursive if org-babel-execute-src-block calls expand-file-name inside
*************** END

#+BEGIN_SRC emacs-lisp
(define-advice org-babel-execute-src-block (:filter-args (&optional args) set-detault-dir-to-org-attach-path)
  "Set working directory to the current entry's attach directory."
  (if (eq major-mode 'org-mode)
      (let* ((directory (file-name-as-directory (org-attach-dir 'create-if-none)))
	     (arg (car args))
             (info (cadr args))
             (params (org-babel-merge-params (nth 2 info) (caddr args)))
             (dir-param (alist-get :dir params)))
        (unless (and dir-param (f-absolute-p dir-param))
          (setf (alist-get :dir params)
		(if dir-param
                    (f-join directory (alist-get :dir params))
                  directory)))
	(list arg info params))
    (list arg info params)))
#+END_SRC

Also, it make sense to show inline images, which I frequently generate via gnuplot after the evaluation
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC
***** TODO gnuplot
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 18:40]
:ID:       9c897a8c-e847-456d-9bf9-b905ba90f4fd
:END:

I had to modify =org-babel-expand-body:gnuplot= to make it respect =:dir= property.

#+BEGIN_SRC emacs-lisp
(defun org-babel-expand-body:gnuplot (body params)
  "Expand BODY according to PARAMS, return the expanded body."
  (save-window-excursion
    (let* ((vars (org-babel-gnuplot-process-vars params))
           (out-file (cdr (assq :file params)))
	   (prologue (cdr (assq :prologue params)))
	   (epilogue (cdr (assq :epilogue params)))
	   (term (or (cdr (assq :term params))
                     (when out-file
		       (let ((ext (file-name-extension out-file)))
			 (or (cdr (assoc (intern (downcase ext))
					 ,*org-babel-gnuplot-terms*))
			     ext)))))
           (title (cdr (assq :title params)))
           (lines (cdr (assq :line params)))
           (sets (cdr (assq :set params)))
           (x-labels (cdr (assq :xlabels params)))
           (y-labels (cdr (assq :ylabels params)))
           (timefmt (cdr (assq :timefmt params)))
           (time-ind (or (cdr (assq :timeind params))
                         (when timefmt 1)))
	   (directory (or (alist-get :dir params)
			  default-directory))
	   (add-to-body (lambda (text) (setq body (concat text "\n" body)))))
      ;; append header argument settings to body
      (when title (funcall add-to-body (format "set title '%s'" title)))
      (when lines (mapc (lambda (el) (funcall add-to-body el)) lines))
      (when sets
	(mapc (lambda (el) (funcall add-to-body (format "set %s" el))) sets))
      (when x-labels
	(funcall add-to-body
		 (format "set xtics (%s)"
			 (mapconcat (lambda (pair)
				      (format "\"%s\" %d"
					      (cdr pair) (car pair)))
				    x-labels ", "))))
      (when y-labels
	(funcall add-to-body
		 (format "set ytics (%s)"
			 (mapconcat (lambda (pair)
				      (format "\"%s\" %d"
					      (cdr pair) (car pair)))
				    y-labels ", "))))
      (when time-ind
	(funcall add-to-body "set xdata time")
	(funcall add-to-body (concat "set timefmt \""
				     (or timefmt
					 "%Y-%m-%d-%H:%M:%S") "\"")))
      (when out-file
	;; set the terminal at the top of the block
	(funcall add-to-body (format "set output \"%s\"" out-file))
	;; and close the terminal at the bottom of the block
	(setq body (concat body "\nset output\n")))
      (when term (funcall add-to-body (format "set term %s" term)))
      ;; insert variables into code body: this should happen last
      ;; placing the variables at the *top* of the code in case their
      ;; values are used later
      (funcall add-to-body
	       (mapconcat #'identity
			  (org-babel-variable-assignments:gnuplot params)
			  "\n"))
      ;; replace any variable names preceded by '$' with the actual
      ;; value of the variable
      (mapc (lambda (pair)
	      (setq body (replace-regexp-in-string
			  (format "\\$%s" (car pair)) (cdr pair) body)))
	    vars)
      (when prologue (funcall add-to-body prologue))
      (when epilogue (setq body (concat body "\n" epilogue)))
      ;; Setting the directory needs to be done first so that
      ;; subsequent 'output' directive goes to the right place.
      (when directory (funcall add-to-body (format "cd '%s'" directory))))
    body))
#+END_SRC

***** Async evaluation
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 21:10]
:ID:       11a37f26-ef17-43ec-bb9b-43155f9fc9ec
:END:
#+begin_src emacs-lisp
(use-package ob-async
  :ensure t
  )
#+end_src
**** TODO Tangle
:PROPERTIES:
:ID:       6e72e3ca-4679-4caf-9af4-2291096eab58
:END:
I have a lot of small scripts and programs written at some point for some purpose I do not remember anymore. Hence, I prefer to use org files instead of all kinds of script files in the system. There are few things, which I need to make it work comfortably:
- make sure that the script are tangled when I save org file, because it is easy to forget tangling of some files after editing.
*************** TODO Auto tangle on save
*************** END

#+begin_src emacs-lisp 
(defun yant/org-babel-tangle-async (file &optional target-file lang)
  "Ivoke `org-babel-tangle-file' asynchronously."
  (require 'async)
  (async-start
   (let ((args (list file target-file lang)))
     `(lambda ()
	(setq org-tangle-flag t)
	(load "~/.emacs.d/config.el" nil nil nil t)
	(apply #'org-babel-tangle-file ',args)))
   (let ((message-sting (format "Tangling (%S %S %S) completed." file target-file lang)))
     `(lambda (result) (message ,message-sting)))))

(defvar yant/auto-tangle-list nil
  "List of files, which can be safely tangled on save.
The list is saved between Emacs sessions.")

(when init-flag
  (use-package savehist
    :config
    (add-to-list 'savehist-additional-variables 'yant/auto-tangle-list))
  (savehist-mode +1)
  (defun yant/toggle-buffer-auto-tangle (arg)
    "Toggle auto tangling of a buffer."
    (interactive "P")
    (if (not (eq major-mode 'org-mode))
	(message "Org-mode is not active in buffer \"%s\"" (buffer-name))
      (cond ((not arg)
	     (if (member (buffer-file-name) yant/auto-tangle-list)
		 (progn (setq yant/auto-tangle-list (delete (buffer-file-name) yant/auto-tangle-list))
			(message "Auto tangling disabled for %s" (buffer-file-name)))
	       (add-to-list 'yant/auto-tangle-list (buffer-file-name))
               (message "Auto tangling enabled for %s" (buffer-file-name))))
            ((or (and (not (listp arg)) (> arg 0))
		 (equal arg '(4)))
             (add-to-list 'yant/auto-tangle-list (buffer-file-name))
             (message "Auto tangling enabled for %s" (buffer-file-name)))
            (t
             (setq yant/auto-tangle-list (delete (buffer-file-name) yant/auto-tangle-list))
	     (message "Auto tangling disabled for %s" (buffer-file-name))))))

  (bind-key "C-c C-*" #'yant/toggle-buffer-auto-tangle org-mode-map))

  (defun yant/org-babel-tangle-current-buffer-async ()
    "Tangle current buffer asynchronously."
    (when (and (eq major-mode 'org-mode)
	       (member (buffer-file-name) yant/auto-tangle-list))
      (yant/org-babel-tangle-async (buffer-file-name))))

(add-hook 'after-save-hook #'yant/org-babel-tangle-current-buffer-async)
#+end_src


**** Export
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:47]
:END:
Frequently, I run heavy analytical code as a part of my project. I it totally inconvenient to run these hour longing codes during export. Hence, I [[id:27e1a878-35c8-4023-8881-645393db0274][disable]] babel evaluation on export by default.
*** Appearance
**** Links
***** Show broken links to files
:PROPERTIES:
:ID:       df5b9cb0-e3d1-406e-b71f-55a7b90c221e
:END:
#+begin_src emacs-lisp
(org-link-set-parameters
 "file"
 :face (lambda (path) (if (file-exists-p (org-link-unescape path)) 'org-link 'org-warning)))
#+end_src
**** Items
:PROPERTIES:
:ID:       6b238696-fbbe-4206-91fb-eeebff4a032a
:END:
- I do not want bigger items font because I tend to use items a lot
  #+begin_src emacs-lisp
  (custom-set-faces
   '(org-level-1 ((t (:inherit outline-1 :height 1.0))))
   '(org-level-2 ((t (:inherit outline-2 :height 1.0))))
   '(org-level-3 ((t (:inherit outline-3 :height 1.0))))
   '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
   '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
   )
  #+end_src
- prefer bullets instead of stars in items
  #+begin_src emacs-lisp
(use-package org-bullets
  :ensure t
  :disabled
  :config
  (setq org-bullets-bullet-list '("⁂" "•" "⊢" "⋮" "⋱" "⋱" "⋱"))
  (add-hook 'org-mode-hook
	    '(lambda () (org-bullets-mode 1))
	    'append))
  #+end_src
- prefer to replace default =...= by something more distinct if item is folded
  #+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ⤵")
(set-face-underline 'org-ellipsis nil)
  #+END_SRC
- no blanks in items
  #+begin_src emacs-lisp
  ;;turn off blanks in a new entries
(setq org-blank-before-new-entry (quote ((heading)
					 (plain-list-item . auto))))
(setq org-cycle-separator-lines 0)
  #+end_src
- hide emphasis markers 
  #+begin_src emacs-lisp
  (setq org-hide-emphasis-markers t)
  #+end_src
- keyword faces
  #+begin_src emacs-lisp
  (setq org-todo-keyword-faces
	(quote (("TODO" :foreground "red" :weight bold)
      		("NEXT" :foreground "blue" :weight bold)
      		("DONE" :foreground "forest green" :weight bold)
      		("FAILED" :foreground "red" :weight bold)
      		("WAITING" :foreground "orange" :weight bold)
      		("HOLD" :foreground "magenta" :weight bold)
      		("CANCELLED" :foreground "gray80" :weight bold))))
(use-package pretty-symbols
  :disabled t 
  :config
  (setq pretty-symbol-patterns (append pretty-symbol-patterns '((?▤ org-specific ":LOGBOOK:" (org-mode))
      								(?⚙ org-specific ":PROPERTIES:" (org-mode))
      								(?⏏ org-specific ":END:" (org-mode))
      								;; (?★ org-specific "\\[#A\\]" (org-mode))
      								;; ("" org-specific "\\[#B\\]" (org-mode))
      								;; (?☕ org-specific "\\[#C\\]" (org-mode))
      								((yant/str-to-glyph "☐") org-specific "\\(?:^*+ +\\)\\(\\<TODO\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "☑") org-specific "\\(?:^*+ +\\)\\(\\<DONE\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "✘") org-specific "\\(?:^*+ +\\)\\(\\<FAILED\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "✘") org-specific "\\(?:^*+ +\\)\\(\\<CANCELLED\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "▶") org-specific "\\(?:^*+ +\\)\\(\\<NEXT\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "⚑") org-specific "\\(?:^*+ +\\)\\(\\<WAITING\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "♲") org-specific "\\(?:^*+ +\\)\\(\\<HOLD\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "☠D") org-specific "\\<DEADLINE:" (org-mode))
      								((yant/str-to-glyph "◴S") org-specific "\\<SCHEDULED:" (org-mode))))))
(use-package org-fancy-priorities
  :disabled t
  :if init-flag
  :ensure t
  :hook 
  ((org-mode org-agenda-mode) . org-fancy-priorities-mode)
  :diminish org-fancy-priorities-mode
  :config
  (setq org-fancy-priorities-list '("★" "" "☕")))
  #+end_src
- truncation by default
#+BEGIN_SRC emacs-lisp
(setq org-startup-truncated t)
#+END_SRC
- no leading stars
#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC
- no indentation inside entries
#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC
**** Agenda
:PROPERTIES:
:ID:       1c3c3255-10b3-401c-99cf-3edd91427475
:END:
#+begin_src emacs-lisp
(defun place-agenda-tags ()
  "Put the agenda tags by the right border of the agenda window."
  (setq org-agenda-tags-column (- 4 (window-width)))
  (org-agenda-align-tags))
(add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
(defadvice org-agenda (around split-vertically activate)
  (let ((split-width-threshold 1000))  ; or whatever width makes sense for you
    ad-do-it))
#+end_src
- do not highlight line below mouse
  #+begin_src emacs-lisp
  (defun yant/remove-mouse-highlight ()
    "Remove all mouse highlights in buffer."
    (let ((inhibit-read-only t))
      (remove-text-properties
       (point-min) (point-max) '(mouse-face t))))
(add-hook 'org-agenda-finalize-hook
	  #'yant/remove-mouse-highlight)
  #+end_src
- highlight current line in agenda
  #+begin_src emacs-lisp
  (use-package hl-line
    :if init-flag

    :diminish global-hl-line-mode
    :config
    (progn
      (add-hook 'org-agenda-mode-hook
		'(lambda () (hl-line-mode 1))
		'append)
      )
    )
  #+end_src
- prefix for entries
  #+begin_src emacs-lisp
  (setq org-agenda-scheduled-leaders '("* today" "* %2d d. ago"))
(defun yant/format-summary-for-agenda ()
  "Format the contents of :SUMMARY: property to show in agenda view."
  (let ((summary (org-entry-get (point) "SUMMARY" 'INHERIT)))
    (if summary
	(concat "\tComment: \"" summary "\"\n\t\t\t\t\t")
      "")))
(defun yant/format-time-balance-multiplier ()
  "Format :ORG-TIME-BALANCE-MULTIPLIER: into agenda."
  (condition-case nil
      (let ((mult (org-get-time-balance-multiplier-at-point))
	    (bonus (org-get-org-time-bonus-on-done-at-point))
            (scheduled? (string-match-p "\\." (or (org-entry-get (point) "SCHEDULED") ""))))
	(format "%s%s%s" (if scheduled? "↰" " ") (if mult (format "%sx" mult) "")
		(if (and bonus (> bonus 0)) (format "+%s" bonus) "")))
    (error "")))
(setq org-agenda-prefix-format "%-12s\t%-12:c\t%?-12t%(concat (yant/format-summary-for-agenda) (yant/format-time-balance-multiplier) \"\\t\")")
  #+end_src
**** Babel
:PROPERTIES:
:ID:       6fed68f0-c4ca-43f3-b487-4b58d9dc1315
:END:
#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
    org-src-preserve-indentation t
      org-hide-block-startup nil)
(set-face-background 'org-block "Gainsboro")
#+end_src
**** Symbols 
:PROPERTIES:
:ID:       aae027ae-a2b7-42b6-a833-cf038edcad3a
:END:
#+begin_src emacs-lisp 
(setq org-pretty-entities t)
(setq org-pretty-entities-include-sub-superscripts t)
#+end_src
**** =Eldoc= integration
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:31]
:ID:       d858e349-99e4-4117-83c6-78b75acf6160
:END:

#+begin_src emacs-lisp 
(use-package org-eldoc)
(add-hook 'org-mode-hook (lambda () (setq-local eldoc-documentation-function #'org-eldoc-documentation-function)))
#+end_src

*** Misc
:PROPERTIES:
:ID:       b195d9ea-e3e0-476e-b898-43b69fbd365d
:END:
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'error)
(setq org-M-RET-may-split-line '((default . nil)))
(setq org-startup-folded nil)
(setq org-show-context-detail
      '((agenda . lineage) ;; instead of "local"
	(bookmark-jump . lineage)
	(isearch . lineage)
	))
#+end_src
**** COMMENT Org element cache
:PROPERTIES:
:CREATED:  [2018-11-18 Sun 13:04]
:ID:       7c1c828b-3a77-4e79-b07a-4ad173a5f87a
:END:

I was irritated by org-mode behaviour when =flycheck= is turned on. org-mode introduces additional =flycheck= hook, which is ran after movement/editing commands. This hook calls =org-element-at-point=, which is terrible on large files.
Turning on org element cache in attempt to make it faster.

#+begin_src emacs-lisp
(custom-set-variables '(org-element-use-cache t))
#+end_src

*************** TODO check if it is good enough
*************** END


*** Notmuch interaction
:PROPERTIES:
:ID:       e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326
:END:
:LOGBOOK:
CLOCK: [2018-09-06 Thu 21:10]--[2018-09-06 Thu 22:51] =>  1:41
:END:

#+begin_src emacs-lisp
(use-package org-notmuch)
(use-package helm-notmuch
  :ensure t
  :config
  (let ((helm-source-notmuch-action (alist-get 'action helm-source-notmuch)))
    (setf (alist-get 'action helm-source-notmuch)
	  (append helm-source-notmuch-action (list '("Copy message link" . org-store-notmuch-link))))))

(defun org-store-notmuch-link (CANDIDATE)
  "Store CANDIDATE org link to notmuch message."
  (let ((link (format "notmuch:%s" CANDIDATE)))
    (interactive)
    (org-open-link-from-string link)
    (set-buffer (first (buffer-list)))
    (let ((desc (replace-regexp-in-string "\\[\\|\\]" "" (notmuch-show-get-subject))))
      (notmuch-bury-or-kill-this-buffer)
      (push (list (format "notmuch:%s" CANDIDATE) desc) org-stored-links))))


(defun yant/add-email-to-task (&optional ARG)
  "Add an email into :EMAIL-SOURCE: property of the task.
       C-u argument means that we add the last link from link ring."
  (interactive)
  (if (eq ARG '4)
      (let ((last-link (car (car org-stored-links)))
	    (last-description (cadr (car org-stored-links))))
	(if (string-match "^notmuch.*$" last-link)
            (progn
	      (org-set-property "EMAIL-SOURCE" (concat "[[" last-link "][" last-description "]]"))
              (org-back-to-heading)
              (org-set-tags-to (append (org-get-tags nil t) '("EMAIL"))))
	  (message "Link \"%s\" is not a message link." last-link))
        (yant/mark-linked-email-after-todo-state-change))
    (let ((helm-source-tmp (copy-alist helm-source-notmuch)))
      (setf (alist-get 'action helm-source-tmp) (list '("Copy message link" . org-store-notmuch-link)))
      (setf (alist-get 'header-line helm-source-tmp) "C-j: Associate the task with an email")
      (helm :sources helm-source-tmp
	    :buffer "*helm notmuch*"
	    :truncate-lines t))
    (yant/add-email-to-task '4)))

(defun yant/mark-linked-email-after-todo-state-change ()
  "Remove inbox tag from a linked email :EMAIL-SOURCE: after the task is marked as finished."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components))))
	(email-link (org-entry-get nil "EMAIL-SOURCE"))
	(done-keywords org-done-keywords))
    (when (not (or (not email-link)
		   (eq email-link "")))
      (interactive)
      (org-open-link-from-string email-link)
      (with-current-buffer (first (buffer-list))
	(if (member mystate done-keywords)
	    (notmuch-show-tag-message "-inbox" "-todo" "-listinbox")
	  (if mystate
	      (notmuch-show-tag-message "-listinbox" "+inbox" "-todo")
	    (if (member "inbox" (notmuch-show-get-tags))
		(notmuch-show-tag-message "-listinbox" "+inbox" "+todo"))))
	(notmuch-bury-or-kill-this-buffer)))))

(add-hook 'org-after-todo-state-change-hook 'yant/mark-linked-email-after-todo-state-change 'append)
(add-hook 'org-capture-before-finalize-hook 'yant/mark-linked-email-after-todo-state-change 'append)
#+end_src
*** Imenu integration
:PROPERTIES:
:CREATED:  [2018-10-25 Thu 22:50]
:ID:       72afd20b-f9c7-4c5b-84cf-a4073c62af76
:END:
=Imenu= appears to be slower in =org-mode= in comparison with =org-goto=
#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (setq org-goto-interface 'outline-path-completion)
  (add-to-list 'meta-functions-meta-goto-alist '(org-mode . helm-org-rifle-current-buffer))
  (meta-functions-update-function-definitions)
  )
#+end_src

*** TODO Key combinations
:PROPERTIES:
:ID:       fe1a02aa-90fb-4ddb-9d04-925b08697e58
:EMAIL-SOURCE: [[notmuch:id:0100015f833663f9-95881448-4653-4709-a5bb-bfa94f3f0bff-000000@email.amazonses.com][Email from Amazon com: Leave Packaging Feedback for y]]
:END:
#+begin_src emacs-lisp
(when init-flag
(bind-keys 
 ("C-c C-S-l" . org-store-link)
 ("C-c m" . org-capture)
 ("C-c c" . org-clock-goto)
 :map boon-goto-map
 ("a" . org-agenda)
 ("t" . gtd-open)
 ("n" . notes-open)
 )
(bind-keys :map org-mode-map
	   ("C-c C-+" . add-current-buffer-to-agenda-files)
	   ("C-c C--" . remove-current-buffer-from-agenda-files)
	   ("C-c e" . yant/add-email-to-task) 
	   ("C-c i" . org-clock-in)
	   ("C-c o" . org-clock-out)
           :map org-agenda-mode-map
           ("s" . org-agenda-bulk-mark)
           ("S" . org-agenda-bulk-mark-all)
	   ("a" . org-agenda-bulk-unmark)
	   ("A" . org-agenda-bulk-unmark-all))

(defun org-agenda-goto-and-narrow ()
  "Run `org-agenda-goto' and narrow to subtree."
  (interactive)
  (org-agenda-goto)
  (org-narrow-to-subtree)
  (delete-other-windows))

(bind-keys :map org-agenda-mode-map
	   ("<tab>" . org-agenda-goto-and-narrow))

(use-package meta-functions
  :config
  (add-to-list 'meta-functions-meta-move-line-up-alist '(org-mode . org-metaup))
  (add-to-list 'meta-functions-meta-move-line-down-alist '(org-mode . org-metadown))
  (add-to-list 'meta-functions-meta-move-element-up-alist '(org-mode . org-shiftmetaup))
  (add-to-list 'meta-functions-meta-move-element-down-alist '(org-mode . org-shiftmetadown))
  (add-to-list 'meta-functions-meta-move-element-left-alist '(org-mode . org-shiftmetaleft))
  (add-to-list 'meta-functions-meta-move-element-right-alist '(org-mode . org-shiftmetaright))
  (add-to-list 'meta-functions-meta-move-line-left-alist '(org-mode . org-metaleft))
  (add-to-list 'meta-functions-meta-move-line-right-alist '(org-mode . org-metaright))
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(org-mode . org-insert-heading-respect-content))
  (add-to-list 'meta-functions-meta-insert-active-enclosure-new-line-alist '(org-mode . org-insert-todo-heading-respect-content))
  (add-to-list 'meta-functions-meta-new-line-alist '(org-mode . org-return))
  (defun yant/org-smart-meta-down-element ()
    "Move down org item if at heading, move down paragraph otherwise."
    (interactive)
    (if (org-at-heading-p)
	(call-interactively #'org-next-visible-heading)
      (forward-paragraph)))
  (defun yant/org-smart-meta-up-element ()
    "Move up org item if at heading, move up paragraph otherwise."
    (interactive)
    (if (org-at-heading-p)
	(call-interactively #'org-previous-visible-heading)
      (backward-paragraph)))  
  (add-to-list 'meta-functions-meta-down-element-alist '(org-mode . yant/org-smart-meta-down-element))
  (add-to-list 'meta-functions-meta-up-element-alist '(org-mode . yant/org-smart-meta-up-element))
  
  (add-to-list 'meta-functions-meta-move-line-up-alist '(org-struct-mode . org-metaup))
  (add-to-list 'meta-functions-meta-move-line-down-alist '(org-struct-mode . org-metadown))
  (add-to-list 'meta-functions-meta-move-element-up-alist '(org-struct-mode . org-shiftmetaup))
  (add-to-list 'meta-functions-meta-move-element-down-alist '(org-struct-mode . org-shiftmetadown))
  (add-to-list 'meta-functions-meta-move-element-left-alist '(org-struct-mode . org-shiftmetaleft))
  (add-to-list 'meta-functions-meta-move-element-right-alist '(org-struct-mode . org-shiftmetaright))
  (add-to-list 'meta-functions-meta-move-line-left-alist '(org-struct-mode . org-metaleft))
  (add-to-list 'meta-functions-meta-move-line-right-alist '(org-struct-mode . org-metaright))
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(org-struct-mode . org-insert-heading-respect-content))
  (add-to-list 'meta-functions-meta-insert-active-enclosure-new-line-alist '(org-struct-mode . org-insert-todo-heading-respect-content))
  (add-to-list 'meta-functions-meta-new-line-alist '(org-struct-mode . org-return))
  (add-to-list 'meta-functions-meta-up-alist '(org-agenda-mode . org-agenda-previous-line))
  (add-to-list 'meta-functions-meta-down-alist '(org-agenda-mode . org-agenda-next-line))
  (meta-functions-update-function-definitions))

)
#+end_src

**** Boon integration
:PROPERTIES:
:ID:       3bc88ae9-2346-4d9a-b50f-5e9970aa173a
:END:
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'boon-insert 'append)
#+end_src
*** =__finalize=
:PROPERTIES:
:ID:       8414a0fc-0456-4c19-a20d-cc20af9573be
:END:
#+begin_src emacs-lisp
)
#+end_src
** Sensitive info                                                  :NOEXPORT:
:PROPERTIES:
:ID:       83801f6a-daf5-4738-a15e-2d20c2b4551c
:END:
#+begin_src emacs-lisp
(org-babel-load-file "~/PersonalDocuments/emacs-personal.org")
#+end_src
** Magic - I have no clue why it works
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:50]
:END:
*** Strange error with =w3m-idle-timer=
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:51]
:ID:       7ce2e20a-7f38-4cb2-9241-6bd1b7e10d39
:END:
#+BEGIN_SRC emacs-lisp
(setq w3m-image-no-idle-timer t)
#+END_SRC
** TODO Summary of key bindings
*** Command frequency measurement in emacs
:PROPERTIES:
:ID:       cd5dd0a5-e810-4846-91a3-ba5b6c649cdc
:END:
#+begin_src emacs-lisp
(use-package keyfreq
  :ensure t
  :config
  (define-globalized-minor-mode global-keyfreq-mode keyfreq-mode
    (lambda nil (progn (keyfreq-mode 1) (keyfreq-autosave-mode 1))))
  (global-keyfreq-mode))
#+end_src
