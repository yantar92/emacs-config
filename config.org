:PROPERTIES:
:ID:       922b85aa-b01d-47ac-b34e-99201b7f9abf
:END:
#+SETUPFILE: ~/Org/common.setup
#+AUTHOR: Ihor Radchenko
#+EMAIL: yantar92@gmail.com
#+PROPERTY: header-args+ :tangle "~/.emacs.d/config.el" :comments link

* NEXT Emacs configuration                                                                                                         :AREA:EMACS:COMMON:
:PROPERTIES:
:ID:       a27092a6-25a6-417f-818f-7f83325b58b3
:ORG-TIME-BALANCE-MULTIPLIER: -0.5
:CREATED:  [2020-05-28 Thu 13:55]
:END:
:LOGBOOK:
CLOCK: [2020-04-09 Thu 17:43]--[2020-04-09 Thu 17:44] =>  0:01
CLOCK: [2019-12-27 Fri 23:03]--[2019-12-27 Fri 23:04] =>  0:01
CLOCK: [2019-12-19 Thu 12:52]--[2019-12-19 Thu 12:53] =>  0:01
CLOCK: [2019-12-09 Mon 20:45]--[2019-12-09 Mon 20:46] =>  0:01
- State "NEXT"       from "NEXT"       [2018-09-06 Thu 21:10]
CLOCK: [2018-07-23 Mon 00:16]--[2018-07-23 Mon 00:23] =>  0:07
- State "NEXT"       from "NEXT"       [2018-07-11 Wed 18:17]
- State "NEXT"       from "NEXT"       [2018-07-09 Mon 21:47]
- State "NEXT"       from "NEXT"       [2018-01-01 Mon 13:17]
CLOCK: [2017-12-30 Sat 22:19]--[2017-12-30 Sat 22:24] =>  0:05
CLOCK: [2017-12-30 Sat 17:03]--[2017-12-30 Sat 17:14] =>  0:11
- State "NEXT"       from "NEXT"       [2017-12-29 Fri 23:14]
CLOCK: [2017-12-28 Thu 18:41]--[2017-12-28 Thu 18:42] =>  0:01
CLOCK: [2017-12-28 Thu 17:59]--[2017-12-28 Thu 18:40] =>  0:41
:END:

This is me

#+begin_src emacs-lisp
;; Setting this is not only fancy, but actually used
;; for example, by yasnippet when filling elisp file header
(setq user-full-name "Ihor Radchenko")
(setq user-mail-address "yantar92@gmail.com")
#+end_src

I am not really doing much programming, but rather use Emacs as knowledge base management tool.  Most of time, I do not even edit or type things directly, but read through the files.  Therefore, the main focus of this setup is =org-mode= and not as much programming, navigating through text and not as much editing.

The usage of =org-mode= unfortunately means that the overall performance of Emacs is generally not very good.  To improve things a little bit, I am trying to run things that "freeze" Emacs most terribly either asynchronously or in separate Emacs process.  Running in separate process would be terribly slow if I just load my main =init.el= over and over again as if I open a new instance of emacs interactively.  Hence, I design my =init.el= in the way that it can load faster in batch mode.

This Emacs configuration allows loading Emacs in both interactive and batch modes.  It is controlled by special variables, identifying startup mode:
- =init-flag= :: normal startup, load all the visual packages and options
- =org-export-flag= :: load necessary options for org-export
- =org-tangle-flag= :: load necessary options for org-tangle
One important note about this configuration is that I do not use =desktop-save-mode=.  Everything I intend to do is kept in my org files, which are automatically loaded by org agenda command.

#+begin_src emacs-lisp
(defvar init-flag nil
  "Do normal init if not nil.")
(defvar org-export-flag nil
  "Set up org export if not nil.")
(defvar org-tangle-flag nil
  "Set up org tangle if not nil.")
#+end_src

** =Init.el=
:PROPERTIES:
:ID:       0948a927-42a3-4284-aaed-1ca9dd27a538
:CREATED:  [2017-12-23 Sat 15:16]
:END:

Init file, which loads this file.
#+begin_src emacs-lisp :tangle "~/.emacs.d/init.el" :var org-file=(buffer-file-name) :var el-file="~/.emacs.d/config.el"
;;(package-initialize)
(setq init-flag t)
(setq comp-deferred-compilation 't) ;; enable automatic native-compilation
(load el-file)
#+end_src

** Emacs server settings
:PROPERTIES:
:ID:       5d8e1dca-a849-4980-bfde-cbf02801e92b
:END:

As many others, I run emacs in server mode. Actually, it is an nobrainer considering how long my huge org files are being opened.

Setup environment variables
*************** TODO load .profile instead of manual setting here
*************** END

#+begin_src emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/home/yantar92/bin/"))
#+end_src

Ensure one server instance
#+begin_src emacs-lisp
(when init-flag
  (require 'server)
  (unless (server-running-p)
    (server-start)))
#+end_src

Run server silently and ignore file clashes ([[https://www.reddit.com/r/emacs/comments/733698/if_a_file_has_changed_on_disk_save_anyway_without/][reddit]])
#+begin_src emacs-lisp
(defun ask-user-about-supersession-threat (args)
  "Ignore file clashes.")
#+end_src

Do not show large file warnings for anything \le100Mb.
The default 10Mb is too small for many pdfs.
#+begin_src emacs-lisp
(if init-flag 
    (setq large-file-warning-threshold (* 100 1024 1024)); 100Mb
  (setq large-file-warning-threshold nil))
#+end_src

Exit server silently without asking about unsaved buffers.
#+begin_src emacs-lisp
(add-hook 'kill-emacs-hook '(lambda() (save-some-buffers 'save-all-buffers)) 'append)
#+end_src

** Package management & configuration
:PROPERTIES:
:ID:       4c0a06f9-9e69-4ead-b570-e3143fa0d61d
:END:

Instead of the default emacs package manager, I use =straigt.el=.
My initial motivation was mostly the ability to get packages from github directly.
In addition, it would be useful to keep track modify the packages in some better way than advising.

*************** TODO Use =el-patch= and take a look at fork+master handling by =package.el=
*************** END

=Straight.el= can use =watchexec= to watch changes in the packages, which is much faster in comparison with default =find=.
Install =watchexec=
#+begin_src bash :dir "/sudo::/" :tangle no
layman -a chaoslab
emerge -v watchexec
#+end_src
*************** TODO Actually, this snippet might be useless on a fresh system. Need to add some check to indicate that missing package is a problem
*************** END

First, make sure that =straight.el= can fetch remote URLs from everywhere.
Set up the =askpass= and cache ssh password.

#+begin_src emacs-lisp
(setenv "DISPLAY" ":0.0")
(setenv "SSH_ASKPASS" "ssh-askpass-fullscreen")
(when init-flag
  (let ((ssh-auth-sock (shell-command-to-string "ssh-agent | grep SSH_AUTH_SOCK | cut -d= -f2 | cut -d';' -f1"))
	(ssh-agent-pid (shell-command-to-string "ssh-agent | grep SSH_AGENT_PID | cut -d= -f2 | cut -d';' -f1")))
    (setenv "SSH_AUTH_SOCK" (replace-regexp-in-string "\n" "" ssh-auth-sock))
    (setenv "SSH_AGENT_PID" (replace-regexp-in-string "\n" "" ssh-agent-pid))
    ;; (shell-command-to-string "ssh-add ~/.ssh/id_rsa")
    ))
#+end_src

And tell =straight.el= to use file watcher

#+begin_src emacs-lisp
;; https://github.com/raxod502/radian/blob/develop/emacs/radian.el
(if (and (executable-find "watchexec")
         (executable-find "python3"))
    (setq straight-check-for-modifications '(watch-files find-when-checking))
  (setq straight-check-for-modifications
        '(find-at-startup find-when-checking)))
#+end_src

For now, I use develop branch of =straight.el=
#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
#+end_src

And use default git protocol for git repositories in =straight.el= 
#+begin_src emacs-lisp
(setq straight-vc-git-default-protocol 'ssh)
#+end_src

[2020-04-25 Sat] Because of recent change in =straigh.el=, installing packages blocks Emacs even during async compilation [[https://github.com/raxod502/straight.el/issues/511][github issue #511]]
Fixing this
#+begin_src emacs-lisp
(setq straight--wait-for-async-jobs nil)
#+end_src

First, put the bootstrap code ([[https://github.com/raxod502/straight.el][as from straight.el readme]])
#+begin_src emacs-lisp
  (eval-and-compile
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage)))
#+end_src

Prefer loading fresh versions of lisp files
#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

Setup local =load-path= for whatever is not handled by =straigh.el=

*************** TODO This may better be done individually using :load-path option of use-package
*************** END

#+begin_src emacs-lisp
(eval-and-compile
  (setq load-path (append '("~/.emacs.d/site-lisp/") load-path))
  (setq load-path (append (directory-files "~/.emacs.d/site-lisp/" t "^[^.]" t) load-path)))
#+end_src

Now, I can setup =use-package= to simplify subsequent package configuration
*************** TODO make always defer work
*************** END
  #+begin_src emacs-lisp
(eval-and-compile (straight-use-package 'use-package))
;;(setq use-package-always-defer t)
(use-package diminish :straight t)
(use-package bind-key)
  #+end_src

*************** TODO separate all the diminish statements into appearance
*************** END

Load org to make sure that obsolete built-in org version is not used.
The main org-mode config is provided [[id:58045c39-ffd5-4ccc-bc9d-49048c437f42][later]].
Also use [[https://github.com/raxod502/straight.el/issues/352][this idea]], to make sure that =org-plus-contrib= is used any time another packages requires =org=.
#+begin_src emacs-lisp
(straight-use-package '(org
			:type git :repo "https://code.orgmode.org/bzg/org-mode.git"
                        :local-repo "org"
			:files (:defaults "contrib/lisp/*.el")
			:fork (:repo "/home/yantar92/Git/org-mode/")))
#+end_src

Keep customisation away from =init.el= in a separate file.
*************** TODO use :custom use-package keyword for setting customisation
*************** END
  #+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
;; (load custom-file)
  #+end_src

Keeping track of the new changes in packages 
https://github.com/raxod502/straight.el/issues/354

#+begin_src emacs-lisp
(setq straight-vc-git-auto-fast-forward nil)
#+end_src

Quick hydra menu for =straight.el=
*************** TODO rewrite using nicer hydras
*************** END
*************** TODO move elsewhere, but leave the link
*************** END
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :if init-flag
  :straight t
  :after boon
  :init (use-package straight-x :demand t)
  :bind (:map boon-x-map
	      ("p" . hydra-straight-helper/body))
  :config
  (defhydra hydra-straight-helper (:hint nil)
    "
_c_heck all       |_f_etch all (download)     |_m_erge all      |_n_ormalize all   |p_u_sh all
_C_heck package   |_F_etch package (download) |_M_erge package  |_N_ormlize package|p_U_sh package
----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
_r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
_R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
    ("c" straight-check-all)
    ("C" straight-check-package)
    ("r" straight-rebuild-all)
    ("R" straight-rebuild-package)
    ("f" straight-x-fetch-all)
    ("F" straight-fetch-package)
    ("p" straight-x-pull-all)
    ("P" straight-pull-package)
    ("m" straight-merge-all)
    ("M" straight-merge-package)
    ("n" straight-normalize-all)
    ("N" straight-normalize-package)
    ("u" straight-push-all)
    ("U" straight-push-package)
    ("v" straight-freeze-versions)
    ("V" straight-thaw-versions)
    ("w" straight-watcher-start)
    ("W" straight-watcher-quit)
    ("g" straight-get-recipe)
    ("e" straight-prune-build)
    ("q" nil)))
#+END_SRC

** TODO Elisp libraries to be used further
:PROPERTIES:
:CREATED:  [2020-04-22 Wed 16:39]
:ID:       7b9a8c35-f3f9-4390-8e5e-fb863abd3f8b
:END:

*** Extra functions for association lists
:PROPERTIES:
:ID:       3967e7cf-4152-4807-bedb-7f6df1312b73
:END:
*************** TODO study functions
*************** END
#+begin_src emacs-lisp
  (use-package asoc
    :demand t
    :straight (asoc.el :type git :host github :repo "troyp/asoc.el"))
#+end_src

*** Handy hook macros [[[https://github.com/weirdNox/dotfiles/blob/master/config/.emacs.d/config.org#hooks][credit]]] 
:PROPERTIES:
:ID:       a5b5ec10-bae3-4811-b47d-2c8a0b7408ed
:END:
#+begin_src emacs-lisp
(defun nox-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun nox-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))

(defun nox-resolve-hook-forms (hooks)
  (declare (pure t) (side-effect-free t))
  (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
           for hook in (nox-enlist (nox-unquote hooks))
           if (eq (car-safe hook) 'quote)
           collect (cadr hook)
           else if quoted-p
           collect hook
           else collect (intern (format "%s-hook" (symbol-name hook)))))

(defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:

   1. Optional properties :local and/or :append, which will make the hook
      buffer-local or append to the list of hooks (respectively),
   2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
      a quoted hook variable or a quoted list of hook variables. If unquoted, the
      hooks will be resolved by appending -hook to each symbol.
   3. A function, list of functions, or body forms to be wrapped in a lambda.

Examples:
    (add-hook! 'some-mode-hook 'enable-something)   (same as `add-hook')
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

Body forms can access the hook's arguments through the let-bound variable `args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (nox-resolve-hook-forms (pop args)))
          (funcs (let ((arg (car args)))
                   (if (memq (car-safe arg) '(quote function))
                       (if (cdr-safe (cadr arg))
                           (cadr arg)
                         (list (cadr arg)))
                     (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (if (eq hook-fn 'remove-hook)
                    `(remove-hook ',hook ,fn ,local-p)
                  `(add-hook ',hook ,fn ,append-p ,local-p))
                forms)))
      `(progn ,@(if append-p (nreverse forms) forms)))))

(defmacro remove-hook! (&rest args)
  "Convenience macro for `remove-hook'. Takes the same arguments as `add-hook!'."
  (declare (indent defun) (debug t))
  `(add-hook! :remove ,@args))

(defmacro setq-hook! (hooks &rest rest)
  "Convenience macro for setting buffer-local variables in a hook.

  (setq-hook! 'markdown-mode-hook
    line-spacing 2
    fill-column 80)"
  (declare (indent 1))
  (unless (= 0 (% (length rest) 2))
    (signal 'wrong-number-of-arguments (length rest)))
  `(add-hook! ,hooks
	      ,@(let (forms)
		  (while rest
		    (let ((var (pop rest))
			  (val (pop rest)))
		      (push `(setq-local ,var ,val) forms)))
		  (nreverse forms))))

(defmacro add-transient-hook! (hook-or-function &rest args)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised).

ARGS can be a function, list of functions, or body forms to be wrapped in a lambda.
When it is a function or a list of functions, they will be called with the hooks args."
  (declare (indent 1))
  (let ((append (if (eq (car args) :after) (pop args)))
        ;; NOTE(nox):
        ;; If args is a function or list of functions, funcs will be a list of functions
        ;; If args is a list of forms, funcs will be a list containing only the list of forms
        (funcs (let ((arg (car args)))
                 (if (memq (car-safe arg) '(quote function))
                     (if (cdr-safe (cadr arg))
                         (cadr arg)
                       (list (cadr arg)))
                   (list args))))
        (func-name (gensym "nox|transient-hook-")))
    `(progn
       (fset ',func-name
             (lambda (&rest call-args)
               ,@(cl-loop for fn in funcs
                          collect (if (symbolp fn)
                                      `(apply #',fn call-args)
                                    `(progn ,@args)))
               (cond ((functionp ,hook-or-function) (advice-remove ,hook-or-function #',func-name))
                     ((symbolp ,hook-or-function)   (remove-hook ,hook-or-function #',func-name)))
               (unintern ',func-name nil)))
       (cond ((functionp ,hook-or-function)
              (advice-add ,hook-or-function ,(if append :after :before) #',func-name))
             ((symbolp ,hook-or-function)
              (put ',func-name 'permanent-local-hook t)
              (add-hook ,hook-or-function #',func-name ,append))))))

(defmacro after! (targets &rest body)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation. This will no-op on features that have been disabled by the user."
  (declare (indent defun) (debug t))
  (list (if (or (not (bound-and-true-p byte-compile-current-file))
                (dolist (next (nox-enlist targets))
                  (unless (keywordp next)
                    (if (symbolp next)
                        (require next nil :no-error)
                      (load next :no-message :no-error)))))
            #'progn
          #'with-no-warnings)
        (if (symbolp targets)
            `(with-eval-after-load ',targets ,@body)
          (pcase (car-safe targets)
            ((or :or :any)
             (macroexp-progn
              (cl-loop for next in (cdr targets)
                       collect `(after! ,next ,@body))))
            ((or :and :all)
             (dolist (next (cdr targets))
               (setq body `((after! ,next ,@body))))
             (car body))
            (_ `(after! (:and ,@targets) ,@body))))))
#+end_src

*** TODO Shut things up 
:PROPERTIES:
:CREATED:  [2020-04-23 Thu 21:16]
:ID:       5ed810ca-4028-4f48-93d9-fd086ba8e340
:END:

Credit: https://github.com/weirdNox/dotfiles/blob/master/config/.emacs.d/config.org#shut-things-up
#+begin_src emacs-lisp
(defmacro quiet! (&rest forms)
  "Run FORMS without making any output."
  `(if nox-debug-mode
       (progn ,@forms)
     (let ((old-fn (symbol-function 'write-region)))
       (cl-letf* ((standard-output (lambda (&rest _)))
                  ((symbol-function 'load-file) (lambda (file) (load file nil t)))
                  ((symbol-function 'message) (lambda (&rest _)))
                  ((symbol-function 'write-region)
                   (lambda (start end filename &optional append visit lockname mustbenew)
                     (unless visit (setq visit 'no-message))
                     (funcall old-fn start end filename append visit lockname mustbenew)))
                  (inhibit-message t)
                  (save-silently t))
         ,@forms))))

(defun nox*shut-up (orig-fn &rest args)
  "Generic advisor for silencing noisy functions."
  (quiet! (apply orig-fn args)))
#+end_src

*** Hash table library
:PROPERTIES:
:CREATED:  [2019-08-25 Sun 19:32]
:ID:       c2f4a307-171c-4eee-aef0-e1ee27dd2e47
:END:
:LOGBOOK:
- Refiled on [2020-05-04 Mon 22:44]
:END:

#+begin_src emacs-lisp
(use-package ht
  :straight t)
#+end_src

*** String manipulation library
    :PROPERTIES:
    :ID:       a373281e-87dc-4dc4-8386-a408168e5c4f
    :END:

#+begin_src emacs-lisp
(use-package s
  :straight t)
#+end_src
** Performance
:PROPERTIES:
:CREATED:  [2018-09-12 Wed 19:48]
:ID:       45c70cb5-df2f-4e86-8ccd-42c1881a7dbf
:END:

Elisp is not the fastest language in the world.
There are various options, which can improve the performance.

Bidirectional text is not something I use frequently (never used up until writing this)
#+BEGIN_SRC emacs-lisp
(setq bidi-display-reordering nil)
#+END_SRC

Speed up line movement [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][source]]
#+begin_src emacs-lisp
(setq auto-window-vscroll nil)
#+end_src

Smart garbage collect. 
Though I don't want it in batch mode because it is optimised for interactive use.

[2020-05-29 Fri] [[notmuch:id:note_351562434@gitlab.com][Email from Koral: Re: gcmh | Commands invoking garbage-collect directly can hang emacs when non-idle (#6)]]
Reducing help:gcmh-cons-threshold to avoid hangs on undo.

#+begin_src emacs-lisp
(when init-flag
  (use-package gcmh
    :straight (gcmh :type git :host gitlab :repo "koral/gcmh"
		    :fork (:host gitlab :repo "yantar92/gcmh"))
    :demand t
    :diminish gcmh-mode
    :hook (after-init . gcmh-mode)))
#+end_src

And increase GC threshold on top of that (I found emacs spend >25% of time doing GC when just moving around the buffer). 
In batch mode, increase the threshold to make things faster.
#+begin_src emacs-lisp
(if init-flag
    (setq gc-cons-threshold (* 200 1000 1000))
  (setq gc-cons-threshold (* 1 1000 1000 1000)))
#+end_src

200Mb: [[elisp:(progn (forward-line) (insert (message "%d" (* 1000 (/ gc-elapsed gcs-done)))))]]
47ms

400Mb: [[elisp:(progn (forward-line) (insert (message "%d" (* 1000 (/ gc-elapsed gcs-done)))))]]
68ms

800Mb: [[elisp:(progn (forward-line) (insert (message "%d" (* 1000 (/ gc-elapsed gcs-done)))))]]
228ms

1600Mb: [[elisp:(progn (forward-line) (insert (message "%d" (* 1000 (/ gc-elapsed gcs-done)))))]]
188ms

** Appearance
:PROPERTIES:
:ID:       5b50a90f-4f47-4244-a6ac-e3646464539d
:END:

The configuration here is only for generic appearance of emacs.
The major mode-specific configuration is configured later on per-mode basis.

*** Theme
:PROPERTIES:
:ID:       335a0a70-61ef-4691-bf1f-90351bd7c3bd
:END:

For a while, I have been using various dark themes for emacs.
Later, I found light themes easier for my eyes when it is not dark outside.
Since it is not really a good idea to work in darkness regardless of the colour scheme, I ended up using a light theme I prefer.

#+begin_src emacs-lisp
(use-package flatui-theme
  :if init-flag
  :straight t
  :demand t
  :config
  (load-theme 'flatui t))
;; (use-package elegance
;;   :if init-flag
;;   :demand t
;;   :straight (elegance :host github :repo "rougier/elegant-emacs"))
#+end_src

For the font, I prefer something that works fine with mixed code and text (e.g. org files).
My choice is Source Code Pro.
Setting it up as default everywhere.

[2020-03-10 Tue] <<39a84dde-88d1-46e8-86d0-28fb8f72f30c>>
Chinese symbols are not covered by Source Code Pro. 
The result is different character width for Chinese characters.
Using Sarasa Gothic hc with slightly larger size for Chinese symbols in order to keep the character width same all the time.
Credit: https://www.reddit.com/r/emacs/comments/fgbnfv/is_there_a_fixed_width_font_supporting_multiple/


  #+begin_src emacs-lisp
(when init-flag
  (set-face-attribute 'default nil
		      :height 100
		      :family "Source Code Pro")
  (set-fontset-font "fontset-default" 'chinese-gbk (font-spec :size 12.0 :family "Sarasa Mono hc"))
  (set-fontset-font "fontset-default" 'cyrillic-iso8859-5 (font-spec :size 13 :family "source code pro"))
  (mapc (lambda (char)
	  (set-fontset-font "fontset-default" char (font-spec :size 12.0 :family "Source Code Pro")))
        '(?λ))
  (mapc (lambda (char)
  (set-fontset-font "fontset-default" char (font-spec :size 5.0 :family "Quivira")))
        '(?⏩ ?⛔))
  (mapc (lambda (char)
	  (set-fontset-font "fontset-default" char (font-spec :size 10.0 :family "Quivira")))
        '(?★ ?⌛))

  (mapc (lambda (char)
	  (set-fontset-font "fontset-default" char (font-spec :size 12.0 :family "Symbola")))
        '(?🖂 ?🖳 ?🏠 ?🔗 ?🖹))
  (mapc (lambda (char)
	  (set-fontset-font "fontset-default" char (font-spec :size 8.0 :family "Symbola")))
        '(?🖹 ?⛕))
  )
  #+end_src

The colour of secondary selection in the theme is the same colour with some symbols in my =org-agenda=.
Actually, it is probably not the case anymore, but it is used to be so...
The colour I use is below
#+BEGIN_SRC emacs-lisp
(when init-flag
  (set-face-background 'secondary-selection "#aae59c"))
#+END_SRC

For =all-the-icons= it is important to install the fonts via [[elisp:all-the-icons-install-fonts]]
*************** TODO check if hangs disappear
*************** END
#+begin_src emacs-lisp
(use-package all-the-icons
  :if init-flag
  :straight t
  :demand t)
#+end_src

*** Startup appearance
:PROPERTIES:
:ID:       5450bef9-a57a-4afb-85f3-893dbcb5f4ba
:END:

Startup message probably only makes sense for someone who is not yet familiar enough with emacs.
Disabling

#+begin_src emacs-lisp
(when init-flag
  (setq inhibit-startup-message t))
#+end_src
*** Frame
:PROPERTIES:
:ID:       098ff7ca-d99c-493e-a2be-a2e5eeddab82
:END:

General frame appearance configuration.

First, disable unnecessary graphical elements
No tool bar, no scroll bar, no menu bar.
#+begin_src emacs-lisp
(when init-flag
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1))
#+END_SRC

Because of the [[id:404c54f5-26eb-4ada-8a0f-c27efc714238][color scheme]] I use, the border between windows is not easy to distinguish.
Using =window-divider-mode= to emphasise it more.

#+BEGIN_SRC emacs-lisp
(when init-flag
  (setq window-divider-default-places 'right-only
	window-divider-default-right-width 1)
  (set-face-attribute 'window-divider nil
		      :foreground (face-foreground 'default))
  (window-divider-mode +1))
#+END_SRC

By default, emacs frame height can only be a multiple of line height.
This is a little annoying when emacs frame is in maximised state, but yet have a small gap on the bottom.
Setting resizing to be exact instead.
*************** TODO Not setting it now because of weird bug when capture frame does not render
*************** END

#+begin_src emacs-lisp
(when init-flag
  (setq frame-resize-pixelwise t))
#+end_src
*** Window
:PROPERTIES:
:CREATED:  [2019-12-25 Wed 14:14]
:END:

General settings for window appearance

**** Handling pop-up windows
:PROPERTIES:
:CREATED:  [2019-12-25 Wed 14:15]
:ID:       d74e4baa-4599-4a98-9246-2d03e52d846e
:END:

Pop-up windows in emacs sometimes behave in a strange way.
They may unexpectedly occupy a window with useful buffer or split window in unexpected direction. 
The most bizarre case was when a debug buffer popped-up in a non-active frame once.
The frame was in different WM workspace and I was totally confused about what is going on. 

=shackle= package allows setting rules for pop-up windows.
*************** TODO this is an example when I want mirror text work
*************** END

#+begin_src emacs-lisp
(use-package shackle
  :if init-flag
  :straight t
  :diminish shackle-mode
  :config (shackle-mode +1)
  :custom
  (shackle-rules
   '(
#+END_SRC

Make help, info, and back-trace pop-up in separate frame
*************** TODO back-trace buffer with the config below pops-up a new frame every time a step into execution
*************** END

#+BEGIN_SRC emacs-lisp  
;; ("*Help*" :select t :frame t)
;; (helpful-mode :select t :frame t)
;; ("*info*" :select t :frame t :same t)
("*Select Link*" :align 'below)
("*Async shell command*" :ignore t)
;; ("*Backtrace*" :select t :frame t :same t)
     #+END_SRC

#+BEGIN_SRC emacs-lisp  
)))
#+end_src

**** Centered text in window
:PROPERTIES:
:ID:       af9c7d6c-fd15-4d68-b379-3d439ea94370
:SHOWFROMDATE: 2019-12-10
:END:
:LOGBOOK:
- Refiled on [2019-12-25 Wed 14:15]
:END:
My screen is too wide to read text comfortably.
I am not very comfortable with =auto-fill-mode=, so I prefer to limit the buffer width.

***** COMMENT Centered window mode
      :PROPERTIES:
      :ID:       3b4bfdc3-0a46-469d-a7f6-a470cb90f2ad
      :END:
[2020-08-08 Sat] There is annoying bug when the mode activates in modes I do not want it to be activated (pdf-mode, org-agenda-mode). Specifically, it happens more often when I create a new frame. 

#+begin_src emacs-lisp
(use-package centered-window
  :if init-flag
  :straight (centered-window-mode :host github :repo "anler/centered-window-mode")
  :after boon
  :config
  (diminish 'centered-window-mode (s-concat " "
					    (propertize (all-the-icons-material "tablet")
							'face `((:family "Material Icons"
									 :height 1.4))
							;; 'display '(raise -0.2)
                                                        )))

  (defun cwm-special-buffer-p (buffer)
    "Return 't if BUFF buffer name is special (starts with an *).

The *scratch* buffer although special, is treated as not special
by this function."
    (let ((buffname (string-trim (buffer-name buffer))))
      (and buffname
           (string-prefix-p "*" buffname)
           (not (eq major-mode 'notmuch-show-mode))
           (not (string= "*scratch*" buffname)))))

  (defun pdf-view-mode-p (&rest args)
    "Return non-nil if in pdf-view-mode."
    (eq major-mode 'pdf-view-mode))
  (add-to-list 'cwm-ignore-buffer-predicates 'pdf-view-mode-p)
  (bind-keys :map boon-x-map ("w" . centered-window-mode))
  (centered-window-mode +1))
#+end_src

***** =Olivetti= mode
:PROPERTIES:
:ID:       1633927d-77d5-4f0e-a64e-4090454da22a
:END:

This mode is minor-mode thus it should be less intrusive in comparison with [[id:3b4bfdc3-0a46-469d-a7f6-a470cb90f2ad][Centered window mode]]

#+begin_src emacs-lisp
(use-package olivetti
  :if init-flag
  :straight t
  :demand t
  :after boon
  :hook ((text-mode notmuch-show-mode) . olivetti-mode)
  :init
  (setq-default olivetti-body-width 110)
  (setq olivetti-lighter
	(s-concat " "
		  (propertize (all-the-icons-material "tablet")
	 		      'face `((:family "Material Icons")))))
  (bind-keys :map boon-x-map ("w" . olivetti-mode)))
#+end_src
**** COMMENT Text wrap indicators
     :PROPERTIES:
     :ID:       7b84d543-2d95-4a04-ba1f-a96e47daa853
     :END:

Nicer text wrap/truncation indicators. 
Credit: [[id:155ab4ae-961b-4665-9c31-2e16378a5fff][rougier/elegant-emacs: A very minimal but elegant emacs (I think)]]

This works instead of default fringe indicators and hence I need to disable fringe.  Without fringe there is also a need to put some internal border in frames.  Otherwise, text will be shifted right to the frame edge, which is not nice.

#+begin_src emacs-lisp
;; Fringe provides the same (but not customisable functionality
(fringe-mode '(0 . 0))
(add-to-list 'default-frame-alist '(internal-border-width . 10))
(set-frame-parameter (selected-frame)
                     'internal-border-width 10)
(defface fallback '((t :family "Fira Code Light"
		       :inherit 'face-faded)) "Fallback")
(set-display-table-slot standard-display-table 'truncation
                        (make-glyph-code ?… 'fallback))
(set-display-table-slot standard-display-table 'wrap
                        (make-glyph-code ?↩ 'fallback))
(set-display-table-slot standard-display-table 'selective-display
                        (string-to-vector " …"))
;; Org buffers would use empty table by default
(use-package org
  :init
  (setq org-display-table (make-display-table))
  (set-display-table-slot org-display-table 'truncation
                          (make-glyph-code ?… 'fallback))
  (set-display-table-slot org-display-table 'wrap
                          (make-glyph-code ?↩ 'fallback))
  (set-display-table-slot org-display-table 'selective-display
                          (string-to-vector " …")))
#+end_src
**** Window boundaries
:PROPERTIES:
:ID:       00975142-2491-4f85-bd0b-f1f6c2938e36
:SUMMARY:  Does not work without fringe
:END:
:LOGBOOK:
- Note taken on [2020-08-20 Thu 18:04] \\
  Does not work without fringe
- Refiled on [2019-12-25 Wed 14:15]
:END:
When the buffer text takes less space then a window, it's neat to see the beginning/end of the buffer in emacs.
#+begin_src emacs-lisp
(when init-flag
  (setq-default indicate-buffer-boundaries 'left))
#+end_src
**** Fringes

Match default face background

#+begin_src emacs-lisp
(set-face-attribute 'fringe nil
		    :background (face-background 'default))
#+end_src

*** Buffer

General buffer appearance.

**** Long lines handling
:PROPERTIES:
:ID:       827dc236-fee4-43b8-bfbe-05026d7e3e6d
:CREATED:  [2019-03-20 Wed 12:07]
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:24]
:END:

Long lines do not look good in text buffers and people often turn on line wrapping.
However, long lines are pretty common in special buffers like in =elfeed=, =notmuch=, =agenda=, etc
Setting line wrapping there makes them look ugly.
Moreover, a need to wrap lines in =prog-mode= buffers is a sign that the code is not formatted well.
So, I don't really need line wrapping in most of the major modes.
I am setting line truncation globally and enable line wrapping only for several certain major modes (i.e. =org-mode=).

If the line wrapping is active, I also want the word wrap to be activated automatically and obey the indentation of the beginning of the line.

#+begin_src emacs-lisp
(when init-flag
  (use-package adaptive-wrap
    :straight t
    :demand t
    :bind ("C-x l" . toggle-truncate-lines)
    :config
    (diminish 'adaptive-wrap-prefix-mode)
    (diminish 'visual-line-mode)
    (define-advice toggle-truncate-lines (:after (&optional arg) toggle-adaptive-wrap)
      "Always use `adaptive-wrap-prefix-mode' when truncation of lines is disabled."
      (setq line-move-visual nil)
      (if truncate-lines
	  (adaptive-wrap-prefix-mode -1)
	(adaptive-wrap-prefix-mode +1))))
  
  (setq-default truncate-lines t
		word-wrap t
                line-move-visual nil))
#+end_src
*** Text in buffers
:PROPERTIES:
:ID:       45675819-9551-43da-8e21-4437dde591e5
:END:
**** Coding system
:PROPERTIES:
:ID:       07c3544a-bcbd-4790-815a-25615ca2ca03
:END:
Prefer UTF
  #+begin_src emacs-lisp
(set-language-environment "English")
(prefer-coding-system 'utf-8)
(add-to-list 'file-coding-system-alist '("\\.org" utf-8))
  #+end_src

Ensure UTF fonts

Note that the fonts should be installed in the system first
#+begin_src bash :tangle no
sudo emerge -a noto dejavu quivira symbola
#+end_src

#+begin_src emacs-lisp
(use-package unicode-fonts
  :if init-flag
  :straight t
  :init
  (use-package persistent-soft
    :straight t) ;; Speed-up unicode-fonts startup, as suggested in unicode-fonts.el commentary
  :config
  (unicode-fonts-setup))
#+end_src
**** Line spacing
:PROPERTIES:
:CREATED:  [2019-12-23 Mon 20:02]
:ID:       86eccbaa-8999-4630-9784-07a91b8d14bd
:END:
This looks nicer.
[[http://ergoemacs.org/emacs/emacs_toggle_line_spacing.html][credit: Xah Lee]]
#+begin_src emacs-lisp
(setq-default line-spacing 3)
#+end_src

**** Visual text transformation
:PROPERTIES:
:ID:       ec85fac4-8fad-4adf-a159-2219ace7e7d7
:END:

Show some text in buffer differently

***** Page break shown as lines
:PROPERTIES:
:ID:       6c1e16d6-7f4e-41e5-99a8-13fac4eab2a3
:END:
#+begin_src emacs-lisp
(use-package page-break-lines
  :if init-flag
  :straight t
  :diminish page-break-lines-mode
  :config (global-page-break-lines-mode))
#+end_src

***** NEXT Pretty symbols
:PROPERTIES:
:ID:       315191d1-6edf-4c10-a1fe-0fb70885fbe1
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:26]
- State "HOLD"       from              [2018-03-04 Sun 17:57]
:END:
*************** TODO Split config to =prog-modes=. Add more commentary
*************** END

#+begin_src emacs-lisp
(use-package pretty-symbols
  :if init-flag
  :diminish pretty-symbols-mode
  :straight t
  :after org
  :hook ((pretty-symbols-mode . font-lock-fontify-buffer)
	 ((prog-mode lisp-interaction-mode org-mode) . pretty-symbols-mode))
  :init
  (setq pretty-symbol-categories '(relational logical lambda org-specific nil cpp general))

  (defun yant/str-to-glyph (str)
    "Transform string into glyph, displayed correctly."
    (let ((composition nil))
      (dolist (char (string-to-list str)
		    (nreverse (cdr composition)))
	(push char composition)
	(push '(Br . Bl) composition)
	)))
  :config
  (setq pretty-symbol-patterns  (let ((lisps '(emacs-lisp-mode
					       inferior-lisp-mode
					       inferior-emacs-lisp-mode
					       lisp-mode scheme-mode))
				      (c-like '(c-mode
						c++-mode go-mode java-mode js-mode
						perl-mode cperl-mode ruby-mode
						python-mode inferior-python-mode)))
				  `(
				    ;; Basic symbols, enabled by default
				    (?λ lambda "\\<lambda\\>" (,@lisps python-mode inferior-python-mode))
				    (?ƒ lambda "\\<function\\>" (js-mode))
				    ;; general symbols, which can be applied in most of the modes
				    ;; Relational operators --
				    ;; enable by adding 'relational to `pretty-symbol-categories'
				    (?≠ relational "\\(!=\\)" (,@c-like org-mode) 1)
				    (?≠ relational "\\(/=\\)" (,@lisps) 1)
				    (?≥ relational "\\(>=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≤ relational "\\(<=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≔ relational "[^=]\\(=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≡ relational "\\(==\\)" (,@c-like ,@lisps org-mode) 1)
				    (?↠ cpp ">>" (c++-mode))
				    (?↞ cpp "<<" (c++-mode))
				    (?🠊 cpp " \\(->\\) " (c++-mode org-mode) 1)
                                    ((yant/str-to-glyph "🠊🠊") cpp " \\(->>\\) " (c++-mode org-mode) 1)
				    (?⋮ cpp "::" (c++-mode org-mode))
				    (?⏎ cpp "\\<endl\\>" (c++-mode))
				    (?∞ cpp "\\<INF\\>" (c++-mode))
				    (?⇰ cpp "\\<return\\>" (c++-mode))
				    (?↹ cpp "\\(\\\\t\\) " (,@c-like ,@lisps org-mode))
				    ;; Logical operators
				    (?∧ logical "&&" (,@c-like org-mode))
				    (?∨ logical "||" (,@c-like org-mode))
                                    (?… nil "\\.\\.\\." (org-mode))
                                    (?— nil " \\(-\\) " (org-mode) 1)
                                    ((yant/str-to-glyph "——") nil " \\(--\\) " (org-mode) 1)
				    (?¬ logical "(\\<\\(not\\)\\>" (,@lisps) 1)
				    (?∅ nil "\\<nil\\>" (,@lisps))
				    ))))
#+end_src

***** Latex pretty symbols
:PROPERTIES:
:ID:       bdf24c4b-681c-4286-86cd-e81f63b94ec0
:END:
*************** TODO Move to latex
*************** END

#+begin_src emacs-lisp
(use-package latex-pretty-symbols
  :if init-flag
  :straight t
  :config
  (global-prettify-symbols-mode t))
#+end_src

**** Selection
:PROPERTIES:
:CREATED:  [2020-04-20 Mon 01:47]
:ID:       15d30e4a-1e47-4dd9-b7fc-6a90b123dccc
:END:

#+begin_src emacs-lisp
(when init-flag
  (custom-set-faces '(secondary-selection ((t (:background "DarkSeaGreen3"))))))
#+end_src

**** Highlight todo keywords in code
:PROPERTIES:
:ID:       bf58379d-d87e-4282-8fee-a36135565b5c
:END:

#+begin_src emacs-lisp
(use-package hl-todo
  :if init-flag
  :straight t
  :hook (emacs-lisp-mode . hl-todo-mode)
  :config
  (setq hl-todo-keyword-faces
	'(("TODO"   . "#FF0000")
          ("FIXME"  . "#FF0000")
          ("DEBUG"  . "#A020F0")
          ("GOTCHA" . "#FF4500")
          ("STUB"   . "#1E90FF"))))
#+end_src

**** No ugly button for checkboxes
:PROPERTIES:
:ID:       36ef77bf-1a8e-45c5-a306-10f02ebaf671
:END:
Credit: [[id:155ab4ae-961b-4665-9c31-2e16378a5fff][rougier/elegant-emacs: A very minimal but elegant emacs (I think)]]

#+begin_src emacs-lisp
(when init-flag
  (setq widget-image-enable nil))
#+end_src

**** Underline at descent position
:PROPERTIES:
:ID:       506912a1-1daf-4506-8e5a-87f90214b42c
:END:
Credit: [[id:155ab4ae-961b-4665-9c31-2e16378a5fff][rougier/elegant-emacs: A very minimal but elegant emacs (I think)]]
Surprisingly, it looks quite nice

#+begin_src emacs-lisp
(when init-flag
  (setq x-underline-at-descent-line t))
#+end_src

*** TODO COMMENT Mode line
:PROPERTIES:
:ID:       ca75c464-f35c-43ed-a90e-d78d4cfaa99a
:END:
:LOGBOOK:
- State "TODO"       from              [2018-09-05 Wed 08:57]
:END:
- =Powerline= + =smart-mode-line=
  - triangular arrow shape
  - set the foreground manually because =boon-powerline= default background is not good with [[id:404c54f5-26eb-4ada-8a0f-c27efc714238][Flatui]] 
    #+begin_src emacs-lisp
(use-package powerline
  :if init-flag
  :straight t
  :config
  ;; (powerline-vim-theme)
  (use-package smart-mode-line
    :straight t
    :config
    (setq powerline-arrow-shape 'arrow14)
    (sml/setup))
  (use-package spaceline
    :if init-flag
    :demand t
    :straight t
    :config
    (setq powerline-default-separator 'arrow-fade
          spaceline-minor-modes-separator " ")
    (require 'spaceline-config)
    ;; (spaceline-emacs-theme)
    ))

(use-package spaceline-all-the-icons
  :demand t
  :custom
  (spaceline-all-the-icons-slim-render t)
  (spaceline-all-the-icons-hide-long-buffer-path t)
  (spaceline-all-the-icons-minor-modes-p t))
  #+end_src
- Show column numbers
  #+begin_src emacs-lisp
    (when init-flag
      (setq column-number-mode t))
        #+end_src
- Show total lines
  #+begin_src emacs-lisp
    (when init-flag
      (setf size-indication-mode t))
      #+end_src

By default, the position in buffer =mode-line-position= is shown in %. However, I only need this in pdf-view, where I want to see the page number. Since the pdf-view changes this value anyway, I just let the buffer position be blank most of time, unless something (pdf-view) changes it to more useful value.
*************** TODO move it close to the definition
*************** END

Show boon state
  #+begin_src emacs-lisp
    (use-package boon
      :if init-flag
      :defer t
      :config
      (use-package boon-powerline
	:config
	(custom-set-faces '(mode-line-inactive ((t (:background "#dfe4ea" :foreground "dim gray" :box nil)))))
	(custom-set-faces '(mode-line ((t (:foreground "DarkSeaGreen" :box nil)))))
	(custom-set-faces '(sml/prefix ((t (:foreground "DarkSeaGreen")))))
	(custom-set-faces '(boon-modeline-ins ((t (:foreground "White" :background "Brown2")))))
	(custom-set-faces '(boon-modeline-spc ((t (:foreground "White" :background "DarkSeaGreen")))))
    
	(set-face-foreground 'boon-modeline-cmd "white")
	(set-face-foreground 'boon-modeline-off "white")

	(set-face-background 'powerline-inactive2 "#dfe4ea")
	(set-face-background 'powerline-inactive1 "#bfc4ca")
	(set-face-background 'powerline-active2 "grey25")


	(defface mode-line-highlight `((t (:foreground ,(face-background 'region) :box nil :inherit mode-line)))
	  "Highligh on active modeline."
	  :group 'mode-line)
	(face-spec-set 'mode-line-highlight `((t (:foreground ,(face-background 'region) :box nil :inherit mode-line)))) ;; why is it needed?

	;; (use-package all-the-icons
	;;   :init
	;;   (use-package memoize :straight t :demand t)
	;;   :config
	;;   ;; the functions below constantly create long lists in memory
	;;   ;; this triggers GC too often and hangs emacs when I use custom all-the-icons in mode-line
	;;   ;; memoize them to cache the results
	;;   (memoize #'all-the-icons-material)
	;;   (memoize #'all-the-icons-faicon)
	;;   (memoize #'all-the-icons-fileicon)
	;;   (memoize #'all-the-icons-alltheicon))
    
	(defun yant-powerline-theme ()
	  "Set up a powerline based on powerline-default-theme and spaceline-all-the-icons-theme which also displays boon-state."
	  (interactive)
	  (require 'spaceline-all-the-icons-segments)
	  (setq-default mode-line-position " ")
	  (setq-default mode-line-format
			'("%e"
			  (:eval
			   (let* ((active (powerline-selected-window-active))
				  (mode-line (if active 'mode-line 'mode-line-inactive))
				  (mode-line-highlight (if active 'mode-line-highlight 'mode-line-inactive))
				  (face0 (if active (boon-state-face) 'mode-line-inactive))
				  (face1 (if active 'powerline-active1 'powerline-inactive1))
				  (face2 (if active 'powerline-active2 'powerline-inactive2))
				  (separator-left (intern (format "powerline-%s-%s"
								  powerline-default-separator
								  (car powerline-default-separator-dir))))
				  (separator-right (intern (format "powerline-%s-%s"
								   powerline-default-separator
								   (cdr powerline-default-separator-dir))))
				  (boon (list
					 (powerline-raw (when current-input-method-title (s-concat " " (s-trim-right current-input-method-title))) face0)
					 (powerline-raw (eval (get 'spaceline-all-the-icons-modified-p :code)) face0 'l)
					 (powerline-raw (eval (get 'spaceline-all-the-icons-buffer-size-p :code)) face0 'l)
					 (powerline-raw " " face0)
					 (funcall 'powerline-bar-right mode-line face0)
					 (when (bound-and-true-p boon-mode) (powerline-raw " " face0))
					 (when (bound-and-true-p boon-mode) (powerline-raw (boon-state-string) face0 'r))
					 (when (bound-and-true-p boon-mode) (funcall separator-left face0 mode-line))
					 ))
				  (lhs (list
					(powerline-raw (eval (get 'spaceline-all-the-icons-mode-icon-p :code)) mode-line 'l)
					(powerline-buffer-id mode-line nil)
					(when (and (boundp 'which-func-mode) which-func-mode)
					  (powerline-raw which-func-format mode-line 'l))
					(when (eval (get 'spaceline-all-the-icons-narrowed-p :when))
					  (powerline-raw (eval (get 'spaceline-all-the-icons-narrowed-p :code))
							 mode-line-highlight 'l))
					(powerline-raw (if truncate-lines
							   (propertize (all-the-icons-faicon "arrow-right")
								       'face `((
										:family "file-icons"
										:height 0.6))
								       'display '(raise 0.3))
							 (propertize (all-the-icons-fileicon "factor")
								     'face `((
									     :family "Material Icons"
									     :height 0.6))
								     'display '(raise 0.3)))
						       mode-line-highlight 'l)
					(funcall separator-left mode-line face1)
					(powerline-process face1)
					(when active (powerline-minor-modes face1 'l))
					(powerline-raw " " face1)
					(funcall separator-left face1 face2)
					(powerline-vc face2 'r)
					))
				  (rhs (list
					(powerline-raw global-mode-string face2 'r)
					(funcall separator-right face2 face1)
					(powerline-raw "%l" face1 'l)
					(powerline-raw ":" face1)
					(powerline-raw "%c" face1 'r)
					(funcall separator-right face1 mode-line)
					(powerline-raw " " mode-line)
					(powerline-raw "%p" mode-line)
					(powerline-raw mode-line-position mode-line)
					(powerline-raw " " mode-line)
					)))
			     (concat (powerline-render boon)
				     (powerline-render lhs)
				     (powerline-fill face2 (powerline-width rhs))
				     (powerline-render rhs)))))))
    
	(setq flymake--mode-line-format '(:eval (when flymake-mode (flymake--mode-line-format))))
	(use-package all-the-icons
	  :init
	  (add-to-list 'all-the-icons-mode-icon-alist '(helpful-mode all-the-icons-faicon "info" :v-adjust -0.1 :face all-the-icons-purple))
	  (add-to-list 'all-the-icons-mode-icon-alist '(pdf-view-mode all-the-icons-octicon "file-pdf" :v-adjust 0.0 :face all-the-icons-dred)))
	(yant-powerline-theme)
	(use-package helm
	  :defer t
	  :config
	  (spaceline-helm-mode +1))
	))
#+end_src

Fancy minor mode lighters

#+begin_src emacs-lisp
(use-package simple
  :config
  (diminish 'auto-fill-function (s-concat " "
					  (propertize (all-the-icons-material "wrap_text")
						      'face `((
							       :family "Material Icons"
							       ;; :height 1.2
							       ))))))
(use-package mml
  :diminish (mml-mode . " 🖂"))
(use-package footnote
  :diminish (footnote-mode . " ¹⁻⁹"))
#+end_src

*** Header line
:PROPERTIES:
:CREATED:  [2020-04-23 Thu 20:43]
:ID:       e0d58345-6e68-4672-a9d7-37ff73717cf3
:END:

Light face for header line.

#+begin_src emacs-lisp
(use-package faces
  :if init-flag
  :after boon
  :init
  (use-package color :demand t)
  :config
  (defface header-line-text '((t :inherit header-line))
    ""  )
  (set-face-attribute 'header-line nil
		      :weight 'normal
		      ;; :box ,(face-background 'boon-modeline-spc)
		      ;; :box `(:color ,(color-darken-name (face-background 'default) 10) :line-width 5)
                      :box `(:color ,(face-background 'default) :line-width 5)
		      ;; :box nil
		      :foreground (color-darken-name (face-foreground 'mode-line) 20)
		      :underline (face-foreground 'default)
		      ;; :background ,(face-background 'default)
		      :background (face-background 'default)
		      )
  (set-face-attribute 'mode-line nil
		      :box nil
                      :underline  (face-foreground 'default)
		      :background (face-background 'default)
                      )
  (set-face-attribute 'mode-line-inactive nil
		      :box nil
                      :underline  (face-foreground 'default)
		      :background (face-background 'default)
                      ))
#+end_src

Use header line from [[id:155ab4ae-961b-4665-9c31-2e16378a5fff][rougier/elegant-emacs: A very minimal but elegant emacs (I think)]]
However, tweak it to follow actual text margins when [[id:1633927d-77d5-4f0e-a64e-4090454da22a][Olivetti mode]] is turned on.
#+begin_src emacs-lisp
(when init-flag
  ;; Mode line (this might be slow because of the "☰" that requires substitution)
  ;; This line below makes things a bit faster
  (set-fontset-font "fontset-default"  '(#x2600 . #x26ff) "Fira Code 12")

  (define-key mode-line-major-mode-keymap [header-line]
    (lookup-key mode-line-major-mode-keymap [mode-line]))


  (defun mode-line-render (left right)
    (let* ((right-width (length right))
	   (left-width (length left)))
      (let ((str
	     (concat
	      (make-string (let ((span (/ (- (window-total-width) (window-width)) 2)))
			     (if (> span 0)
				 span
			       0))
			   ?\ )
	      left
	      (make-string (let ((span (- (window-width) right-width left-width)))
			     (if (> span 0)
				 span
			       0))
			   ?\ )
	      right
	      (make-string (let ((span (/ (- (window-total-width) (window-width)) 2)))
			     (if (> span 0)
				 span
			       0))
			   ?\ ))))
	(if (<= (length str) (window-total-width))
	    str
	  (s-truncate (window-total-width)
		      (concat
		       (make-string (let ((span (/ (- (window-total-width) (window-width)) 2)))
				      (if (> span 0)
					  span
					0))
				    ?\ )
		       left
		       (make-string (let ((span (- (window-width) left-width)))
				      (if (> span 0)
					  span
					0))
				    ?\ )
		       (make-string (let ((span (/ (- (window-total-width) (window-width)) 2)))
				      (if (> span 0)
					  span
					0))
				    ?\ )))))))
  (setq-default header-line-format
		'((:eval
		   (mode-line-render
		    (concat (format-mode-line (all-the-icons-icon-for-mode major-mode :v-adjust 0.04 :height 0.8 :face `((:foreground ,(face-foreground 'default)))))
			    ;; (format-mode-line (list
			    ;; 		       (propertize "☰" 'face `(:inherit header-line)
			    ;; 				   'help-echo "Mode(s) menu"
			    ;; 				   'mouse-face 'mode-line-highlight
			    ;; 				   'local-map   mode-line-major-mode-keymap)))
			    (when (buffer-narrowed-p) (concat " " (propertize (all-the-icons-faicon "filter" :v-adjust 0.04)
									      'face `((
										       :family "file-icons"
										       :foreground ,(face-background 'region))))))
			    (case major-mode
			      ('org-agenda-mode (format-mode-line (list " " mode-name " ")))
			      (t
			       (or
				(and org-src-mode
				     (format " %s "
					     
					     (substitute-command-keys
					      (if org-src--allow-write-back
						  "Edit, then exit with `\\[org-edit-src-exit]' or abort with \
  `\\[org-edit-src-abort]'"
						"Exit with `\\[org-edit-src-exit]' or abort with \
  `\\[org-edit-src-abort]'"))))
				(format-mode-line (list " %b "
							(if (and buffer-file-name (buffer-modified-p))
							    (propertize "(modified)" 'face `(:inherit header-line))))))))
			    (if truncate-lines
				(propertize (all-the-icons-faicon "arrow-right" :v-adjust 0.04)
					    'face `((
						     :family "file-icons"
						     :foreground ,(face-background 'region)
						     :height 0.6)))
			      (propertize (all-the-icons-fileicon "factor" :v-adjust 0.04)
					  'face `((
						   :family "Material Icons"
						   :foreground ,(face-background 'region)
						   :height 0.6)))))
		    (concat
                     (propertize (all-the-icons-faicon "angle-left" :v-adjust 0.00)
				 'face `((
					  :family "FontAwesome"
                                          :height 1.5
					  )))
		     (format-mode-line minor-mode-alist)
		     " "
                     (propertize (all-the-icons-faicon "angle-right" :v-adjust 0.00)
				 'face `((
					  :family "FontAwesome"
                                          :height 1.5
					  )))
		     "    "
		     ;; (format-mode-line
		     ;;  "%4l:%2c  ")
		     )))))

  (defun yant/force-header-line-format ()
    "Set `header-line-format' to its default value."
    (setq header-line-format
	  (default-value 'header-line-format)))
  (add-hook! (org-src-mode org-capture-mode) #'yant/force-header-line-format)

  ;; Comment if you want to keep the modeline at the bottom
  (setq-default mode-line-format '("")))

#+end_src

*** Mini-buffer
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:29]
:END:
**** =Eldoc= show various info in mini-buffer
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:29]
:ID:       461cf4e2-bcb0-4166-bdf0-fe437d352417
:END:

#+begin_src emacs-lisp
(when init-flag
  (global-eldoc-mode)
  (diminish 'eldoc-mode))
#+end_src

Since I wrap the default movement commands into custom functions (see [[id:0fe0bca3-fb51-4e0c-8b35-79a5e92975d6][Modal setup]]), I need to make these custom commands trigger =eldoc= information update.

#+begin_src emacs-lisp
(when init-flag
  (mapc #'eldoc-add-command '(meta-up meta-up-element meta-down meta-down-element meta-backward meta-backward-element meta-forward meta-forward-element meta-scroll-down meta-scroll-up self-insert-command)))
#+end_src
**** Stack messages in mini-buffer when they appear quickly after each other
:PROPERTIES:
:CREATED:  [2019-12-22 Sun 14:26]
:ID:       2a660565-143a-4431-946b-404498bd3996
:END:
:LOGBOOK:
- Refiled on [2019-12-23 Mon 11:43]
:END:
Credit: [[notmuch:id:87sgldfi9j.fsf@mail.linkov.net][Email from Juri Linkov: Re: Intelligent stacking of messages in the echo area]]

One problem with this is that resizing the echo area forces emacs to redraw, which 
makes some functions laggy.

*************** TODO this somehow interferes with eldoc in elisp
*************** END

#+begin_src emacs-lisp
  (defcustom multi-message-timeout 0.5
    "Number of seconds between messages before clearing the accumulated list."
    :type 'number
    :group 'minibuffer
    :version "28.1")

  (defcustom multi-message-max 3
    "Max size of the list of accumulated messages."
    :type 'number
    :group 'minibuffer
    :version "28.1")

  (defun multi-message--ellipsis-p (message)
    "Return non nil when MESSAGE ends with ellipsis."
    (string-match-p "\\.\\.\\.\\'" message))

  (defun multi-message--keystroke-regex-p (message)
    "Return non nil when MESSAGE looks like a keystroke echo."
    (string-match-p "^[A-Za-z]\\(-[A-Za-z]\\)*-?$" message))

  (defun multi-message--keystroke-echo-p (message)
    "Return non nil when MESSAGE is a currently entered keystroke."
    (string-match-p (key-description (this-command-keys-vector)) message))


  (defcustom multi-message-transient-functions '(multi-message--ellipsis-p multi-message--keystroke-echo-p multi-message--keystroke-regex-p)
    "List of functions to filter out transient messages that should not be stacked.
  Each function is called in sequence with message string as an only argument.
  If any of the functions returns non nil, the message is filtered out."
    :type 'list
    :group 'minibuffer
    :version "28.1")

  (defvar multi-message-separator "\n")

  (defvar multi-message-list nil)

  (defun set-multi-message (message)
    "Return recent messages as one string to display in the echo area.
  Note that this feature works best only when `resize-mini-windows'
  is at its default value `grow-only'."
    (let ((last-message (car multi-message-list)))
      (unless (and last-message (equal message (aref last-message 1)))
	(when last-message
	  (cond
	   ((> (float-time) (+ (aref last-message 0) multi-message-timeout))
	    (setq multi-message-list nil))
	   ((or
	     ;; `message-log-max' was nil, potential clutter.
	     (aref last-message 2)
	     (run-hook-with-args-until-success 'multi-message-transient-functions (aref last-message 1)))
	    (setq multi-message-list (cdr multi-message-list)))))
	(push (vector (float-time) message (not message-log-max)) multi-message-list)
	(when (> (length multi-message-list) multi-message-max)
	  (setf (nthcdr multi-message-max multi-message-list) nil)))
      (mapconcat (lambda (m) (aref m 1))
		 (reverse multi-message-list)
		 multi-message-separator)
      ;; (let ((message-display (mapconcat (lambda (m) (aref m 1))
      ;; 				      (reverse multi-message-list)
      ;; 				      multi-message-separator))
      ;;       (n-lines (s-count-matches "\n" message-display)))
      ;;   (if (and last-message
      ;; 	       (equal this-command (aref 3 last-message))
      ;;            (< n-lines multi-message-max))
      ;;       (s-concat message-display (s-repeat (- multi-message-max n-lines) "\n"))
      ;;     message-display))
      )
    )

  (setq set-message-function 'set-multi-message)
#+end_src

*** Cursor
:PROPERTIES:
:ID:       3dbc3bed-206e-4132-b8e1-0d1ed338f990
:END:

**** Highlight current line
:PROPERTIES:
:ID:       eb188515-3363-4f8c-afe4-0110a5cdc185
:END:

#+begin_src emacs-lisp
(when init-flag
  (global-hl-line-mode t))
#+end_src

**** Change default cursor colour (just my taste)
:PROPERTIES:
:ID:       272e4188-f79d-4597-b4b8-2ce652b349f3
:END:

#+BEGIN_SRC emacs-lisp
(when init-flag
  (set-cursor-color "IndianRed"))
#+END_SRC

**** Do not blink
:PROPERTIES:
:ID:       47b6a282-1ab2-4137-a4eb-db62f8a376fd
:END:

Blinking does not matter much for me and no blinking is one less timer and hence one more tiny bit of slowing Emacs.

#+begin_src emacs-lisp
(when init-flag
  (blink-cursor-mode 0))
#+end_src

**** COMMENT Highlight cursor when it moves far
:PROPERTIES:
:ID:       c86d4d84-aa19-43e8-990a-6305db525433
:ARCHIVE_TIME: 2019-12-09 Mon 13:06
:ARCHIVE_FILE: ~/Git/emacs-config/config.org
:ARCHIVE_OLPATH: Emacs configuration/Appearance/Cursor
:ARCHIVE_CATEGORY: config
:ARCHIVE_ITAGS: EMACS COMMON
:END:

[2020-08-10 Mon] Slows down Emacs after some time

#+begin_src emacs-lisp
(use-package beacon
  :if init-flag
  :straight t
  :diminish beacon-mode
  :config
  (beacon-mode 1))
#+end_src

** Command loop
:PROPERTIES:
:ID:       ff7a4c41-d457-4a90-bcb9-4f653af48ff4
:END:

This section contains customisation relevant to actions associated with running various commands.

*** Dialogues
:PROPERTIES:
:ID:       b1e1c83a-18be-4c5c-bd77-970a0a163b72
:END:
- do not use graphical dialogues

  #+begin_src emacs-lisp
(setq use-dialog-box nil)
  #+end_src

*** Tooltips
:PROPERTIES:
:ID:       2b71a4fe-82e8-4ec6-9164-ad6958c6767f
:END:
Disable tooltips
#+begin_src emacs-lisp
(tooltip-mode -1)
#+end_src

*** Key bindings
At some point, a got very annoyed about distance between =C-n=, =C-p=, =C-f=, and =C-b= and did not want to move my hand all the way to arrow keys.
So, I use modal editing  now, which allows me to move around using the keys, which are close to each other.

**** Modal setup
:PROPERTIES:
:ID:       0fe0bca3-fb51-4e0c-8b35-79a5e92975d6
:END:

Do not use =self-insert-command= by default, but bind character keys to navigation, selection, etc.
I use [[https://github.com/jyp/boon][boon]] package for this purpose.

It is bad idea to enable boon insert mode in special buffers, so it has =special mode= with limited redefined key binding by default.
This mode replaces normal =insert mode=.
I add extra functionality for the case when =special mode= or =command mode= should not be enabled by default --- the buffer requires a lot of writing (I mean shell buffers, for example).
This is defined by =boon-insert-state-major-mode-list= where the default mode is =insert mode=.

=boon-special-mode= is frequently useful in all kinds of major modes, like debug, org-agenda, =notmuch=, etc.
However, many major modes use the conventional movement key bindings or their derivatives (like "n" and "p" in =org-agenda=).
I do not like it.
I prefer to have some minimal set of movement keys working in all the buffers (see below).
It means that I need to redefine the movement commands to be able to act according to the major mode (like "n" from org-mode is bound to =org-next-line= and, hence, "j" from =org-special-map= should be also bound to =org-next-line=.
This can be done by defining special wrapper command, which acts differently depending on the mode or buffer position, while the general result or running the command is similar (i.e. move next line in text buffer, but move next file in =dired=, or next agenda item in =org-agenda=.

First, unify all the movement commands.
In boon, it can be done by forcing global move commands in special state.
#+BEGIN_SRC emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (set-keymap-parent boon-special-map boon-moves-map))
#+END_SRC

*************** TODO respect interactive definitions
*************** END

*************** TODO Provide a way to prepend condition
*************** END 
*************** TODO check when trying to bind non-existing function? maybe link to function symbol instead
*************** END

*************** TODO make sure that defining default function after conditional does not mess up anything
*************** END


Second, implement the wrapper command <<meta-functions>>.

#+begin_src emacs-lisp :tangle ~/Git/meta-functions/meta-functions.el
  ;;; meta-functions.el --- Define meta-functions to act differently depending on major mode -*- lexical-binding: t; -*-

;; Version: 2.0
;; Author: Ihor Radchenko <yantar92@gmail.com>
;; Created: 10 March 2018

  ;;; Commentary:

;; Quick implementation of meta-functions, which allows to run multiple
;; functions, which do similar logical operations by one single "meta"
;; function in different major modes. For example, one may want to define
;; meta-next-line to call `next-line' normally, but
;; `org-agenda-next-line' in org-agenda mode. Both can be binded to, say
;; "M-j", without a need to change the key-bindings on both fundamental
;; and org-agenda modes.
;; Example usage:
;; (use-package meta-functions
;;   :config
;; (meta-defun meta-next-element ()
;;   "Go to next element."
;;   :mode org-agenda-mode (org-agenda-next-item 1) ; call org-agenda-next-item in org-agenda
;;   :cond (lambda () (and (eq major-mode 'org-mode) (org-at-heading-p))) (org-next-visible-heading 1) ; call org-next-visible-headting when at heading in org-mode
;;   (next-line)) ; call-next line in any other case
;; )
;; or the same can be written as
;; (meta-defun meta-next-element "Go to next element." next-line)
;; (meta-defun meta-next-element :mode org-agenda-mode (org-agenda-next-item 1))
;; (meta-defun meta-next-element :mode org-mode :cond org-at-heading-p (org-next-visible-heading 1))
;;
;; Similar packages:
;; https://gitlab.com/jjzmajic/handle implements similar functionality to unify functions across major modes
;; However, handle is very major-mode centric. meta-functions is more function-centric
;; Also, meta-functions is not only limited to current major mode defining which function to call.

  ;;; Code:
(require 'seq)
(require 'dash)
(require 'org-id)


(defun meta-functions--process-args-1 (args &optional recursive)
  "Return list of ((sub-body-symbol condition-func|mode-symbol number-elements-in-args) ...) in front of ARGS."
  (pcase args
    (`(:mode ,(and (pred symbolp) s) . ,_)
     (cons
      (list (make-symbol (concat "%" (symbol-name s)))
	    `(quote ,s)
	    2)
      (meta-functions--process-args-1 (cddr args) 'recursive)))
    (`(:cond :symbol ,(and (pred symbolp) s) ,(and (pred #'functionp) func) . ,_)
     (cons
      (list (make-symbol (concat "%" (symbol-name s)))
	    `(function ,func)
	    4)
      (meta-functions--process-args-1 (cddddr args) 'recursive)))
    (`(:cond :symbol . ,_)
     (error ":cond :symbol must be followed by symbol and function."))
    (`(:cond ,(and (pred functionp) func) . ,_)
     (cons
      (list (when (symbolp func) (make-symbol (concat "%" (symbol-name func))))
	    `(function ,func)
	    2)
      (meta-functions--process-args-1 (cddr args) 'recursive)))
    (`(:cond ,form . ,_)
     (cons
      (list (make-symbol (concat "%lambda" (org-id-uuid)))
	    `(function (lambda () ,form))
	    2)
      (meta-functions--process-args-1 (cddr args) 'recursive)))
    (_
     (unless recursive
       (list (list
	      '%t
	      `(function t)
	      0))))))

(defun meta-functions--process-args (name args)
  "Process arguments of `meta-defun'.
  The return value is a list (arglist docstring ((sub-body-symbol condition-func|mode-symbol body) ...))."
  (when (memq ':override-nil args) (setq args (delq ':override-nil args)))
  (let* ((arglist (and (listp (car args)) (pop args)))
	 (docstring (and (stringp (car args)) (pop args)))
	 conditions)
    (while args
      (add-to-list 'conditions
		   (cl-loop for (symbol subcondition num-remove) in (meta-functions--process-args-1 args)
			    with condition = nil
			    with sumsymbol = nil
			    do (when symbol
				 (if sumsymbol
				     (setq sumsymbol
					   (make-symbol (concat (symbol-name sumsymbol)
								"+"
								(symbol-name symbol))))
				   (setq sumsymbol
					 (make-symbol (concat (symbol-name name)
							      (symbol-name symbol))))))
			    do (dotimes (_ num-remove) (pop args))
			    do (push subcondition condition)
			    finally return (cons sumsymbol
						 (nreverse (push (pcase (cl-loop for el = (pop args)
										 collect el
										 until (or (seq-empty-p args) (meta-functions--process-args-1 args 'recursive)))
								   (`(,(and (pred functionp) func)) `(function ,func))
								   (`(,form) `(lambda () (interactive) ,form)))
								 condition))))
		   'append))
    (list arglist docstring conditions)))


(defun meta-functions--generate-docstring (name default-docstring conditions)
  "Generate a docstring for a function define using meta-defun."
  (->>
   (concat "[Meta function.]\n"
	   (when default-docstring default-docstring)
	   "\n"
	   "By default, run `"
	   (format "%s" (cadr (alist-get (make-symbol (concat (symbol-name name) "%t")) conditions nil nil (lambda (a b) (string= (symbol-name a) (symbol-name b))))))
	   "'\n"
	   (mapconcat (lambda (condition)
			(let* ((rcondition (seq-reverse (cdr condition)))
			       (body (car rcondition))
			       (subconditions (seq-reverse (cdr rcondition))))
			  (unless (equal subconditions '(#'t))
			    (concat "When "
				    (mapconcat (lambda (el)
						 (pcase el
						   ('#'t nil)
						   (`(function ,_)
						    (concat "`" (format "%s" el) "' returns 't"))
						   (_
						    (concat "major mode is `" (format "%s" (eval el)) "'"))))
					       subconditions
					       " and ")
				    ", run `"
				    (format "%s" body)
				    "'"))))
		      conditions
		      "\n"))
   (replace-regexp-in-string "#'" "")))

(cl-defmacro meta-defun (name &rest args)
  "Define a meta-function or update its definition.

  USAGE:
  (meta-defun foo [(arglist)]
  [:override-nil]
  [docstring]
  [:mode bar-mode body-sexp]
  [:mode ...]
  [:cond [:symbol zen-func-symbol] zen-func body-sexp]
  [:cond ...]
  [default-body])

  If a command foo has not yet been defined using meta-defun, the above
  defines a command foo, which can call different BODY (which can be a
  function or sexp) depending on major mode or :cond functions. For any
  major mode, the BODY defined in the corresponding [:mode mode body]
  definition is called. If none of the define mode conditions are
  satisfied, the FUNCs in [:cond func body] are called sequentially
  without argument until one of the return 't. Then, the corresponding
  BODY is called. If none of the above conditions can be met,
  DEFAULT-BODY is called.

  If a command foo has been already defined with meta-defun, the
  existing definition will be updated. All the omitted definitions will
  be preserved (including docstring and default-body) unless
  :override-nil keyword is provided. If :override-nil keyword is
  present, the command foo will be redefined.

  In addition, every BODY definition in :mode definition is bound to foo%bar-mode symbol.
  This symbol can be used in the following [:mode ...] and [:cond ...] definitions.
  In the [:cond ...] definition, it [:symbol zen-fun-symbol] is present, the BODY
  is bound to foo%zen-fun-symbol.
  Otherwise, it is bound to foo%zen-fun is zen a symbol.

  \(fn NAME [(ARGLIST)] [DOCSTRING] ARGS...)"
  (declare (indent defun))
  `(pcase-let ((`(,arglist ,default-docstring ,conditions) (meta-functions--process-args ',name ',args))
	       (old-conditions (function-get ',name 'meta-functions-cond-plist))
	       (old-default-docstring (function-get ',name 'meta-functions-default-docstring)))
     (unless (memq :override-nil ',args)
       (mapc (lambda (el)
	       (setf (alist-get (car el) old-conditions nil nil (lambda (a b) (string= (symbol-name a) (symbol-name b)))) (cdr el)))
	     (reverse conditions))
       (setq conditions old-conditions)
       (unless default-docstring (setq default-docstring old-default-docstring)))
     (mapc (lambda (el)
	     (let ((main-name  ',name)
		   (sub-name (car el))
		   (body (car (reverse el))))
	       (when sub-name
		 (eval `(defun ,sub-name ()
			  (concat "Sub-definition in meta-function `" (symbol-name ',main-name) "'.")
			  ,body)))))
	   conditions) ; define the sub-bodies
     (let ((docstring (meta-functions--generate-docstring ',name default-docstring conditions)))
       (eval `(defun ,',name ,arglist
		,docstring
		(interactive)
		(seq-some (lambda (condition)
			    (let* ((rcondition (seq-reverse (cdr condition)))
				   (body (car rcondition))
				   (subconditions (seq-reverse (cdr rcondition))))
			      (when (seq-reduce (lambda (prev el)
						  (and prev
						       (pcase el
							 ('#'t t)
							 (`(function ,_) (eval `(funcall-interactively ,el)))
							 (_ (eq major-mode (eval el))))))
						subconditions
						t)
				(eval `(call-interactively ,body))
				t)))
			  ',conditions)))) ; define meta-function
     (function-put ',name 'meta-functions-cond-plist conditions)
     (function-put ',name 'meta-functions-default-docstring default-docstring)))

(defun meta-defun-mapc (list)
  "Defun multiple meta-functions with `meta-defun' trating each element of LIST as argument."
  (mapc (lambda (body) (eval `(meta-defun ,@body))) list))

(provide 'meta-functions)

  ;;; meta-functions.el ends here
#+end_src

And use the wrapper command in interactive mode.

#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :demand t)
#+END_SRC


Define the most basic movement commands:
 - occur :: interactive search in buffer

*************** TODO Move the editing meta-commands to editing section
*************** END

 - goto :: interactive go to a place in buffer

 - down/up :: move down/up the line

 - down-element/up-element :: move down/up to the next multi-line buffer element

 - forward/backward :: move forward/backward by smallest possible element in the buffer

 - forward-element/backward-element :: move forward/backward by second smallest element in the buffer

 - forward-sexp/backward-sexp :: move forward/backward by an element, which typically takes less then a single line

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (use-package helm-occur
    :defer t
    :config
    (meta-defun meta-occur "Occur." helm-occur))
  (use-package boon
    :defer t
    :config
    (meta-defun meta-new-line "Insert new line." boon-newline-dwim))
  (use-package undo-tree
    :defer t
    :config
    (meta-defun meta-undo "Undo." undo-tree-undo))
  
  (meta-defun meta-scroll-up "Scroll up." scroll-up)
  (meta-defun meta-scroll-down "Scroll down." scroll-down)
  (meta-defun-mapc
   '((meta-down "Move down." next-logical-line)
     (meta-up "Move up." previous-logical-line)
     (meta-end-of-line "Move to the end of line."
		       (boon-end-of-line)
                       :mode org-agenda-mode
                       org-agenda-end-of-line)
     (meta-down-element "Move down one element." forward-paragraph)
     (meta-up-element "Move up one element." backward-paragraph)
     (meta-forward "Move forward." forward-char)
     (meta-forward-sexp "Move forward sexp." forward-sexp)
     (meta-backward "Move backward." backward-char)
     (meta-backward-sexp "Move backward sexp." backward-sexp)
     (meta-forward-element "Move forward one element." forward-word)
     (meta-backward-element "Move backward one element." backward-word)
     (meta-recenter-top-bottom "Recenter text on scree." recenter-top-bottom)
     (meta-insert-enclosure-new-line "Insert beg/end passive structure in the line below." ignore)
     (meta-insert-active-enclosure-new-line "Isert beg/end active structure in the line below." ignore)
     ))
  )
#+end_src

It should be noted that the same can be done via setting the proper bindings for "j", "k", etc. in the mode itself. 
The problem is that it may mess up the cases when I want to assign special meanings to some keys in =command-mode=, but leave the normal editing on in the =insert-mode=.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :demand t
  :straight (boon :type git :host github :repo "jyp/boon"
		  :fork (:host github
			       :repo "yantar92/boon"))
  :diminish boon-local-mode
  :config
  (setq boon-special-mode-list
	'(debugger-mode edebug-mode ediff-mode org-agenda-mode cfw:calendar-mode
			notmuch-search-mode notmuch-show-mode elfeed-search-mode
			notmuch-tree-mode elfeed-show-mode pomidor-mode mingus-mode
			notmuch-hello-mode ledger-report-mode help-mode
			dired-mode image-dired-thumbnail-mode image-dired-display-image-mode
                        pdf-view-mode helpful-mode magit-file-mode
			magit-status-mode magit-revision-mode magit-log-mode
                        magit-diff-mode timer-list-mode
                        org-lint--report-mode image-mode
			mingus-playlist-mode mingus-browse-mode
			mingus-help-mode calendar-mode undo-tree-visualizer-mode
                        profiler-report-mode fundamental-mode explain-pause-mode
                        bm-show-mode
                        Info-mode woman-mode Man-mode
                        eaf-mode))
  (defvar boon-insert-state-major-mode-list '()
    "List of major modes started with insert state active.")
  
  (setq boon-insert-state-major-mode-list '(
					    notmuch-message-mode eshell-mode
                                            shell-mode calc-mode
                                            term-mode vterm-mode
                                            magit-popup-mode))
  (use-package org
    :config
    (add-hook 'org-log-buffer-setup-hook (boon-set-state 'boon-insert-state)))
  (add-hook 'boon-local-mode-hook
	    (lambda() (when (and boon-local-mode
			    (member major-mode boon-insert-state-major-mode-list))
		   (boon-set-state 'boon-insert-state)))
	    'append)
  (defun boon-set-insert-state ()
    "Switch to insert state."
    (boon-set-state 'boon-insert-state))
  (use-package boon-qwerty)
  (boon-mode))
#+end_src

Also, I do not like default implementation of =boon-special-mode-p=, which forces setting special mode for terminal-modes. I prefer to rewrite it

#+BEGIN_SRC emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (define-advice boon-special-mode-p (:around (oldfun) force-special-mode-list-only)
    "Force setting boon-special-mode when mode is in `boon-special-mode-list' and only in it. No exceptions."
    (memq major-mode boon-special-mode-list)))
#+END_SRC
**** Hydra
:PROPERTIES:
:CREATED:  [2017-12-31 Sun 08:36]
:ID:       8ad95362-807a-457d-8b59-32e83a350c18
:END:
Hydra is useful to quickly run commands in special contexts. 
It can be treated as a combination of command mode in =boon= to get simple key bindings in context with =which-key= to remind the meanings of these bindings. 
Additionally, it is possible to build hydras dynamically.

I currently do not use hydras often.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :if init-flag
  :straight t)
#+END_SRC
**** Ignore some system keybindings, which are used in my WM (annoying unknown keybinding error)
:PROPERTIES:
:ID:       af77c219-c181-4534-bdfc-325616965ddc
:END:
#+begin_src emacs-lisp
(when init-flag
(global-set-key (kbd "<XF86MonBrightnessUp>") #'ignore)
(global-set-key (kbd "<XF86MonBrightnessDown>") #'ignore)
(global-set-key (kbd "S-_") #'ignore)
(global-set-key (kbd "S-)") #'ignore)
(global-set-key (kbd "S-I") #'ignore)
(global-set-key (kbd "S-y") #'ignore)
(global-set-key (kbd "S-u") #'ignore)
(global-set-key (kbd "S-w") #'ignore)
(global-set-key (kbd "C-s-g") #'ignore)
(global-set-key (kbd "C-S-g") #'ignore))
#+end_src
**** Disable terminal key aliases (I don't use console emacs anyway)
:PROPERTIES:
:CREATED:  [2019-11-18 Mon 10:24]
:ID:       5656ef63-a887-47c0-9427-f7d53d9ddc13
:END:

Source: https://www.reddit.com/r/emacs/comments/auwzjr/weekly_tipstricketc_thread/ehcg919/
#+begin_src emacs-lisp
(when init-flag
;; free up blocked keys (GUI only)
;; add to your init.el
(define-key input-decode-map [?\C-m] [C-m])
(define-key input-decode-map [?\C-i] [C-i])
(define-key input-decode-map (kbd "C-[") [C-\[]))
#+end_src

**** Disable some keybinding, which interfere with my setup (easy to press by mistake)
:PROPERTIES:
:CREATED:  [2018-09-25 Tue 20:22]
:ID:       c952de1f-b5f9-4238-b01e-ff0870159694
:END:
#+BEGIN_SRC emacs-lisp
(when init-flag
  (unbind-key "M-u" global-map)
  (unbind-key "M-k" global-map)
  (unbind-key "M-j" global-map)
  (unbind-key "M-." global-map))
#+END_SRC
**** Quitting minibuffer when point is in another window
:PROPERTIES:
:CREATED:  [2020-07-25 Sat 20:45]
:ID:       0d66e995-bf3b-4c2f-a7ab-d3b9a3c4d18c
:END:

Credit: [[id:clemera2020_with_emacs_quit_curren_contex][clemera [with-emacs] (2020) With-Emacs · Quit Current Context]]

#+begin_src emacs-lisp
(defun keyboard-quit-context+ ()
  "Quit current context.

This function is a combination of `keyboard-quit' and
`keyboard-escape-quit' with some parts omitted and some custom
behavior added."
  (interactive)
  (cond ((region-active-p)
         ;; Avoid adding the region to the window selection.
         (setq saved-region-selection nil)
         (let (select-active-regions)
           (deactivate-mark)))
        ((eq last-command 'mode-exited) nil)
        (current-prefix-arg
         nil)
        (defining-kbd-macro
          (message
           (substitute-command-keys
            "Quit is ignored during macro defintion, use \\[kmacro-end-macro] if you want to stop macro definition"))
          (cancel-kbd-macro-events))
        ((active-minibuffer-window)
         (when (get-buffer-window "*Completions*")
           ;; hide completions first so point stays in active window when
           ;; outside the minibuffer
           (minibuffer-hide-completions))
         (abort-recursive-edit))
        (t
         ;; if we got this far just use the default so we don't miss
         ;; any upstream changes
         (keyboard-quit))))

(global-set-key [remap keyboard-quit] #'keyboard-quit-context+)
#+end_src

**** Make key bindings work in Ukrainian/Russian =keymap=
:PROPERTIES:
:ID:       943917fe-aecf-45a7-bc0d-591492d17898
:END:
#+begin_src emacs-lisp
(use-package reverse-im
  :straight t
  :if init-flag
  :config
  (reverse-im-activate "russian-computer"))
(when init-flag
  (cl-loop
   for from across "йцукенгшщзхїфівапролджєячсмитьбюЙЦУКЕНГШЩЗХЇФІВАПРОЛДЖЄЯЧСМИТЬБЮ№"
   for to   across "qwertyuiop[]asdfghjkl;'zxcvbnm,.QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>#"
   do
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "C-"
			  (string from)))
	    (kbd ,(concat "C-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "M-"
			  (string from)))
	    (kbd ,(concat "M-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "C-M-"
			  (string from)))
	    (kbd ,(concat "C-M-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(string from))
	    (kbd ,(string to))))))
#+end_src
**** Mnemonic key binding for =exit-recursive-edit=
:PROPERTIES:
:CREATED:  [2020-05-13 Wed 00:11]
:ID:       9a994fb4-5a44-4a3e-8a12-ce3035f7c558
:END:

#+begin_src emacs-lisp
(when init-flag
  (bind-key* "C-S-g" #'exit-recursive-edit))
#+end_src

*** Chinese input
:PROPERTIES:
:CREATED:  [2019-08-03 Sat 17:01]
:ID:       c822d425-3cfa-4cb7-bf1e-9ea893fbee5c
:END:
#+begin_src emacs-lisp
(use-package pyim 
  :if init-flag
  :straight t
  :demand t)
(use-package pyim-basedict
  :if init-flag
  :after pyim
  :requires pyim
  :config
  (pyim-basedict-enable)
  (setq default-input-method "pyim")
  (setq-default pyim-english-input-switch-functions
                '(pyim-probe-isearch-mode
                  pyim-probe-program-mode
                  pyim-probe-org-structure-template))
  (setq pyim-page-tooltip 'tooltip)
  (setq pyim-page-length 5))
#+end_src

*** Default major mode
:PROPERTIES:
:CREATED:  [2019-08-11 Sun 14:57]
:ID:       357921b0-cf2f-41ef-bbea-ddffab6090ce
:END:

Use text-mode by default.
From https://github.com/cadadr/configuration/blob/master/emacs.d/init.el

#+begin_src emacs-lisp
;; Default mode is ‘text-mode’.  The actual default,
;; ‘fundamental-mode’ is rather useless.

(setq-default major-mode 'text-mode)
#+end_src

** Completion
:PROPERTIES:
:ID:       f78e9123-ed35-4c76-a5fd-5549cc8f8210
:END:

Completion is what makes working in Emacs look like magic. 

*** Helm
:PROPERTIES:
:ID:       d388e4f5-214e-4697-a53a-be6fb6c24411
:END:

*************** TODO The update is delayed terribly sometimes. Not sure why. Sometimes, the helm buffer does not get updated at all, especially on short input (1-2 chars)
*************** END

Unlike default completion, =helm= lets you see all the possible completions dynamically updated as you type. 
No need to press TAB like crazy.

In addition to Emacs-wide change of the completion method, =Helm= also provides a bunch of useful commands, which especially benefit from live completion:
- =M-x= completion does not require the user to remember exact command names and exact sequence of words in command names
- apropos commands become a lot easier to discover
- can search in kill ring
- can search in most of info pages, including Emacs manual

Helm mode is very special in regards to =boon= because it works in mini-buffer. 
Hence, I had to define special versions of =boon=-like bindings for helm. 
The basic idea is to prefix movement commands with meta. 

#+begin_src emacs-lisp
  (use-package helm
    :if init-flag
    :straight (helm :type git :host github :repo "emacs-helm/helm"
		    :fork (:host github
				 :repo "yantar92/helm"))
    :diminish helm-mode
    :after boon
    :init
    ;; Re-define obsolete variables removed in latest Emacs
    (defvar minibuffer-local-must-match-filename-map nil)
    (defvar browse-url-mosaic-program nil)
    :bind (
	   ("M-x" . helm-M-x)
	   ("M-y" . helm-show-kill-ring)
	   ("<f1> a" . helm-apropos)
	   ("C-x c" . nil)
	   :map helm-map
	   ("M-j" . helm-next-line)
	   ("M-k" . helm-previous-line)
	   ("M-o" . helm-next-source)
	   ("M-i" . helm-previous-source)
	   ("M-l" . yant/helm-yank-selection-or-execute-persistent-action)
	   ("C-u" . helm-execute-persistent-action)
	   ("C-M-h" . backward-kill-word)
	   ("M-h" . backward-kill-word)
	   ("C-h" . backward-delete-char-untabify)
	   :map helm-find-files-map
	   ("M-l" . helm-execute-persistent-action)
	   :map boon-goto-map
	   ("e" . helm-resume)
	   )
    :defines helm-global-mode
    :custom
    (helm-split-window-inside-p t)
    (helm-move-to-line-cycle-in-source t)
    (helm-ff-file-name-history-use-recentf t)
    (helm-mode-fuzzy-match t)
    :config
    (defun yant/helm-yank-selection-or-execute-persistent-action (arg)
      "Call `helm-yank-selection' in some cases listed below."
      (interactive "P")
      (pcase helm--prompt
	((pred (string-match-p "Refile\\|\\(Link to attachment from\\)")) (funcall-interactively #'helm-yank-selection arg))
	(_ (funcall-interactively #'helm-execute-persistent-action))))
    (use-package helm-config)
    (use-package helm-files)
    (use-package helm-command)
    (define-global-minor-mode helm-global-mode helm-mode
      (lambda()
	(helm-mode 1)))
    (helm-global-mode))
#+end_src

**** Adaptive sorting of candidates
:PROPERTIES:
:CREATED:  [2020-07-04 Sat 17:17]
:ID:       403302b0-3861-4c90-baf2-aaa50c8e2df8
:END:

It is handly when frequently used matches are shown on top.
Credit: [[id:b9619989-5416-463c-a5e9-42d35364cbf2][emacs-tv-config/init-helm.el at master · thierryvolpiatto/emacs-tv-config]]

#+begin_src emacs-lisp
(use-package helm-adaptive
  :if init-flag
  :after helm
  :config
  (setq helm-adaptive-history-file nil)
  (helm-adaptive-mode 1))
#+end_src

*** Company
:PROPERTIES:
:ID:       8ca3a911-ad9d-43a6-83a6-a7b12b383984
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-09-22 Fri 07:58]
:END:

Context completion is *very* useful, especially if a major mode supports the completion. 
I use company for completion just because it is easy to use.

#+begin_src emacs-lisp
(use-package company
  :if init-flag
  :straight t
  :diminish (company-mode . " ⭿")
  :hook ((prog-mode ledger-mode lisp-interaction-mode) . company-mode)
  :custom
  (company-idle-delay 0)
  (company-minimum-prefix-length 2)
  (company-selection-wrap-around t)
  (company-require-match nil)
  (company-transformers '(company-sort-by-occurrence))
  :bind (:map company-active-map
	      ("<tab>" . company-complete-common-or-cycle)
	      ("M-j" . company-select-next)
	      ("M-k" . company-select-previous)
	      ("C-h" . backward-delete-char-untabify)
              ("C-M-h" . backward-kill-word)
              ("M-l" . nil)
              ("M-h" . company-show-doc-buffer)
              ("M-s" . company-filter-candidates)))
#+end_src

*** TODO Skeleton
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 14:28]
:END:
:LOGBOOK:
- State "TODO"       from              [2018-10-21 Sun 14:28]
:END:

Skeletons go beyond simple completion of a single word. 
They define a powerful template system making completion programmable and interactive. 

** NEXT History & version control
:PROPERTIES:
:ID:       a76e7822-8153-4adc-a3f8-8f05588eff5e
:END:

Keeping history of file changes both in short and long term is just like backups. 
One is already using it or not yet using...

*** Save buffer key binding
:PROPERTIES:
:ID:       21a8d99d-3f19-48d8-8f50-bfa9e139dbbc
:END:

Boon =command mode= allows translating =c 'symbol= key bindings into =C-c
'symbol= key bindings. It is useful, but =save-buffer= is more meaningful
to rebind to =C-c s= is such a case and =save-some-buffers= to =C-c C-s=.
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (bind-key "C-x s" 'save-buffer)
  (bind-key "C-x C-s" 'save-some-buffers))
#+end_src
*** Backup
:PROPERTIES:
:ID:       e9322c07-68fa-485f-abac-af5b5a2b97f5
:END:

I don't like Emacs' default behaviour to save backup files in the same folder, thus cluttering it annoyingly.
Keep everything in a single folder with tree ([[http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html][credit: Xah Lee]]) structure.

#+begin_src emacs-lisp
;; make backup to a designated dir, mirroring the full path
(defun my-backup-file-name (fpath)
  "Return a new file path of a given file path.
If the new path's directories does not exist, create them."
  (let* (
         (backupRootDir "~/.emacs.d/backup/")
         (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path, for example, “C:”
         (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") ))
         )
    (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
    backupFilePath))

(setq make-backup-file-name-function 'my-backup-file-name)

(setq
 backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
 backup-by-copying t
 delete-old-versions t
 kept-new-versions 100
 kept-old-versions 100
 version-control t
 )
#+end_src

Since this config is often called in extra batch process, lock-files can mess everything up. 
Disable them.

#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src

*** Backup walker
:PROPERTIES:
:CREATED:  [2019-08-22 Thu 22:51]
:ID:       3837955e-831d-46b3-8cbb-a4e7a9e19b92
:END:

Walk across the backup files

#+begin_src emacs-lisp
(use-package backup-walker
  :if init-flag
  :straight t
  :commands backup-walker-start)
#+end_src

*** Auto save
:PROPERTIES:
:ID:       2e32ad16-4c7a-46b9-8c47-06f7f5566032
:END:

Better auto save.
*************** NEXT This slows down emacs. Investigate
*************** END

#+begin_src emacs-lisp
(use-package auto-save-buffers-enhanced
  :disabled
  :straight t
  :config
  (auto-save-buffers-enhanced t))
#+end_src

#+begin_src emacs-lisp
(setq  auto-save-file-name-transforms `((".*"  "~/.emacs.d/auto-save/" t))
       auto-save-interval 20)
#+end_src
Save virtual buffers (kill ring, etc.)

Do it in separate file to avoid accidental overwriting when config is corrupted.
  #+begin_src emacs-lisp
(when init-flag
  (setq savehist-file (concat user-emacs-directory "yant.history"))
  (savehist-mode 1))
  #+end_src
*** TODO Never save some buffers
:PROPERTIES:
:ID:       7d188a71-560a-4d37-8037-2f2e44726a06
:END:
I got an issue with =org-src= block editing buffers. They are saved
under some weird name beside the actual org file when some command,
saving all the buffers, is executed.
#+begin_src emacs-lisp
(defvar yant/never-save-buffer-list nil
  "The buffers, matching any of the regexps in this list will never be saved.")
#+end_src
*** Persistent scratch
:PROPERTIES:
:ID:       4185d833-9d1f-4763-97a0-d44bcc322da7
:END:
#+begin_src emacs-lisp
(use-package  persistent-scratch
  :if init-flag
  :straight t
  :config
  (persistent-scratch-autosave-mode 1)
  )
#+end_src
*** Recent files
:PROPERTIES:
:ID:       b72d24a2-7692-4e37-b547-10c30b058c22
:END:

Show recently opened files in =helm-mini= buffer.

#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :config
  (recentf-mode t)
  (setq
   recentf-max-menu-items 30
   recentf-max-saved-items 100
   helm-ff-file-name-history-use-recentf t))
#+end_src
*** No global auto-revert
:PROPERTIES:
:ID:       b4f4fbea-9315-412c-bb48-6984906c67d8
:END:

Auto-revert mode is nice, but it slows down Emacs on my huge .org files. 
Hence, I do not use it globally, but enable only where I need it.

#+begin_src emacs-lisp
(global-auto-revert-mode -1)
(diminish 'auto-revert-mode)
(setq auto-revert-verbose nil)
(setq revert-without-query '(".*"))
(bind-key* "M-r" #'revert-buffer)
#+end_src
*** Follow symlinks to vc files
:PROPERTIES:
:CREATED:  [2020-07-12 Sun 18:35]
:ID:       cc9cf78f-888f-488e-98f6-ecb5011af85a
:END:

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src

*** =Magit=
:PROPERTIES:
:CREATED:  [2018-08-11 Sat 20:47]
:ID:       6e9f1b1e-bcd9-4927-894f-7a3ff773fb8c
:END:

One more step towards doing all the things in Emacs. 
Do not even need terminal to interact with Git.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :straight t
  :if init-flag
  :init
  (use-package transient :straight t)
  :config
  (use-package boon :config
    (bind-keys :map boon-x-map
	       ("g" . magit-status)
	       ("G" . magit-dispatch-popup)
	       ("M-g" . magit-file-popup))
    (use-package meta-functions
      :config
      (meta-defun meta-down-element :mode magit-status-mode magit-section-forward)
      (meta-defun meta-up-element :mode magit-status-mode magit-section-backward)
      (meta-defun meta-down-element :mode magit-revision-mode magit-section-forward)
      (meta-defun meta-up-element :mode magit-revision-mode magit-section-backward))))
#+END_SRC

Interaction with Github

#+BEGIN_SRC emacs-lisp
(use-package magithub
  :if init-flag
  :straight t
  :after (magit magit-popup)
  :init
  (use-package magit-popup :straight t)
  (require 'magit-popup)
  :config
  (magithub-feature-autoinject t)
  ;; Workaround for https://github.com/vermiculus/magithub/issues/71
  (defun magithub-issue--sort (issues)
    "Sort ISSUES by issue number."
    (sort issues
          (lambda (a b) (> (plist-get a :number)
		      (plist-get b :number))))))
#+END_SRC

Working with forges

#+begin_src emacs-lisp
(use-package forge
  :if init-flag
  :straight t
  :after magit)
#+end_src

Activate insert state when editing commits
#+begin_src emacs-lisp
(when init-flag
(add-hook 'with-editor-mode-hook #'boon-set-insert-state))
#+end_src
**** Initial section visibility
:PROPERTIES:
:CREATED:  [2020-05-26 Tue 16:45]
:ID:       3b8d01b1-878f-466a-bc75-64be45f7e967
:END:
Credit: [[id:7fe204b5-3d7e-4227-a4b3-ff3b96ee1601][Irreal: Setting the Initial Visibility of Magit Sections]]

#+begin_src emacs-lisp
(use-package magit
  :custom
  (magit-section-initial-visibility-alist
   '((stashes . hide) (untracked . hide) (unpushed . hide))))
#+end_src
** Text highlight & colouring
:PROPERTIES:
:ID:       d95f91d1-cef9-4094-9592-b38514fe2a77
:END:

*** Temporary highlight text in buffer
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 14:29]
:ID:       9c3fe725-f67e-4abb-878f-da7b45bea121
:END:

User-defined temporary highlighting.

#+begin_src emacs-lisp
(use-package hi-lock
  :if init-flag
  :diminish hi-lock-mode)
#+end_src
*** TODO Spell checking
:PROPERTIES:
:ID:       117c5718-7a46-4a7a-ab0d-b5b347444080
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-18 Wed 11:26]
:END:

Typos are inevitable. 
Highlighting typos is crucial.

**** =Flyspell=
:PROPERTIES:
:CREATED:  [2018-10-12 Fri 14:07]
:ID:       b79658d1-8d62-4c47-be3b-cc399a0a8c59
:END:

*************** TODO fly =ispell= only with idle timer?
*************** END
*************** TODO enable in org-mode
*************** END

#+begin_src emacs-lisp
(use-package flyspell
  :if init-flag
  :straight t
  :after org
  :diminish (flyspell-mode . " ✓")
  :hook ((notmuch-message-mode org-mode) . flyspell-mode)
  :bind (("<f8>" . ispell-word)
	 ("M-<f8>" . ispell-buffer)
         :map boon-forward-search-map
         ("s" . flyspell-goto-next-error))
  :init
  (use-package boon)
  :config
  (setq ispell-program-name "/usr/bin/ispell-aspell")
  (setq ispell-dictionary "british")
  (setq ispell-personal-dictionary "~/.emacs.d/dict")
  )
#+end_src

***** Textual error pop-up
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 12:56]
:ID:       f99358cd-f847-4004-ac4e-bc1f49fdfcce
:END:
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :if init-flag
  :config
  (defun flyspell-emacs-popup-textual (event poss word)
    "A textual flyspell popup menu.
From https://www.emacswiki.org/emacs/FlySpell"
    (require 'popup)
    (let* ((corrects (if flyspell-sort-corrections
			 (sort (car (cdr (cdr poss))) 'string<)
		       (car (cdr (cdr poss)))))
	   (cor-menu (if (consp corrects)
			 (mapcar (lambda (correct)
				   (list correct correct))
				 corrects)
		       '()))
	   (affix (car (cdr (cdr (cdr poss)))))
	   show-affix-info
	   (base-menu  (let ((save (if (and (consp affix) show-affix-info)
				       (list
					(list (concat "Save affix: " (car affix))
					      'save)
					'("Accept (session)" session)
					'("Accept (buffer)" buffer))
				     '(("Save word" save)
				       ("Accept (session)" session)
				       ("Accept (buffer)" buffer)))))
			 (if (consp cor-menu)
			     (append cor-menu (cons "" save))
			   save)))
	   (menu (mapcar
		  (lambda (arg) (if (consp arg) (car arg) arg))
		  base-menu)))
      (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
  (fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)
  (defadvice flyspell-goto-next-error (after check-word-spelling activate) (ispell-word))
  )
#+END_SRC
***** Automatically add wrong spelled words to abbrev to avoid such mistakes later
:PROPERTIES:
:CREATED:  [2019-08-07 Wed 10:27]
:ID:       a47c3763-17c4-4a6e-9ec7-d204a8616166
:END:

The idea and the code is from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][here]].

#+begin_src emacs-lisp
(when init-flag

  (bind-key* "M-h" #'endless/ispell-word-then-abbrev)

  (defun endless/simple-get-word ()
    (car-safe (save-excursion (ispell-get-word nil))))

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
	(while (if (setq bef (endless/simple-get-word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
		 ;; If there's no word at point, keep looking
		 ;; until `bob'.
		 (not (bobp)))
          (backward-word)
          (backward-char))
	(setq aft (endless/simple-get-word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
		(bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
	(user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
  (diminish 'abbrev-mode))
#+end_src
*** Code checking
:PROPERTIES:
:ID:       3a550aad-f2a2-4636-a92c-539cdf230aeb
:END:

Show errors in code with =flycheck=, in tooltips (via =flycheck-tip=).

I also use =shellcheck= software to check my bash scripts (it is automatically used by =flycheck= if available).
Thanks [[id:0c12a7e7-6cd0-45aa-b6d2-9f0f9e164d92][Alvaro Ramirez's notes: Trying out ShellCheck]] for suggestion!

#+begin_src emacs-lisp
(use-package flycheck
  :if init-flag
  :straight t
  :diminish (flycheck-mode . " λ✓")
  :hook ((prog-mode lisp-interaction-mode) . flycheck-mode)
  :config
  (use-package flycheck-tip
    :straight t
    :config
    (setq flycheck-display-errors-function 'ignore)
    (use-package boon
      :config
      (bind-keys :map boon-forward-search-map
		 ("c" . flycheck-tip-cycle)
                 :map boon-backward-search-map
                 ("c" . flycheck-tip-cycle-reverse)))))
#+end_src
*** Highlight parentheses everywhere
:PROPERTIES:
:ID:       767805ca-1482-4299-8a1c-3e3b1a73f94a
:END:

#+begin_src emacs-lisp
(use-package highlight-parentheses
  :if init-flag
  :straight t
  :diminish highlight-parentheses-mode
  :config
  (define-globalized-minor-mode global-highlight-parentheses-mode
    highlight-parentheses-mode
    (lambda ()
      (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t))

(use-package rainbow-delimiters
  :if init-flag
  :straight t
  :hook ((prog-mode lisp-interaction-mode) . rainbow-delimiters-mode))
#+end_src
*** Highlight numbers
:PROPERTIES:
:ID:       024a16ec-c9db-4906-9896-8ebf8af76dae
:END:
#+begin_src emacs-lisp
(use-package highlight-numbers
  :if init-flag
  :straight t
  :hook ((prog-mode lisp-interaction-mode) . highlight-numbers-mode))
#+end_src
*** Regexp escape smart highlight
:PROPERTIES:
:ID:       5d7810ea-35d4-4ee9-afaa-61b9c6c624c6
:END:

Emacs regex escaping in string is often confusing. 
=easy-escape= helps to avoid mistakes.

#+begin_src emacs-lisp
(use-package easy-escape
  :if init-flag
  :straight t
  :diminish easy-escape-minor-mode
  :hook ((prog-mode lisp-interaction-mode) . easy-escape-minor-mode))
#+end_src
*** Search highlight
:PROPERTIES:
:ID:       afa67877-bede-41c1-9c44-bb168070d292
:END:

Highlight text matching =isearch=.

#+begin_src emacs-lisp
(when init-flag
(setf search-highlight t)
(setf query-replace-highlight t))
#+end_src
*** Volatile highlights - highlight actions
:PROPERTIES:
:ID:       02c8a98c-a38a-4054-a0a2-400f6757693b
:END:

Highlight recently changed text. 
Especially useful when inserting/replacing big chunks of text.

I changed the background colour here due to clash with my =org-mode= colours

  #+begin_src emacs-lisp
(use-package volatile-highlights
  :if init-flag
  :straight t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t)
  (custom-set-faces
   '(vhl/default-face ((t :background "LightGray" :inherit secondary-selection)))))
  #+end_src
*** Highlight evaluated sexp
:PROPERTIES:
:CREATED:  [2020-04-16 Thu 15:15]
:ID:       e2c5bd27-1c31-4372-8d8a-9d09ac00ce8e
:END:

#+begin_src emacs-lisp
(use-package eval-sexp-fu :straight t)
#+end_src

*** Expand region
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 20:46]
:ID:       13ec58f5-636b-479f-ad19-ad229ce47603
:END:

Incrementally expand active region.
I only use it occasionally though.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :if init-flag
  :straight t
  :after org
  :bind (:map boon-command-map
	      ("`" . er/expand-region)
              :map boon-special-map
              ("`" . er/expand-region)))

#+END_SRC

** Fold & narrow
:PROPERTIES:
:ID:       7f5795bc-6bc1-4095-b31c-ed724bbc942c
:END:

*** =Hideshow= mode
:PROPERTIES:
:ID:       6ea2a9f7-7b73-4289-976f-b53adcae8f38
:END:

It is useful to explore large source code files with hidden details of implementation.
I often use it to search interesting things in Emacs packages.

#+begin_src emacs-lisp
(use-package hideshow
  :if init-flag
  :straight t
  :diminish hs-minor-mode
  :bind (:map hs-minor-mode-map
	      :filter boon-command-state
	      ("<tab>" . hs-toggle-hiding)
	      ("<backtab>" . hs-hide-all)
	      ("M-S-<iso-lefttab>" . hs-show-all))
  :hook ((c-mode-common emacs-lisp-mode sh-mode) . hs-minor-mode))
#+end_src
*** Turn on narrow
:PROPERTIES:
:ID:       9b629716-48c5-41c7-b34e-5e458922368b
:END:

Narrowing is very useful, especially in large org files or when working with a large function in Elisp code.
Enable it. 

#+begin_src emacs-lisp
(when init-flag
  (put 'narrow-to-region 'disabled nil))
#+end_src
** Search & navigation
:PROPERTIES:
:ID:       46fb459b-7794-4b9a-9fce-85389aba1d95
:END:

*** Text

**** Case fold search
:PROPERTIES:
:CREATED:  [2020-05-03 Sun 22:32]
:ID:       7087ec1b-50ab-4161-9819-db874fe53a21
:END:

Ignore case during search by default

#+begin_src emacs-lisp
(setq-default case-fold-search t)
(use-package isearch
  :if init-flag
  :config
  (setq-default isearch-case-fold-search t))(
  use-package helm
  :if init-flag
  :custom
  (helm-set-case-fold-search 'smart))
#+end_src

**** Boon navigation & search
:PROPERTIES:
:ID:       e90d8071-a7ed-4aba-a694-a78aa5fded78
:END:

File navigation and search are the most frequent actions for me. 
Here, I want to make sure that the navigation commands are bind to easily accessible keys on home row of the keyboard.

The core keys for left hand are =jkl;= =uiop=, and =bn= which are easy to access with pointing finger sitting on top of =j=. I use these keys for buffer navigation. 

The left hand is mostly sitting on =<SHIFT>sdf= with =<TAB>wert= and =zxcv= being easily accessible. Note that I do not include =a=. It is to simplify access to =<CTRL><TAB><SHIFT>=, which are useful for traditional Emacs keys. Also, left thumb is mostly sitting on =<META><SPACE>=. Nothing special here.

Exiting insert mode with =<ESC>= is extremely uncomfortable. I prefer =M-l=, which is very fast to use.
Because of this, I have to unbind =M-l= in global map (it calls capitalise word by default). 

Note that I use [[meta-functions][meta-functions]] here as much as possible to unify the navigation in different major modes.
The =n= binding to =boon-switch-mark= and =N= for =pop-global-mark= is especially useful because it can jump backward in the mark-ring, exchange region marks, or jump in global mark ring which is especially useful if I temporary move to some place to look for something. Many of the movement functions are also additionally modified to store mark before moving.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (define-key boon-x-map "n" narrow-map)
  (bind-keys ("C-M-S-j" . scroll-other-window)
	     ("C-M-S-k" . scroll-other-window-down)
	     :map boon-x-map
	     ("e" . eval-last-sexp)
	     ("c" . delete-frame)
	     :map boon-moves-map
	     ("j" . meta-down)
	     ("J" . meta-down-element)
	     ("k" . meta-up)
	     ("K" . meta-up-element)
	     ("o" . meta-forward)
	     ("O" . meta-forward-element)
	     ("P" . meta-forward-sexp)
	     ("i" . meta-backward)
	     ("I" . meta-backward-element)
	     ("U" . meta-backward-sexp)
	     ("l" . meta-scroll-up)
	     ("L" . meta-scroll-down)
	     (";" . meta-recenter-top-bottom)
	     ("G" . end-of-buffer)
	     ("g" . boon-goto-map)
	     ;;("U" . move-beginning-of-line)
	     ;;("P" . move-end-of-line)
	     ("u" . boon-beginning-of-line)
	     ("p" . meta-end-of-line)
	     :map boon-goto-map
	     ("g" . beginning-of-buffer)
	     ("G" . end-of-buffer)
	     :map boon-command-map
	     ("-" . meta-undo)
	     ("~" . boon-repeat-command)
	     ("Q" . kmacro-end-or-call-macro)
	     ("z" . boon-quote-character)
	     ("y" . transpose-chars)
	     ("Y" . transpose-words)
             ("C-Y" . transpose-sexps)
             ("n" . boon-switch-mark)
             ("m" . bm-previous)
             ("C-k" . meta-cut-element)
	     :map boon-forward-search-map
	     ("C-SPC" . isearch-forward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("w" . meta-occur)
             ("g" . meta-goto)
	     :map boon-backward-search-map
	     ("C-SPC" . isearch-backward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("e" . meta-occur)
             ("g" . meta-goto)
	     :map boon-special-map
	     ("c" . boon-c-god)
	     ("z" . boon-quote-character)
	     ("e" . boon-forward-search-map)
	     ("w" . boon-backward-search-map)
	     ("q" . nil)
	     ("g" . boon-goto-map)
	     ("G" . end-of-buffer)
	     ("D" . boon-treasure-region)
	     ("<SPC>" . boon-drop-mark))
  (unbind-key "M-l" global-map))
#+end_src
**** =Avy= mode - =qutebrowser= like hints to words
:PROPERTIES:
:ID:       f645973b-fcd8-466a-9fec-7e8ebcbb0be1
:END:

I do not move by visual line in files. Instead, I prefer to use =avy= to move within the line.

#+begin_src emacs-lisp
  (use-package boon
    :if init-flag
    :defer t
    :config
  (use-package avy
    :straight t
    :bind (:map boon-moves-map
		("H" . avy-goto-char-timer)
		("h" . avy-goto-char-in-line))
    :custom
    (avy-timeout-seconds 0.2 "The default is too long.")))
#+end_src

**** End of sentence
:PROPERTIES:
:CREATED:  [2018-01-18 Thu 14:43]
:ID:       40e35090-b8ec-4770-864b-9e286459533c
:END:

Double space convention is outdated.

#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC
**** =goto-line= with preview
:PROPERTIES:
:CREATED:  [2019-08-07 Wed 21:38]
:ID:       6e7fa2e9-644d-4682-84c9-53e2f0c2d295
:END:

#+begin_src emacs-lisp
(use-package goto-line-preview
  :if init-flag
  :straight t
  :config
  (global-set-key [remap goto-line] 'goto-line-preview))
#+end_src
**** =Isearch=
:PROPERTIES:
:CREATED:  [2020-03-31 Tue 01:37]
:ID:       8faacef7-04f8-4e18-9282-ce5d68757efb
:END:

Xah Lee gave an interesting idea to bind extra key in =isearch=. [[http://ergoemacs.org/emacs/emacs_isearch_by_arrow_keys.html][cite]]
Following my key binding theme for [[id:d388e4f5-214e-4697-a53a-be6fb6c24411][Helm]], I also define extra keys in =isearch= 

#+begin_src emacs-lisp
(use-package isearch
  :if init-flag
  :config
  (bind-key "M-j" #'isearch-repeat-forward isearch-mode-map)
  (bind-key "M-k" #'isearch-repeat-backward isearch-mode-map))
#+end_src
**** Remember previous location after moving around text
:PROPERTIES:
:CREATED:  [2020-04-08 Wed 16:08]
:ID:       256b50fe-7a39-4ca7-87f5-b279feb0321b
:END:

Many movement commands save the current position into the mark ring before moving. 
Do the same for my meta- movement functions.

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (define-advice meta-up-element (:before (&rest args) push-mark)
    "Call `push-mark'"
    (when (and (not (region-active-p))
	       (called-interactively-p))
      (push-mark)))
  (advice-add 'meta-down-element :before #'meta-up-element@push-mark))
#+end_src

**** Disable "Mark set" message
:PROPERTIES:
:CREATED:  [2020-04-06 Mon 00:34]
:ID:       36b5ae6e-a53a-466f-984a-d877e5a4617f
:END:

Since I am using boon and a lot of searching for fast movement in the buffers, the "Mark set" message often spams the minibuffer. 
Disabling it, since it is not very useful for me anyway.

#+begin_src emacs-lisp
(when init-flag
  ;; (use-package helm-lib
  ;;   :config
  ;;   ;; helm overrides the `push-mark' function by default (according to `helm-advice-push-mark' value)
  ;;   ;; advice the override as well
  ;;   (define-advice helm--advice-push-mark (:filter-args (args) disable-message)
  ;;     "Disable \"Mark set\" message."
  ;;     (list (car args) t (caddr args))))
  (define-advice push-mark (:filter-args (args) disable-message)
    "Disable \"Mark set\" message."
    (list (car args) t (caddr args))))
#+end_src
*** Links
:PROPERTIES:
:ID:       7908bb55-6bc0-4db2-b5d2-258ff985250d
:END:

**** Browse URL
:PROPERTIES:
:ID:       17ccb0ae-e369-45bb-bfab-1d3cac9ca147
:END:

Just use external browser to open URLs. 

#+begin_src emacs-lisp
(use-package browse-url
  :bind (("C-c C-o" . browse-url))
  :custom
  (browse-url-browser-function 'browse-url-generic)
  (browse-url-generic-program "/home/yantar92/bin/qutebrowser-call.sh"))
#+end_src

*** =Imenu=
:PROPERTIES:
:CREATED:  [2018-10-25 Thu 22:45]
:ID:       fdbef4e6-7b49-4c80-88be-cf9f85bce94f
:END:

=Imenu= allows navigating through the buffer structure, according to the major mode.

#+begin_src emacs-lisp
(use-package imenu
  :if init-flag
  :config
  (use-package helm
    :config  
    (use-package meta-functions :config  
      (meta-defun meta-goto "Goto place in document." helm-imenu))))
#+end_src

*** Buffers
**** Switching buffers
:PROPERTIES:
:ID:       b69737e2-daa5-4b12-bb10-9ce37831edd4
:END:

I use =helm-mini= to switch buffers

#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :bind (:map boon-forward-search-map
	      ("b" . helm-mini)
	      :map boon-backward-search-map
	      ("b" . helm-mini))
  :after boon)
#+end_src
**** Go to scratch key binding
:PROPERTIES:
:ID:       53b113ca-e2be-4f79-a575-aedbd0f0f7ad
:END:

There is a significant number cases when I want to quickly pop to scratch buffer. 
Setting a binding for this.

#+begin_src emacs-lisp
(when init-flag
  (defun yant/show-scratch()
    (interactive)
    (pop-to-buffer "*scratch*"))
  
  (use-package boon
    :bind (:map boon-goto-map
		("8" . yant/show-scratch))))
#+end_src
**** Kill buffer & buffer manipulation/movement
:PROPERTIES:
:ID:       cb74c835-f010-4880-ad84-00736172753f
:END:

The default function to kill buffer bound to =C-x k= always ask for a buffer to kill. I often just need to kill current buffer without redundant confirmation. 

#+begin_src emacs-lisp
(when init-flag
  (defun yant/kill-this-buffer ()
    "Kill current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (bind-key "C-x q" #'yant/kill-this-buffer))
#+end_src
**** Buffer manipulation
:PROPERTIES:
:CREATED:  [2020-04-09 Thu 17:30]
:ID:       6e8fd921-88ca-411d-9045-6141121e9afa
:END:

Sometimes, I want to switch to previous/next buffer in current window.
The definition of previous/next buffer may depend on the major mode though. 
 
#+begin_src emacs-lisp
(use-package boon
  :bind (:map boon-goto-map
	      ("o" . meta-next-buffer)
	      ("i" . meta-previous-buffer))
  :init
  (use-package meta-functions
    :config
    (meta-defun meta-next-buffer "Go forward in buffer." next-buffer)
    (meta-defun meta-previous-buffer "Go backward in buffer." previous-buffer)))
#+end_src

*** Windows
**** Window layout management
:PROPERTIES:
:ID:       413ad4db-e20c-432f-8d15-b849d35b6cff
:END:

If we use boon, it frees up =M-digit= bindings.
I use them to manage windows. It is much faster than default.

Also, improve the default commands by using =windower=. 
Instead of =delete-other-windows=, use =windower's= version, which toggles maximised/original layout.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :init
  (use-package windower
    :straight (emacs-windower :host gitlab :repo "ambrevar/emacs-windower"
			      :fork (:host gitlab :repo "yantar92/emacs-windower")))
  :bind (("M-1" . #'windower-toggle-single)
	 ("M-2" . split-window-below)
	 ("M-0" . delete-window)
	 ("M-3" . split-window-right)
	 ("M-4" . (lambda () (interactive)
		    (split-window-right)
                    (call-interactively #'clone-indirect-buffer-other-window)))))
#+end_src

Sometimes, there is a need to split window vertically or horizontally, but I make a mistake and split in wrong direction.
Then I used to delete the window (=M-0)= and re-split, but can as well save a keystroke if I can change direction of the split.

#+begin_src emacs-lisp
(use-package windower
  :bind ("M-`" . #'windower-toggle-split))
#+end_src
**** Window selection
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 00:00]
:ID:       e1c38416-fd29-4a1a-ab23-9e70fbc5e6e5
:END:

Use =boon-*-search-map= to select windows and =C-M-l= to cycle current window.

#+begin_src emacs-lisp
(use-package windmove
  :bind (("C-M-;" . other-window)
	 :map boon-forward-search-map
	 ("j" . windmove-down)
         ("k" . windmove-up)
         ("i" . windmove-left)
         ("o" . windmove-right)))
#+end_src

**** Undo window configuration changes
:PROPERTIES:
:CREATED:  [2018-10-08 Mon 14:45]
:ID:       46cd7842-d65f-4794-9ddd-e9dc50f6495c
:END:

#+BEGIN_SRC emacs-lisp
(when init-flag
  (winner-mode +1)
  (use-package boon
    :bind (:map boon-goto-map
		("u" . winner-undo)
		("p" . winner-redo))))
#+END_SRC
**** Recentering text in window
:PROPERTIES:
:ID:       0e666b8b-fed0-45e1-8921-b67e0c24790b
:END:

By default help:recenter-top-bottom goes in the following order: middle top bottom.
However, most of time I use this function is aligning text to top of the window.

#+begin_src emacs-lisp
(when init-flag
  (setq recenter-positions '(top middle bottom)))
#+end_src

*** Frame
:PROPERTIES:
:ID:       bb7ce294-1833-43bd-a837-ab4cd73fca6b
:END:

**** Deleting frame
:PROPERTIES:
:CREATED:  [2020-04-09 Thu 17:36]
:ID:       dc5f5576-0a2b-4c7f-9f45-871b3777d5c1
:END:

I need an extra binding here to make =x c= work in boon command map.

#+begin_src emacs-lisp
(when init-flag
(global-set-key (kbd "C-x C-c") 'delete-frame)
(global-set-key (kbd "C-x c") 'delete-frame))
#+end_src

**** Detach current window from the frame
:PROPERTIES:
:CREATED:  [2019-08-02 Fri 23:25]
:ID:       a80e772c-443e-4e44-a2c1-7891808c3dc0
:END:

I keep forgetting this, but it is sometimes useful to detach current window into separate frame.
For example, debugger window may sometimes occupy too much of frame space and detaching it from the frame can be useful.

#+begin_src emacs-lisp
(when init-flag

  (defun my/tear-off-window ()
    "Delete the selected window, and create a new frame displaying its buffer."
    (interactive)
    (let* ((window (selected-window))
	   (buf (window-buffer window))
	   (frame (make-frame)))
      (select-frame frame)
      (switch-to-buffer buf)
      (delete-window window)))
  (use-package boon
    :config
    (bind-key "M-5" #'my/tear-off-window)))
#+end_src
*** Files
**** Find files
:PROPERTIES:
:ID:       ecf20706-a6b2-4a46-b3c6-db3236a46d0f
:END:

I use helm to find files. Binding to =boon-*-search-map=, since it is logical. 

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)
             :map boon-backward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)))
#+end_src
**** Open files as root
:PROPERTIES:
:CREATED:  [2018-01-10 Wed 02:38]
:ID:       4229fb72-78fe-4848-b925-fb1f87f75fdf
:END:
:LOGBOOK:
- Refiled on [2020-04-20 Mon 21:21]
- State "TODO"       from              [2018-01-10 Wed 02:41]
:END:

#+BEGIN_SRC emacs-lisp
(when init-flag
  ;; http://emacs.readthedocs.io/en/latest/file_management.html
  (defun yt/sudo-find-file (file-name)
    "Like find file, but opens the file as root."
    (interactive "FSudo Find File: ")
    (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
      (find-file tramp-file-name)))
  (use-package boon
    :defer t
    :bind (:map boon-forward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name))))
                :map boon-backward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name)))))))
#+END_SRC
*** Directories
**** =Dired=
:PROPERTIES:
:ID:       66f5dab7-add6-48c2-9824-fed4ef202b7a
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-10-08 Mon 14:55]
- State "TODO"       from              [2018-03-12 Mon 14:57]
- State "CANCELLED"  from              [2017-05-28 Sun 17:46]
:END:

Run =dired= from =boon-*-search-map=

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
             ("d" . dired)
             :map boon-backward-search-map
	     ("d" . dired)))
#+end_src

And extend it with =dired+= 

*************** TODO review possibilities in dired+
*************** END

#+BEGIN_SRC emacs-lisp
(use-package dired+
  :if init-flag
  :straight t)
#+END_SRC

*************** TODO re-check performance
*************** END
 do not use =dired+= mode-line. Too much performance degradation
#+begin_src emacs-lisp
;; (when init-flag
;;   (remove-hook 'dired-after-readin-hook #'diredp-nb-marked-in-mode-name))
#+end_src

***** Command loop
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:18]
:END:
****** Key bindings
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:18]
:END:
******* Dired bindings
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:38]
:ID:       e5aa5b80-b4dd-41b2-9c43-3dde7ba7d2f7
:END:

#+BEGIN_SRC emacs-lisp  
(use-package dired
  :if init-flag
  :bind (:map dired-mode-map
	      ("W" . dired-copy-filename-as-kill)
	      ("s" . dired-mark)
	      ("a" . dired-unmark)
              ("A" . dired-unmark-all-marks))
  :config
  (use-package dired-filter
    :defer t
    :bind (:map dired-filter-group-header-map
		("<tab>" . dired-filter-group-toggle-header))
    :config
    (set-face-attribute 'dired-filter-group-header nil
			:underline nil))
  (use-package meta-functions
    :init
    (use-package dired-hacks-utils :straight t)
    :config
    (meta-defun meta-down :mode dired-mode dired-hacks-next-file)
    (meta-defun meta-up :mode dired-mode dired-hacks-previous-file)
    (meta-defun meta-up-element :mode dired-mode dired-up-directory)
    (meta-defun meta-up-element :mode dired-mode :cond (get-text-property (point) 'dired-filter-group-header) dired-filter-group-backward-drawer)
    (meta-defun meta-down-element :mode dired-mode dired-filter-group-forward-drawer)
    (meta-defun meta-return :mode dired-mode :cond (get-text-property (point) 'dired-filter-group-header) dired-filter-group-toggle-header)
    (meta-defun meta-return :mode dired-mode :cond (get-text-property (point) 'dired-filter-group-header) dired-filter-group-toggle-header)
    ))
#+end_src

******* =Image-dired= bindings
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 21:26]
:ID:       c095c061-ffdc-4adb-a889-bb4e54b6a514
:END:
*************** TODO review capabilities of image-dired
*************** END

#+begin_src emacs-lisp
(use-package image-dired
  :if init-flag
  :bind (:map image-dired-thumbnail-mode-map
	      ("s" . image-dired-mark-thumb-original-file)
              ("a" . image-dired-unmark-thumb-original-file)
              ("A" . image-dired-unmark-all-thumbs-original-files))
  :init
  (defun image-dired-unmark-all-thumbs-original-files ()
    "Unmark all original image files in associated dired buffer."
    (interactive)
    (when-let ((dired-buf (image-dired-associated-dired-buffer)))
      (with-current-buffer dired-buf
	(dired-unmark-all-marks))))

  :config
  (unbind-key "o" image-map)
  (use-package meta-functions
    :config
    (meta-defun meta-forward :mode image-dired-thumbnail-mode image-dired-forward-image)
    (meta-defun meta-backward :mode image-dired-thumbnail-mode image-dired-backward-image)
    (meta-defun meta-down :mode image-dired-thumbnail-mode image-dired-next-line)
    (meta-defun meta-up :mode image-dired-thumbnail-mode image-dired-previous-line)))
#+end_src
****** =DWIM= target on copy/rename
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:18]
:ID:       80db1c22-bc50-451f-950c-d8e4d9f373c9
:END:

#+begin_src emacs-lisp
(use-package dired
  :custom (dired-dwim-target t))
#+end_src

****** Automatically kill =dired= buffers pointing to deleted directories
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:25]
:ID:       9367d902-8069-4507-becb-3a7688885feb
:END:

#+begin_src emacs-lisp
(use-package dired
  :if init-flag
  :custom
  (dired-clean-confirm-killing-deleted-buffers nil))
#+end_src

****** Kill all the previous =dired= buffers when quitting 
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:27]
:ID:       3a1bc711-2264-4893-9939-d533de84e91b
:END:

By default, every time I enter a new directory from =dired=, a new =dired= buffer is created. 
This makes it annoying to exit the =dired= buffer since I would need to press "q" many times. 
Some people solve this problem by using 

Kill all the =dired= buffers in the window until non-=dired= buffer on "q"

#+begin_src emacs-lisp
(use-package dired
  :if init-flag
  :bind (:map dired-mode-map
	      ("q" . dired-quit-window))
  :init
  (defun dired-quit-window (&optional kill window)
    "Run `quit-window' until first non-dired buffer in the current window."
    (interactive)
    (let ((window (or window (selected-window))))
      (with-selected-window window
	(while (and (window-live-p window)
		    (eq major-mode 'dired-mode))
	  (quit-window kill window))))))
#+end_src

***** Image dired
:PROPERTIES:
:CREATED:  [2020-05-15 Fri 00:20]
:ID:       0513c7b0-f723-40f7-85bc-ee3c4b35b823
:END:


*************** TODO suggest to add to emacs?
*************** END

Unselect all the files after showing thumbnails. Useful to mark files from the =image-dired= buffer. 
#+begin_src emacs-lisp
(use-package image-dired
  :if init-flag
  :config
  (define-advice image-dired-display-thumbs (:after (&rest _) unmark-all-files)
    "Unmark all files in current dired buffer."
    (when (eq major-mode 'dired-mode)
      (dired-unmark-all-marks))))
#+end_src

***** Delete to trash
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:23]
:ID:       854016c9-7412-42f9-b782-c03ece68d609
:END:

Using trash is safer.

#+begin_src emacs-lisp
(use-package dired
  :if init-flag
  :custom
  (delete-by-moving-to-trash t)
  (trash-directory "~/tmp/Trash"))
#+end_src
***** TODO COMMENT Auto-revert =dired= buffers
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:11]
:ID:       6ac566c7-dbe9-4329-9710-ad05293d7b78
:END:

Some large dired buffers take a while to update, especially when there are multiple such buffers.
This gets really annoying if I change some directory externally, switch to Emacs, and have to wait several seconds until Emacs unhangs.
Instead of using =auto-revert=, I just update dired buffers when they become active.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :if init-flag
  :hook (dired-mode . auto-revert-mode)
  :init
  (use-package autorevert))
#+END_SRC

***** Open file in external app from dired
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:55]
:ID:       61a29cb9-8c13-4e10-979d-144866c4d122
:END:

#+begin_src emacs-lisp
(use-package dired-open
  :if init-flag
  :straight t
  :bind (:map dired-mode-map
	      ("<return>" . dired-open-xdg)))
#+end_src
***** Async operations
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       06e9d624-67fe-42cb-acca-44c1e5e1fde1
:END:
#+BEGIN_SRC emacs-lisp
(use-package dired
  :if init-flag
  :init
  (use-package async
    :straight t
    :config
    (use-package dired-async))
  :hook (dired-mode . dired-async-mode))
#+END_SRC
***** TODO Follow symlink structure
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 15:42]
:ID:       3f656102-43d7-4a91-b245-92af4ffca9a6
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-23 Mon 15:45]
:END:

=dired-find-file= calls =find-file=, which calls =find-file-noselect=, which forces =abbreviate-file-name= to be applied.
It makes entering symlink in =~/Dropbox/Org/->~/Org= go into "~/Org".
As a result, =dired-up-directory= goes to =~/= instead of =~/Dropbox=.

Hence, I avoid =abbreviate-file-name= in =dired-find-file=.
Same for =dired-noselect= (called by =dired=, which is called by =dired-up-directory=).

#+BEGIN_SRC emacs-lisp
(define-advice dired-find-file (:around (OLDFUN &rest args) disable-abbreviate-file-name)
  "Disable `abbreviate-file-name' in dired."
  (cl-flet ((abbreviate-file-name (filename) ""
				  (if (f-directory? filename)
				      (f-slash filename)
                                    filename)))
    (apply OLDFUN args)))
(advice-add 'dired-noselect :around #'dired-find-file@disable-abbreviate-file-name)
#+END_SRC
***** Do not update mode-line info as in =dired+=
:PROPERTIES:
:CREATED:  [2020-07-15 Wed 09:23]
:ID:       d97e39ed-f771-4675-9cee-dd499e7f53e0
:END:

=diredp-nb-marked-in-mode-name= from =dired+= is very too slow.
Disabling it

#+begin_src emacs-lisp
(use-package dired+
  :if init-flag
  :after dired+
  :config
  (remove-hook 'dired-after-readin-hook 'diredp-nb-marked-in-mode-name)
  (remove-hook 'dired-mode-hook         'diredp-nb-marked-in-mode-name))

#+end_src



***** Appearance
****** COMMENT File icons
:PROPERTIES:
:CREATED:  [2019-08-27 Tue 17:18]
:ID:       942eca8c-c6e6-4c60-91b6-0e7cc0c6857b
:END:

*************** TODO Investigate how to avoid hangs on large folders
*************** END

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :if init-flag
  :straight t
  :diminish all-the-icons-dired-mode
  :hook (dired-mode . all-the-icons-dired-mode))
#+end_src
****** Highlight files
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 22:09]
:ID:       45393002-d153-42bf-ae39-70b6e49b25b0
:END:

Additional fontification in =dired=

#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :if init-flag
  :straight t
  :config
  (diredfl-global-mode 1))
#+END_SRC
****** Group files
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       18e2dd1e-dc25-4188-bad4-cdcdb76f506a
:END:

#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :if init-flag
  :straight t
  :custom (dired-filter-group-saved-groups '(("default"
					      ("Dirs"
					       (directory . nil))
					      ("Archives"
					       (extension "zip" "rar" "gz" "bz2" "tar"))
					      ("Documents"
					       (extension "org" "cfm" "pdf" "tex" "bib" "mobi" "fb2" "doc" "docx"))
					      ("Scripts"
					       (extension "gnuplot" "sh"))
					      ("Data"
					       (extension "txt" "hys" "xls" "xlsx"))
					      ("Images"
					       (extension "png" "jpg" "jpeg" "tiff" "tif"))
					      ("Videos"
					       (extension "avi" "mpeg" "mp4" "mkv"))
					      )))
  :hook (dired-mode . dired-filter-group-mode))
#+END_SRC

****** Hide uninteresting files
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 14:10]
:ID:       3b9c56de-390c-4daf-a582-9006f4d5e7c1
:END:
:LOGBOOK:
- Refiled on [2020-04-14 Tue 14:16]
:END:

Hide =dotfiles=

#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :if init-flag
  :straight t
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :bind (:map dired-mode-map
	      ("." . dired-hide-dotfiles-mode)))
#+END_SRC

Hide "." and ".." 

#+begin_src emacs-lisp
(use-package dired
  :custom (dired-listing-switches "-DlhGg"))
#+end_src

****** Hide details
:PROPERTIES:
:CREATED:  [2020-04-14 Tue 16:05]
:ID:       e92e4c8f-f8c8-4bdd-8389-3a4a34e8bd30
:END:

Do not hide symlink target when hiding details.
#+begin_src emacs-lisp
(use-package dired
  :if init-flag
  :custom (dired-hide-details-hide-symlink-targets nil))
#+end_src

**** Disk usage
:PROPERTIES:
:CREATED:  [2019-07-15 Mon 22:04]
:ID:       1b72898b-f2e1-4534-862e-143f30e16d3c
:END:

#+begin_src emacs-lisp
(use-package disk-usage
  :if init-flag
  :straight t)
#+end_src

Fix =ange-ftp= using =dired-listing-switches= even when ftp server does not accept them

#+begin_src emacs-lisp
(define-advice ange-ftp-ls (:around (oldfun file lsargs parse &optional no-error wildcard) force-default-ls-switches)
  "Always use -al in ftp."
  (unless (string= lsargs "-al")
    (setq lsargs "-al --dired"))
  (apply oldfun (list file "-al" parse no-error wildcard)))
#+end_src

*** TODO Bookmarks
:PROPERTIES:
:ID:       a3d45efd-52f8-44f7-a699-940033cba429
:END:
:LOGBOOK:
- Refiled on [2020-05-12 Tue 15:22]
- State "CANCELLED"  from "TODO"          [2020-04-09 Thu 17:22]
:END:

#+BEGIN_SRC emacs-lisp
(use-package bm
  :if init-flag
  :straight t
  :demand t

  :init
  ;; restore on load (even before you require bm)
  (setq bm-restore-repository-on-load t)

  :config

  (use-package helm-bm :straight t)

  ;; Allow cross-buffer 'next'
  (setq bm-cycle-all-buffers t)

  ;; highligh style
  (setq bm-highlight-style 'bm-highlight-line-and-fringe)
  (custom-set-faces '(bm-persistent-face ((t (:background "Lightyellow")))))
  (custom-set-faces '(bm-fringe-persistent-face ((t (:background "Lightyellow")))))

  ;; where to store persistant files
  (setq bm-repository-file "~/.emacs.d/bm-repository")

  ;; save bookmarks
  (setq-default bm-buffer-persistence t)

  ;; Loading the repository from file when on start up.
  (add-hook' after-init-hook 'bm-repository-load)

  ;; Saving bookmarks
  (add-hook 'kill-buffer-hook #'bm-buffer-save)

  ;; Saving the repository to file when on exit.
  ;; kill-buffer-hook is not called when Emacs is killed, so we
  ;; must save all bookmarks first.
  (add-hook 'kill-emacs-hook #'(lambda nil
                                 (bm-buffer-save-all)
                                 (bm-repository-save)))

  ;; The `after-save-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state.
  (add-hook 'after-save-hook #'bm-buffer-save)

  ;; Restoring bookmarks
  (add-hook 'find-file-hooks   #'bm-buffer-restore)
  (add-hook 'after-revert-hook #'bm-buffer-restore)

  ;; The `after-revert-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state. This hook might cause trouble when using packages
  ;; that automatically reverts the buffer (like vc after a check-in).
  ;; This can easily be avoided if the package provides a hook that is
  ;; called before the buffer is reverted (like `vc-before-checkin-hook').
  ;; Then new bookmarks can be saved before the buffer is reverted.
  ;; Make sure bookmarks is saved before check-in (and revert-buffer)
  (add-hook 'vc-before-checkin-hook #'bm-buffer-save)

  (use-package meta-functions
    :defer t
    :config
    (meta-defun meta-down-element :mode bm-show-mode bm-show-next)
    (meta-defun meta-up-element :mode bm-show-mode bm-show-prev))

  :bind (:map boon-command-map
	      ("N" . bm-toggle)
	      ("M-n" . bm-bookmark-annotate)
	      :map boon-insert-map
	      ("M-N" . bm-toggle)
	      ("C-M-N" . bm-toggle)
              :map boon-goto-map
              ("n" . bm-show)
              ("N" . helm-bm)
	      :map boon-forward-search-map
	      ("n" . bm-next)
              :map boon-backward-search-map
              ("n" . bm-previous)
              :map bm-show-mode-map
              ("<tab>" . bm-show-goto-bookmark)
              )
  )
#+END_SRC
*** COMMENT Hyperbole
:PROPERTIES:
:CREATED:  [2019-03-21 Thu 13:52]
:ID:       40c2aac3-517c-45cd-bfe4-aa5465e4c3e6
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2019-03-21 Thu 13:52]
:END:

#+begin_src emacs-lisp
(use-package hyperbole
  :if init-flag
  :straight t
  :config
  ;; (bind-key* "<tab>" #'action-key)
  ;; (bind-key* "<backtab>" #'assist-key)
  )
#+end_src
** Editing
:PROPERTIES:
:ID:       6d0859b5-5d38-42a6-a676-aebec0867681
:END:


*** Ingest primary selection from OS
:PROPERTIES:
:CREATED:  [2019-12-23 Mon 19:43]
:ID:       ffef4dc6-ed14-468a-acd1-4f54284ac37b
:END:

#+begin_src emacs-lisp
(when init-flag
  (setq select-enable-primary t)
  (setq save-interprogram-paste-before-kill t))
#+end_src

*** Boon - set =command state= from =insert state=
:PROPERTIES:
:ID:       94ed4714-1f9d-43f7-8ddc-74f855154b2c
:END:

The boon's default =ESC= key binding to go back to command state is too hard to press.
I prefer a key on home row. 
=M-l= have proven to be good enough for me.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-key "M-l" 'boon-set-command-state boon-insert-map))
#+end_src
*** Multiple cursors
:PROPERTIES:
:ID:       8cbda343-0d1f-4abd-92d1-75a22b0b8d3c
:END:

I use multiple cursors in very limited way. 
Mostly just one command - editing multiple lines from selection. 
Bind it to command mode in boon.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (use-package multiple-cursors
    :defer t
    :bind (:map boon-command-map
		("C-V" . mc/edit-beginnings-of-lines))))
#+end_src
*** Open current line
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 16:03]
:ID:       0d1d2022-e094-49b0-abc0-0957536690ee
:END:

This is one of the frequently used commands and I want it to be available from command state. 
However, org has its own version of open-line. 
So, I define a meta-function to make open-line work as correctly regardless of the mode.

#+BEGIN_SRC emacs-lisp
(use-package boon
  :if init-flag
  :config
  (meta-defun meta-open-line "Create an empty line above point." boon-open-line)
  (use-package org :config 
    (meta-defun meta-open-line :mode org-mode org-open-line))
  (bind-key "C-o" 'meta-open-line boon-command-map))
#+END_SRC

Also, don't break the current line if the cursor is in the middle of a line

#+begin_src emacs-lisp
(use-package simple
  :if init-flag
  :config
  (define-advice open-line (:before (&rest args) mote-to-beg-first)
    (beginning-of-line)))
#+end_src

*** Cut element at point
:PROPERTIES:
:CREATED:  [2020-04-13 Mon 13:55]
:ID:       eae5f592-a735-487e-b42c-52904c0e5fd7
:END:
:LOGBOOK:
- Refiled on [2020-04-14 Tue 15:47]
:END:

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (meta-defun meta-cut-element () "Cut element at point" kill-paragraph))
#+end_src

*** Query replace
:PROPERTIES:
:ID:       1825c53a-1f53-4da8-a2b0-04ddea8cc43e
:END:

Use a query replace version with nice highlights.

#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (use-package visual-regexp
    :straight t  
    :bind (:map boon-command-map
		("?" . vr/query-replace))))
#+end_src
*** Indent region
:PROPERTIES:
:ID:       703f08dd-3ad9-4eba-a60e-2ad4de642375
:END:

#+begin_src emacs-lisp
(when init-flag
  (bind-key* "C-<tab>" 'indent-region))
#+end_src
*** Aggressive indent
:PROPERTIES:
:ID:       f3eaeebf-fe50-4ec6-81ed-f42e8b7b71c6
:END:

Automatic indentation is handy to keep the code nice and readable.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :if init-flag
  :straight t
  :diminish aggressive-indent-mode
  :config
  (global-aggressive-indent-mode t))
#+end_src

Inhibit message that indentation is completed
#+begin_src emacs-lisp
(define-advice indent-region (:around (fun &rest args) silence)
  "Do not show meessages."
  (let ((inhibit-message t))
    (apply fun args)))
#+end_src

*** Delete backward key bindings
:PROPERTIES:
:ID:       c36d8b82-50ab-4097-a93a-56cbcf376cee
:END:

Deleting a char/word backward is pretty common command when typing.
However, <DEL> key is too far on keyboard. 
I prefer something on home row - =C-h= and =C-M-h=.

#+begin_src emacs-lisp
(when init-flag
  (bind-keys ("C-M-h" . backward-kill-word)
	     ("C-h" . backward-delete-char-untabify)
             :map isearch-mode-map
	     ("C-h" . isearch-delete-char)
             ("C-M-h" . isearch-delete-char)))
#+end_src
*** Smarter =backward-kill-word=
:PROPERTIES:
:CREATED:  [2019-07-29 Mon 21:58]
:ID:       533e507c-2f3a-48cf-8a50-240d306a43f0
:END:

From [[https://www.reddit.com/r/emacs/comments/bz9rxn/weekly_tipstricketc_thread/er0bgll/][reddit]].

#+begin_src emacs-lisp
(when init-flag

    (defun user/smarter-backward-kill-word ()
      "Deletes the previous word, respecting:
1. If the cursor is at the beginning of line, delete the '\n'.
2. If there is only whitespace, delete only to beginning of line.
3. If there is whitespace, delete whitespace and check 4-5.
4. If there are other characters instead of words, delete one only char.
5. If it's a word at point, delete it."
      (interactive)

      (if (bolp)
	  ;; 1
	  (delete-char -1)

	(if (string-match-p "^[[:space:]]+$"
                            (buffer-substring-no-properties
                             (line-beginning-position) (point)))
            ;; 2
            (delete-horizontal-space)

	  (when (thing-at-point 'whitespace)
            ;; 3
            (delete-horizontal-space))

	  (if (thing-at-point 'word)
              ;; 5
              (let ((start (car (bounds-of-thing-at-point 'word)))
                    (end (point)))
		(if (> end start)
                    (delete-region start end)
		  (delete-char -1)))
            ;; 4
            (delete-char -1)))))
  (bind-key [remap backward-kill-word] #'user/smarter-backward-kill-word))
#+end_src

*** Return key
:PROPERTIES:
:ID:       ce7df944-6c64-4a7d-8e11-136237250e3c
:END:
*************** TODO adjust keybindings to avoid interference with WM
*************** END

Meta-versions of return/return-dwim commands.
Mostly intended to use with org.

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-j") (kbd "<RET>"))

(use-package meta-functions
  :if init-flag
  :config
  (use-package boon
    :bind (:map boon-command-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line)
                :map boon-insert-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line))))
#+end_src
*** Do no yank with mouse, but use Shift-Ins to yank the primary selection
:PROPERTIES:
:ID:       88a3703a-21fe-47a1-9b8c-bce7fdb5d10a
:END:

I do not use mouse as much as possible and discourage myself to use it unnecessarily.

#+begin_src emacs-lisp
(when init-flag
  (bind-key "<S-insert>" (lambda () (interactive)
			   (insert (gui-get-primary-selection))))
  (bind-key "<mouse-2>" #'ignore))
#+end_src
*** Move lines, elements around
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 15:00]
:ID:       61ed40af-8165-4ffa-9412-96d802bb8e18
:END:

#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (use-package move-text
    :straight t
    :bind (:map boon-command-map
		("M-j" . meta-move-line-down)
		("M-k" . meta-move-line-up)
		("M-J" . meta-move-element-down)
		("M-K" . meta-move-element-up)
		("M-O" . meta-move-element-right)
		("M-I" . meta-move-element-left)
		("M-o" . meta-move-line-right)
		("M-i" . meta-move-line-left)
                :map boon-special-map
                ("M-j" . meta-move-line-down)
		("M-k" . meta-move-line-up)
		("M-J" . meta-move-element-down)
		("M-K" . meta-move-element-up)
		("M-O" . meta-move-element-right)
		("M-I" . meta-move-element-left)
		("M-o" . meta-move-line-right)
		("M-i" . meta-move-line-left))
    :config
    (meta-defun-mapc '((meta-move-line-right "Move the line under cursor right." ignore)
		       (meta-move-line-left "Move the line under cursor left." ignore)
		       (meta-move-line-up "Move the line under cursor up." move-text-line-up)
		       (meta-move-line-down "Move the line under cursor down." move-text-line-down)
		       (meta-move-element-right "Move the element under cursor right." ignore)
		       (meta-move-element-left "Move the element under cursor left." ignore)
		       (meta-move-element-down "Move the element under cursor down." move-text-down)
		       (meta-move-element-up "Move the element under cursor up." move-text-up))))
  :init (use-package boon))
#+END_SRC
*** =Yasnippet=
:PROPERTIES:
:CREATED:  [2019-08-07 Wed 10:53]
:ID:       800d19f3-bbce-4a3c-888d-d8b6ac34eb81
:END:

=Yasnippet= is a very handy way to use templates as you type.
There is also built-in skeleton mode, but =yasnippet= also has a good user-contributed snippet database.
 
*************** TODO study the snippets
*************** END

#+begin_src emacs-lisp
(use-package yasnippet
  :if init-flag
  :straight t
  :diminish (yas-minor-mode . " ⇶_")
  :hook ((org-mode latex-mode markdown-mode prog-mode lisp-interaction-mode) . yas-minor-mode)
  :config
  (use-package yasnippet-snippets
    :straight t))
#+end_src

*** Undo

**** Undo-tree 
:PROPERTIES:
:CREATED:  [2020-01-20 Mon 10:34]
:ID:       8b8023ed-03c8-4aa7-a47e-6195f94bc63d
:END:

Tree view of emacs undo history.
Very useful to undo and redo after complex edits.

#+begin_src emacs-lisp
(use-package undo-tree
  :straight t
  :diminish undo-tree-mode
  :custom 
  (undo-tree-auto-save-history nil) ;; disabling since it causes cryptic error
  :config
  (global-undo-tree-mode +1))
#+end_src

Add meta-bindings

#+begin_src emacs-lisp
(use-package meta-functions
  :after undo-tree 
  :config
  (meta-defun meta-up :mode undo-tree-visualizer-mode undo-tree-visualize-undo)
  (meta-defun meta-down :mode undo-tree-visualizer-mode undo-tree-visualize-redo)
  (meta-defun meta-forward :mode undo-tree-visualizer-mode undo-tree-visualize-switch-branch-right)
  (meta-defun meta-backward :mode undo-tree-visualizer-mode undo-tree-visualize-switch-branch-left))
#+end_src

*** SOMEDAY Editing outside emacs
:PROPERTIES:
:CREATED:  [2019-08-25 Sun 19:56]
:ID:       b8575b61-511d-482b-ae5b-bd542db5f443
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 14:49]--[2020-04-23 Thu 14:50] =>  0:01
:END:

=emacs-anywhere= allows to invoke emacs for editing in any other application

#+begin_src emacs-lisp
(use-package emacs_anywhere
  :disabled t
  :straight (emacs_anywhere :type git :host github :repo "zachcurry/emacs-anywhere"))
#+end_src
*** Fill/unfill paragraph
:PROPERTIES:
:CREATED:  [2019-12-25 Wed 15:20]
:ID:       596fe5bd-824f-4706-a2b5-d4decb90511e
:END:

Interactive fill/unfill paragraph at point.

#+begin_src emacs-lisp
(when init-flag
    ;; https://github.com/jethrokuan/.emacs.d/blob/master/init.el
    (defun endless/fill-or-unfill ()
      "Like `fill-paragraph', but unfill if used twice."
      (interactive)
      (let ((fill-column
             (if (eq last-command 'endless/fill-or-unfill)
		 (progn (setq this-command nil)
			(point-max))
               fill-column)))
	(call-interactively #'fill-paragraph)))
  (use-package boon
    :defer t
    :bind (:map boon-command-map
		("q" . endless/fill-or-unfill))))
#+end_src
** Debugging
:PROPERTIES:
:ID:       749e7414-827f-45cb-9ee0-19637eb2274e
:END:
*** Command loop
:PROPERTIES:
:CREATED:  [2020-04-23 Thu 14:44]
:END:
**** Debug on error
:PROPERTIES:
:ID:       1b3bb071-a145-43ef-826a-25dacb4c5cc2
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-12-19 Tue 08:53]
:END:
#+begin_src emacs-lisp
(when init-flag
  (setq debug-on-error t)
  (setq debug-on-quit nil)
  (setq debug-ignored-errors '(beginning-of-line
			       beginning-of-buffer
			       end-of-line
			       end-of-buffer
			       end-of-file
			       buffer-read-only
			       quit
			       file-supersession
			       mark-inactive
			       user-error
                               search-failed
			       file-missing
                               file-date-error
                               "Already at top level of the outline"
			       "Attempt to delete the sole visible or iconified frame"
                               "No such page"
                               "use-package: :[a-z]+ wants"
                               "The mark is not set now, so there is no region"
                               "Search string not set"
			       "use-package: Unrecognized keyword"
			       "No more buttons"
                               "No command bound to"
			       )))
#+end_src
**** Debugger key bindings
:PROPERTIES:
:ID:       cbca9cd1-9225-45b5-aa88-43ff09f128e5
:END:
#+begin_src emacs-lisp
  (use-package debug
    :if init-flag
    :config
    (bind-key "s" #'debugger-continue debugger-mode-map))
#+end_src
*** Appearance
:PROPERTIES:
:CREATED:  [2020-04-23 Thu 14:44]
:END:
**** Use visible bell
:PROPERTIES:
:ID:       83e9e494-8646-4118-a574-b35026acd582
:END:

Visible bell saved me from surprise prompts many times.

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

Do not ring the bell when I quit some command via =C-g= or =ESC=.
Credit: [[id:c0dea452-4742-4355-a0ff-063131c89a6d][bradwright/emacs.d: My Emacs configuration]]
#+begin_src emacs-lisp
(setq ring-bell-function
      (lambda ()
        "Only rings the bell if it's not a valid quit case, e.g
keyboard-quit"
        (unless (memq this-command
                      '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
          (ding))))
#+end_src
**** =(expr ...)= instead of =expr( ... )= in debugger
:PROPERTIES:
:CREATED:  [2019-08-11 Sun 15:18]
:ID:       bbf1433b-ed85-4597-aafb-2a8bb4c1cf4a
:END:

From: https://github.com/cadadr/configuration/blob/master/emacs.d/init.el

#+begin_src emacs-lisp
(when init-flag
  (setq
   ;; (expr ...) not expr(...)
   debugger-stack-frame-as-list t))
#+end_src
*** Lorem ipsum
:PROPERTIES:
:CREATED:  [2019-08-15 Thu 22:10]
:ID:       3d17a7be-9f76-4016-92e4-a55205183d97
:END:

Sometimes, I just need to have any random text in buffer for testing.

#+begin_src emacs-lisp
(use-package lorem-ipsum
  :if init-flag
  :straight t)
#+end_src
*** Bug hunting in =init.el=
:PROPERTIES:
:ID:       fa3afe58-87b9-4230-a9a6-298be9f6998d
:END:
:LOGBOOK:
- Refiled on [2020-04-27 Mon 15:06]
:END:

#+begin_src emacs-lisp
(use-package bug-hunter
  :if init-flag
  :straight t)
#+end_src
*** Hunt for the commands causing hangs
:PROPERTIES:
:CREATED:  [2020-05-25 Mon 18:45]
:ID:       e55d91e3-562c-465b-a564-82729edad44d
:END:

#+begin_src emacs-lisp
(use-package explain-pause-mode
  :if init-flag
  :demand t
  :straight (explain-pause-mode :host github :repo "lastquestion/explain-pause-mode")
  :custom (explain-pause-blocking-too-long-ms 400)
  :config
  ;; (diminish 'explain-pause-mode " ⌚")
  (diminish 'explain-pause-mode (s-concat " "
					  (propertize (all-the-icons-material "watch" :v-adjust 0.04)
						      'face `((
							       :family "Material Icons"
							       ;; :height 1.1
                                                               ))
						      ;; 'display '(raise -0.1)
                                                      )))
  (explain-pause-mode +1))
#+end_src
*** Debugging of font-lock
:PROPERTIES:
:CREATED:  [2020-07-28 Tue 17:46]
:ID:       e8ad6617-d24c-4dfe-8f28-e6336e4c7787
:END:

By default, font-locking is not debuggable because all the errors thrown by fontification functions are catched and cause the functions to be removed. It indeed makes sense since errors in fontification functions can easily hang Emacs. However, it makes debugging such functions very difficult.

Here is the solution: [[id:d3ad021d-475f-48d6-9b80-315dbff60322][Lindydancer/font-lock-studio: Debugger for Font Lock keywords]]
Just invoke =M-x font-lock-studio= for interactive debugging.

#+begin_src emacs-lisp
(use-package font-lock-studio
  :if init-flag
  :straight (font-lock-studio :type git :host github :repo "Lindydancer/font-lock-studio"))
#+end_src

The same author also wrote font-lock profiler: [[id:github_lindydancer_lindy_font_lock_profil_cover][Lindydancer [Github] Lindydancer Font-Lock-Profiler: Coverage and Timing Tool for Font-Lock Keywords]]

#+begin_src emacs-lisp
(use-package font-lock-profiler
  :if init-flag
  :straight (font-lock-profiler :type git :host github :repo "Lindydancer/font-lock-profiler"))
#+end_src

** Programming & emacsing
:PROPERTIES:
:ID:       e2ea50c3-b8da-433e-a5f9-74d8ef91d807
:END:
*** Emacs help

There are various ways Emacs can assist on getting documentation.

**** Symbol&info lookup
:PROPERTIES:
:ID:       e48bff0a-518d-4499-a62d-7003d203077a
:END:

Quick documentation access is one of the most powerful features of emacs.
=Helm= makes searching the documentation lightning fast.
We can search:
 - functions, variables, other symbols
 - =.el= files
 - key bindings
 - info entries for anything
 - man entries

The default =elisp= info search does not include many useful libraries like =cl-lib=, =dash=, or =EIEIO.
I rely on the search so much that I, for example, did not even know about =cl-lib= for a long time and still struggling to use it efficiently.
Expanding =helm= completion to include everything.
 #+begin_src emacs-lisp
(when init-flag
;;Modified from https://www.reddit.com/r/emacs/comments/e5dzv6/weekly_tipstricketc_thread/f9xug5q/
  (defun helm-info-elisp-and-libs ()
    "Helm for Emacs, Elisp, and CL-library info pages."
    (interactive)
    (helm :sources '(helm-source-info-dash
		     helm-source-info-eieio
		     helm-source-info-elisp
                     helm-source-info-cl))))
 #+end_src

Similarly, many emacs features are hidden in separate info nodes.
 #+begin_src emacs-lisp
(when init-flag
  (defun helm-info-emacs-and-extra ()
    "Helm for Emacs, Elisp, and CL-library info pages."
    (interactive)
    (helm :sources '(helm-source-info-emacs
                     helm-source-info-autotype
                     helm-source-info-magit
                     helm-source-info-tramp))))
 #+end_src

Explore loaded library files

#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :bind (("<f1> l" . helm-locate-library)))
#+end_src




**** Man
:PROPERTIES:
:ID:       45d67bee-9fa3-4c00-8f48-2b41ed03ea46
:END:
#+begin_src emacs-lisp
(use-package woman
  :if init-flag
  :commands woman
  :config
  (use-package meta-functions
    :config
    (meta-defun meta-down-element :mode woman-mode Man-next-section)
    (meta-defun meta-up-element :mode woman-mode Man-previous-section)))
#+end_src
**** TL;DR - short practical version of man
:PROPERTIES:
:CREATED:  [2019-01-20 Sun 02:28]
:ID:       fd10055f-2a65-4c7e-a1e9-3d95e7d8ea72
:END:

#+begin_src emacs-lisp
(use-package tldr
  :if init-flag
  :straight t)
#+end_src

**** Appearance
:PROPERTIES:
:CREATED:  [2020-04-27 Mon 15:19]
:END:
***** COMMENT Info+
:PROPERTIES:
:CREATED:  [2019-07-26 Fri 21:36]
:ID:       e75f029b-943d-4600-933b-e76ceb98f501
:END:
Better info pages (see [[https://onlinelibrary.wiley.com/doi/abs/10.1002/adem.201900474][emacswiki]]). Specifically, the package improves the highlighting.

#+begin_src emacs-lisp
(use-package info+
  :if init-flag
  :straight (info+ :host github :repo "emacsmirror/emacswiki.org"))
#+end_src
***** Helpful - better help buffers
:PROPERTIES:
:CREATED:  [2018-03-29 Thu 23:16]
:ID:       00d36901-9a96-46c3-be8b-6fe5edd9c3c7
:END:
For the =elisp= built-in docstrings, =helpful= package extension with very useful.
It provides extra functionality to the standard =help= buffers.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :if init-flag
  :straight t)
#+END_SRC
***** Elisp demos
:PROPERTIES:
:CREATED:  [2019-08-15 Thu 12:17]
:ID:       4e508904-0543-474c-956a-85e56506f403
:END:

Another package =elisp-demos= extends =helpful= even further providing examples to many standard functions.

#+begin_src emacs-lisp
(use-package elisp-demos
  :if init-flag
  :straight t
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src
**** Command loop
:PROPERTIES:
:CREATED:  [2020-04-27 Mon 15:19]
:END:
***** Explore keymaps
:PROPERTIES:
:CREATED:  [2020-04-28 Tue 11:34]
:ID:       d4a815d0-a548-4913-b47e-a500282624ca
:END:

#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :config
  (use-package helm-descbinds :straight t))
#+end_src
***** Show the continuation of unfinished keybindings
:PROPERTIES:
:ID:       af18cad7-734f-491f-85a8-1fc817cf2dbd
:END:
#+begin_src emacs-lisp
(use-package which-key
  :if init-flag
  :straight t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+end_src
***** Help buffer navigation
:PROPERTIES:
:ID:       2bc3b25c-9754-4bce-a885-8d8b1300b6cc
:END:
#+begin_src emacs-lisp
(use-package boon
  :defer t
  :if init-flag
  :config
  (use-package meta-functions
    :config
    (meta-defun meta-next-buffer :mode help-mode help-go-forward)
    (meta-defun meta-previous-buffer :mode help-mode help-go-back)))
#+end_src
***** Info buffer navigation
:PROPERTIES:
:CREATED:  [2018-07-11 Wed 14:55]
:ID:       924cdc83-3ddc-4ef1-ae8d-8ca57682d389
:END:
#+begin_src emacs-lisp
(use-package boon
  :defer t
  :if init-flag
  :config
  (use-package meta-functions
    :config
    (meta-defun meta-down-element :mode Info-mode Info-forward-node)
    (meta-defun meta-up-element :mode Info-mode Info-backward-node)
    (meta-defun meta-new-line :mode Info-mode Info-follow-nearest-node)
    (meta-defun meta-previous-buffer :mode Info-mode Info-history-back)
    (meta-defun meta-next-buffer :mode Info-mode Info-history-forward)))
#+end_src
***** Global key bindings
:PROPERTIES:
:CREATED:  [2020-04-28 Tue 11:37]
:ID:       88eacd5b-812b-462c-8aa3-144b66ceb697
:END:

#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :init
  (use-package boon
    :defer t
    :config
    (bind-keys :map boon-goto-map
	       ("k" . helpful-key)
	       ("f" . helpful-callable)
	       ("v" . helpful-at-point)
	       ("d" . helpful-variable)
	       ("s" . helpful-symbol)
	       ("b" . helm-descbinds)
	       ("h m" . woman)
	       ("h n" . tldr)
	       ("h i" . helm-info-elisp-and-libs)
	       ("h o" . helm-info-org)
	       ("h e" . helm-info-emacs-and-extra)
	       ("h t" . helm-info-auctex)
	       ("h T" . helm-info-texinfo))))
#+end_src

*** Elisp coding
:PROPERTIES:
:CREATED:  [2019-07-08 Mon 20:50]
:END:
**** =Paredit=
:PROPERTIES:
:CREATED:  [2020-03-22 Sun 21:43]
:ID:       e802659e-0d50-4658-95b6-fdfe2f4b65f1
:END:
:LOGBOOK:
- Refiled on [2020-04-23 Thu 14:42]
:END:

Smarter elisp editing

#+begin_src emacs-lisp
  (use-package paredit
    :if init-flag
    :straight t
    :diminish (paredit-mode . " (⤑)")
    :demand t ;; I need it in scratch buffer
    :hook ((lisp-mode lisp-interaction-mode emacs-lisp-mode) . paredit-mode)
    :config
    (use-package boon
      :defer t
      :after meta-functions
      :config
      (meta-defun meta-move-line-right :mode emacs-lisp-mode paredit-forward-slurp-sexp)
      (meta-defun meta-move-line-right :mode lisp-interaction-mode paredit-forward-slurp-sexp)
      (meta-defun meta-move-line-left :mode emacs-lisp-mode paredit-backward-slurp-sexp)
      (meta-defun meta-move-line-left :mode lisp-interaction-mode paredit-backward-slurp-sexp)
      (meta-defun meta-forward-element :mode emacs-lisp-mode paredit-forward)
      (meta-defun meta-backward-element :mode emacs-lisp-mode paredit-backward)
      (bind-keys :map boon-insert-map
		 ("M-o" . meta-move-line-right)
		 ("M-i" . meta-move-line-left))))
#+end_src
**** Font-lock based namespace for writing modes
:PROPERTIES:
:ID:       5b5c84f0-e363-4e5c-b373-69ddf019f9e3
:END:


The convention for writing Emacs packages is using the package name as prefix for every dynamically scoped variable in the package. 
The result is useful to avoid mess in the global variables, but also makes the variable and function names too long. 
=nameless= provides a convenient way to hide those long prefixes.

#+begin_src emacs-lisp
(use-package nameless
  :if init-flag
  :straight t
  :diminish (nameless-mode . "::")
  :init
  (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
  :config
  (setq nameless-private-prefix t)
  (bind-key "_" #'nameless-insert-name-or-self-insert nameless-mode-map))
#+end_src
**** Show elisp result in overlay
:PROPERTIES:
:CREATED:  [2019-07-20 Sat 19:34]
:ID:       35974311-ca9b-4626-a0eb-47294ccb37b2
:END:

#+begin_src emacs-lisp
(use-package eros
  :if init-flag
  :straight t
  :hook ((lisp-mode lisp-interaction-mode emacs-lisp-mode) . eros-mode))
#+end_src

**** COMMENT Improved interactive evaluation of elisp code
:PROPERTIES:
:CREATED:  [2018-07-14 Sat 00:42]
:ID:       08ca8dd5-a692-470f-97fd-5e46f8255a90
:END:
1. Evaluating Quoted Expressions
2. Evaluating Function Symbols
3. Redefining Variables
4. Default Expressions to Evaluate
5. Editing Default Expressions

#+BEGIN_SRC emacs-lisp
  (use-package rsw-elisp
    :if init-flag
    :straight (rsw-elisp :host github :repo "rswgnu/rsw-elisp")
    :config
    (rsw-elisp-enable))
#+END_SRC

**** Smart redefining functions
:PROPERTIES:
:CREATED:  [2020-04-01 Wed 21:28]
:ID:       39680274-85c7-4480-bc27-210c4e397655
:END:

Sometimes, advises and hooks are simply not enough to alter existing functions.
The only resort then is redefining the whole function.
However, it can break updated packages if something changes in the original function implementation.
*************** TODO Actually, same can sometimes happen with advises. Is there a way to deal with it?
*************** END
=El-patch= allow changing the whole function definition without a risk to break anything. 
It warns me if the original definition changes from what I expect.

#+begin_src emacs-lisp
(use-package el-patch
  :straight t
  :demand t)
#+end_src

*** Scripts
:PROPERTIES:
:CREATED:  [2020-05-14 Thu 14:39]
:END:

**** Set executable flag in all the script files
:PROPERTIES:
:CREATED:  [2019-12-25 Wed 13:52]
:ID:       09ca1291-739f-4949-a7bc-4cb50303c364
:END:

#+begin_src emacs-lisp
(when init-flag
;; stolen from https://github.com/jethrokuan/.emacs.d/blob/master/init.el
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p))
#+end_src

*** Gnuplot
:PROPERTIES:
:ID:       192254a2-dc90-4a29-a713-f43f794211f6
:END:
#+begin_src emacs-lisp
(use-package gnuplot
  :if (or init-flag org-export-flag)
  :straight t
  :mode ("\\.\\(gp\\|gnuplot\\|plot\\)$" . gnuplot-mode))
#+end_src
*** Lua
:PROPERTIES:
:CREATED:  [2019-12-05 Thu 15:17]
:ID:       2cfb9df1-22b4-4c4a-bc68-535e3093b649
:END:

#+begin_src emacs-lisp
(use-package lua-mode
  :if init-flag
  :straight t)
#+end_src

** LaTeX
:PROPERTIES:
:ID:       2fb97bdf-d310-4e5a-8266-d68a1ae10298
:END:

*************** HOLD [#A] revise config from here                                                                     :HOLD:
:PROPERTIES:
:SHOWFROMDATE: 2020-05-13 18:00
:SUMMARY:  Later, when I do not have more important emacs things to do
:END:
:LOGBOOK:
- State "HOLD"       from "DOING"         [2020-05-13 Wed 21:56] \\
  Later, when I do not have more important emacs things to do
CLOCK: [2020-05-05 Tue 23:50]--[2020-05-06 Wed 00:09] =>  0:19
CLOCK: [2020-05-05 Tue 22:45]--[2020-05-05 Tue 23:06] =>  0:21
CLOCK: [2020-05-05 Tue 22:21]--[2020-05-05 Tue 22:45] =>  0:24
CLOCK: [2020-05-05 Tue 22:18]--[2020-05-05 Tue 22:20] =>  0:02
CLOCK: [2020-05-04 Mon 22:42]--[2020-05-04 Mon 22:51] =>  0:09
CLOCK: [2020-04-28 Tue 11:32]--[2020-04-28 Tue 11:50] =>  0:18
CLOCK: [2020-04-27 Mon 15:17]--[2020-04-27 Mon 15:20] =>  0:03
CLOCK: [2020-04-27 Mon 15:03]--[2020-04-27 Mon 15:16] =>  0:13
CLOCK: [2020-04-23 Thu 14:35]--[2020-04-23 Thu 14:49] =>  0:14
CLOCK: [2020-04-22 Wed 22:52]--[2020-04-22 Wed 23:07] =>  0:15
CLOCK: [2020-04-21 Tue 23:12]--[2020-04-21 Tue 23:14] =>  0:02
CLOCK: [2020-04-20 Mon 21:21]--[2020-04-20 Mon 21:22] =>  0:01
CLOCK: [2020-04-20 Mon 20:56]--[2020-04-20 Mon 21:21] =>  0:25
CLOCK: [2020-04-20 Mon 20:47]--[2020-04-20 Mon 20:56] =>  0:09
CLOCK: [2020-04-17 Fri 16:30]--[2020-04-17 Fri 16:59] =>  0:29
CLOCK: [2020-04-14 Tue 14:08]--[2020-04-14 Tue 15:00] =>  0:52
CLOCK: [2020-04-12 Sun 19:54]--[2020-04-12 Sun 19:55] =>  0:01
CLOCK: [2020-04-09 Thu 16:49]--[2020-04-09 Thu 17:43] =>  0:54
CLOCK: [2020-04-08 Wed 13:57]--[2020-04-08 Wed 14:00] =>  0:03
CLOCK: [2020-04-02 Thu 13:30]--[2020-04-02 Thu 13:40] =>  0:10
CLOCK: [2020-03-30 Mon 22:39]--[2020-03-30 Mon 23:07] =>  0:28
- State "DONE"       from "DOING"      [2019-12-19 Thu 13:06]
CLOCK: [2019-12-19 Thu 12:55]--[2019-12-19 Thu 13:06] =>  0:11
CLOCK: [2019-12-18 Wed 16:26]--[2019-12-18 Wed 16:46] =>  0:20
CLOCK: [2019-12-10 Tue 22:29]--[2019-12-10 Tue 22:31] =>  0:02
CLOCK: [2019-12-09 Mon 16:27]--[2019-12-09 Mon 20:45] =>  4:18
CLOCK: [2019-12-09 Mon 13:01]--[2019-12-09 Mon 16:26] =>  3:25
CLOCK: [2019-12-05 Thu 12:17]--[2019-12-05 Thu 13:59] =>  1:42
:END:
*************** END

Nowadays, I do not really write pure LaTeX, but rather use org-mode export.
The below configuration is here just in case if I need to open and edit tex files for some reason.

*** =Auctex=
:PROPERTIES:
:CREATED:  [2020-03-30 Mon 14:09]
:ID:       be8768df-105f-49dd-92e7-fa91d393a9bf
:END:

This is also required for =cdlatex= to work with org-mode. 

#+begin_src emacs-lisp
(use-package latex
  :if init-flag
  :straight auctex
  :custom
  (TeX-auto-save t)
  (TeX-parse-self t))
#+end_src
*** Use =pdf-tools= to view resulting pdf
:PROPERTIES:
:ID:       a0515bfd-07df-418a-90a2-5515b1a4deb3
:END:
#+begin_src emacs-lisp
(when init-flag
  (setq TeX-view-program-list '(("pdf tools refresh" (lambda() (pdf-tools-install)
						       (TeX-pdf-tools-sync-view)))))
  (setq TeX-view-program-selection '((output-pdf "pdf tools refresh")))
  (setq TeX-source-correlate-start-server t))
#+end_src

** Ledger
:PROPERTIES:
:ID:       a0cacc17-641c-4b29-86b2-7dcf609cd803
:END:
#+begin_src emacs-lisp
(use-package ledger-mode
  :if init-flag
  :straight t
  :bind (:map boon-goto-map
	      ("z" . open-finance)
	      :map ledger-mode-map
	      ("M-n" . nil)
	      ("M-p" . nil)
	      ("C-c C-a" . ledger-add-transaction-and-boonedit))
  :config
  (defun open-finance()
    "Open ledger file."
    (interactive)
    (find-file "~/Finance/Singapore-PhD/Ledger.dat"))
  (defun ledger-add-transaction-and-boonedit ()
    "Switch to boon insert state when adding transaction."
    (interactive)
    (call-interactively 'ledger-add-transaction)
    (boon-set-insert-like-state))
  (setq ledger-reports
	'(("bal" "ledger --pedantic -f %(ledger-file) bal not Equity")
	  ("balsg" "ledger --pedantic -f %(ledger-file) bal not Equity -X S$")
	  ("balcny" "ledger --pedantic -f %(ledger-file) bal not Equity -X CNY")
	  ("balall" "ledger --pedantic -f %(ledger-file) bal not Equity:Opening")
	  ("reg" "ledger --pedantic --pending -f %(ledger-file) reg not Equity")
	  ("payee" "ledger --pedantic -f %(ledger-file) reg @%(payee)")
	  ("account" "ledger --pedantic -f %(ledger-file) reg %(account)")
	  ("budget" "ledger --pedantic -f %(ledger-file) bal --budget")
          ("budgetcny" "ledger --pedantic -f %(ledger-file) bal --budget -X CNY")
	  ("budgetsg" "ledger --pedantic -f %(ledger-file) bal --budget -X S$"))
	ledger-report-auto-refresh t)
  (use-package meta-functions
    :config
    (meta-defun meta-down-element :mode ledger-mode ledger-navigate-next-xact-or-directive)
    (meta-defun meta-up-element :mode ledger-mode ledger-navigate-prev-xact-or-directive))
  )
#+END_SRC

*** Do not end the completions with string
:PROPERTIES:
:CREATED:  [2019-03-23 Sat 07:31]
:ID:       af89ed91-0fc7-4d03-b08a-478c08ad0558
:END:

#+begin_src emacs-lisp
(when init-flag
  (add-hook 'ledger-mode-hook (lambda () (setq-local pcomplete-termination-string ""))))
#+end_src
*** Complete in steps
:PROPERTIES:
:CREATED:  [2019-07-23 Tue 09:33]
:ID:       43baaeec-565a-4cb8-b450-1221e3306399
:END:

#+begin_src emacs-lisp
(use-package ledger-mode
  :if init-flag
  :defer t
  :config
  (setq ledger-complete-in-steps t))
#+end_src

** Wolfram Mathematica
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 17:37]
:ID:       fbacbe1c-3e5c-47f0-9e2d-e6e5bde1fa5c
:END:
#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :if init-flag
  :straight t
  )
#+END_SRC
** TODO Pdf view
:PROPERTIES:
:ID:       201475d1-64b3-4e1d-8e78-d850c6067761
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :straight (pdf-tools :type git :host github :repo "politza/pdf-tools"
		  :fork (:host github
			       :repo "yantar92/pdf-tools"))
  :magic ("%PDF" . pdf-view-mode)
  :bind (:map pdf-view-mode-map
	      ("v w" . pdf-view-fit-width-to-window)
	      ("v h" . pdf-view-fit-height-to-window))
  :init
  (defun yant/pdf-view-down nil
    "Go down document in pdf-view."
    (interactive)
    (pdf-view-next-line-or-next-page 5))
  (defun yant/pdf-view-up nil
    "Go up document in pdf-view."
    (interactive)
    (pdf-view-previous-line-or-previous-page 5))
  (use-package pdf-annot)
  (use-package pdf-occur)
  (use-package pdf-history)
  (use-package pdf-links)
  (use-package pdf-outline)
  (use-package pdf-sync)
  (use-package pdf-isearch)
  (use-package pdf-cache)
  :config
  (pdf-tools-install)
  (add-hook 'pdf-view-mode-hook #'pdf-view-fit-width-to-window 'APPEND)
  (add-hook 'pdf-view-mode-hook #'pdf-tools-enable-minor-modes 'APPEND)
  (use-package meta-functions
    :config
    (meta-defun meta-down :mode pdf-view-mode yant/pdf-view-down)
    (meta-defun meta-up :mode pdf-view-mode yant/pdf-view-up)
    (meta-defun meta-scroll-down :mode pdf-view-mode pdf-view-scroll-down-or-previous-page)
    (meta-defun meta-scroll-up :mode pdf-view-mode pdf-view-scroll-up-or-next-page)
    (meta-defun meta-down :mode pdf-annot-list-mode tablist-next-line)
    (meta-defun meta-up :mode pdf-annot-list-mode tablist-previous-line)))
#+end_src

*** Restore the last position in pdf
:PROPERTIES:
:CREATED:  [2019-07-22 Mon 22:25]
:ID:       298073df-f1e0-4a57-ac78-65ab17582ead
:END:

#+begin_src emacs-lisp
(use-package pdf-view-restore
  :if init-flag
  :straight t
  :after pdf-tools
  :config
  (add-hook 'pdf-view-mode-hook 'pdf-view-restore-mode)
  (setq pdf-view-restore-filename "~/.emacs.d/.pdf-view-restore"))
#+end_src

*** Pdf rotate
:PROPERTIES:
:ID:       0ec2a69c-4284-48f2-86cb-4bac1f0a3b3f
:END:
#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :init
  (use-package pdf-view :demand t)
  (defun pdf-view--rotate (&optional counterclockwise-p page-p)
    "Rotate PDF 90 degrees.  Requires pdftk to work.\n
       Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
       non-nil for the other direction.  Rotate the whole document by
       default; set PAGE-P to non-nil to rotate only the current page.
       \nWARNING: overwrites the original file, so be careful!"
    ;; error out when pdftk is not installed
    (if (null (executable-find "pdftk"))
	(error "Rotation requires pdftk")
      ;; only rotate in pdf-view-mode
      (when (eq major-mode 'pdf-view-mode)
	(let* ((rotate (if counterclockwise-p "left" "right"))
	       (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
	       (page   (pdf-view-current-page))
	       (pages  (cond ((not page-p)                        ; whole doc?
			      (format "1-end%s" rotate))
			     ((= page 1)                          ; first page?
			      (format "%d%s %d-end"
				      page rotate (1+ page)))
			     ((= page (pdf-info-number-of-pages)) ; last page?
			      (format "1-%d %d%s"
				      (1- page) page rotate))
			     (t                                   ; interior page?
			      (format "1-%d %d%s %d-end"
				      (1- page) page rotate (1+ page))))))
	  ;; empty string if it worked
	  (if (string= "" (shell-command-to-string
			   (format (concat "pdftk %s cat %s "
					   "output %s.NEW "
					   "&& mv %s.NEW %s")
				   file pages file file file)))
	      (pdf-view-revert-buffer nil t)
	    (error "Rotation error!"))))))
  (defun pdf-view-rotate-clockwise (&optional arg)
    "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
       entire document."
    (interactive "P")
    (pdf-view--rotate nil (not arg)))
  (defun pdf-view-rotate-counterclockwise (&optional arg)
    "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
       rotate entire document."
    (interactive "P")
    (pdf-view--rotate :counterclockwise (not arg))))
#+end_src
*** TODO Fix page number in boon mode-line when the pdf is opened in a new frame
:PROPERTIES:
:CREATED:  [2019-07-03 Wed 18:14]
:ID:       5fb47379-ccda-4f17-a834-7796b0f188dc
:END:
It's magic
#+begin_src emacs-lisp
(use-package boon-powerline
  :if init-flag
  :defer t
  :init
  (use-package pdf-view
    :config
    (setq pdf-cache-prefetch-delay 8)))
#+end_src
*** Kill pdf buffer on =q=
:PROPERTIES:
:CREATED:  [2019-12-05 Thu 11:16]
:ID:       ee42b095-7f3a-4bc9-a07b-3c830287c59c
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :defer t
  :config
  (defun yant/kill-pdf-buffer-and-quit-window ()
    "When in pdf-view-mode, kill the buffer and clear image cache.
See https://lists.gnu.org/archive/html/bug-gnu-emacs/2019-11/msg01731.html for details why clearing cache is useful."
    (interactive)
    (if (eq major-mode 'pdf-view-mode)
	(progn
	  (quit-window 'kill)
          (clear-image-cache t))
      (funcall-interactively #'quit-window)))
  (bind-key "q" #'yant/kill-pdf-buffer-and-quit-window pdf-view-mode-map))
#+end_src
** TODO Ebook reader
   :PROPERTIES:
   :ID:       b1733b83-8c7d-4254-b2c6-d9b38793542a
   :END:

#+begin_src emacs-lisp
(use-package ereader
  :if init-flag
  :straight t)
#+end_src

** Utils
:PROPERTIES:
:ID:       460ee9e2-32f5-4ad2-a535-69121b201bcf
:END:
*** TODO Shell
**** Eterm
:PROPERTIES:
:CREATED:  [2019-11-25 Mon 20:31]
:ID:       e5c58182-de92-45b5-98d1-1a42db7c0886
:END:

Eterm is a much faster version of terminal for emacs since utilising emacs library support.
#+begin_src emacs-lisp
(use-package vterm
  :if init-flag
  :load-path  "~/.emacs.d/site-lisp/emacs-libvterm"
  ;;:straight (vterm :host github :repo "akermu/emacs-libvterm")
  :commands (vterm vterm-other-window))

;; ;; directory tracking
;; (defun vterm--rename-buffer-as-title (title)
;;   (let ((dir (string-trim-left (concat (nth 1 (split-string title ":")) "/"))))
;;     (cd-absolute dir)
;;     (rename-buffer (format "term %s" title) t)))
;; (add-hook 'vterm-set-title-functions 'vterm--rename-buffer-as-title)

;; ;; vterm toggle
;; (eval-when-compile
;;   (quelpa '(vterm-toggle :fetcher github :repo "jixiuf/vterm-toggle")))
;; (use-package vterm-toggle
;;   :ensure nil
;;   :commands (vterm-toggle-forward vterm-toggle-backward vterm-toggle-cd vterm-toggle)
;;   :config
;;   (setq vterm-toggle-fullscreen-p nil)
;;   ;; toggle window in bottom side
;;   (add-to-list 'display-buffer-alist
;;                '("^v?term.*"
;;                  (display-buffer-reuse-window display-buffer-at-bottom)
;;                  ;;(display-buffer-reuse-window display-buffer-in-direction)
;;                  ;;display-buffer-in-direction/direction/dedicated is added in emacs27
;;                  ;;(direction . bottom)
;;                  ;;(dedicated . t) ;dedicated is supported in emacs27
;;                  (reusable-frames . visible)
;;                  (window-height . 0.5))))
#+end_src

**** Shell colours
:PROPERTIES:
:CREATED:  [2019-11-25 Mon 20:29]
:ID:       0e7fd436-6b4b-43a2-932e-fd75daac32d2
:END:

#+begin_src emacs-lisp
(use-package eterm-256color
  :if init-flag
  :straight t
  :hook
  (term-mode-hook . eterm-256color-mode)
  (vterm-mode-hook . eterm-256color-mode))
#+end_src

**** Invocation
:PROPERTIES:
:ID:       1bdbe0fd-07db-483b-bf04-c9a6813ee351
:END:
#+begin_src emacs-lisp
(use-package shell-pop
  :if init-flag
  :straight t
  :bind ("M-<f9>" . shell-pop)
  :init
  (setq shell-pop-shell-type '("vterm" "*vterm*" (lambda () (vterm))))
  (setq shell-pop-window-position "right")
  :config
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+end_src
**** Interaction with boon
:PROPERTIES:
:ID:       2d3d61e0-4447-4bcb-8cb9-af49f9696335
:END:

#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (use-package term
    :config
    (meta-defun meta-insert-enclosure-new-line :mode term-mode ignore)
    (meta-defun meta-new-line :mode term-mode term-send-raw)))

#+END_SRC
**** Kill process buffer after finishing
:PROPERTIES:
:CREATED:  [2019-08-09 Fri 17:30]
:ID:       6027fccc-5e96-4c55-9e5a-12194caadefd
:END:

#+begin_src emacs-lisp
(when init-flag
  (defun jt-shell-sentinel (process event)
    "Kill buffer and window on shell PROCESS termination when EVENT describe normal termination."
    (when (and (not (process-live-p process))
	       (string-equal event "finished\n"))
      (let ((buf (process-buffer process)))
	(when (buffer-live-p buf)
	  (with-current-buffer buf
            (kill-buffer)
            (delete-window))))))
  (add-hook 'shell-mode-hook (lambda () (set-process-sentinel (get-buffer-process (buffer-name) ) #'jt-shell-sentinel))))
#+end_src

*** =Calc=
:PROPERTIES:
:ID:       db607f5d-6270-4193-942a-c1f772a97ca6
:END:
#+begin_src emacs-lisp
(use-package calc
  :if init-flag
  :bind (:map boon-goto-map
	      ("c" . calc)))
#+end_src
*** Music
**** Mingus (=mpd=)
:PROPERTIES:
:ID:       dad9e1d1-308f-4706-900e-3ec546e6eb58
:END:
I usually run =mingus= in a new frame using global WM key binding.
Hence, delete frame instead of burying the =mingus= buffer.

#+begin_src emacs-lisp
(use-package mingus
  :if init-flag
  :straight t
  :bind (:map mingus-playlist-map
	      ("q" . (lambda() (interactive) (mingus-git-out) (delete-frame)))))
#+end_src

When listening a new band/album, I usually go through all the songs and delete what I do no like until several song remain in the playlist. It is much more convenient to have a global command to delete currently playing song if I do not like it instead of opening =mingus= frame and doing it manually.

#+begin_src emacs-lisp
(use-package mingus
  :defer t
  :if init-flag
  :config
  (defun yant/mingus-delete-currently-playing ()
    "Remove currently playing song from playlist."
    (interactive)
    (when (and (get-buffer "*Mingus*")
	       (mingus-cur-song-number))
      (with-current-buffer "*Mingus*"
	(mingus-goto-current-song)
	(mingus-del)))))
#+end_src

**** Boon special mode bindings
:PROPERTIES:
:ID:       336d16e1-7a21-44c1-8469-15a8658871a3
:END:
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 22:24]

:END:

#+begin_src emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (meta-defun meta-move-line-down :mode mingus-playlist-mode mingus-move-down)
  (meta-defun meta-move-line-up :mode mingus-playlist-mode mingus-move-up)
  (meta-defun meta-new-line :mode mingus-playlist-mode mingus-play)
  (meta-defun meta-new-line :mode mingus-browse-mode mingus-down-dir-or-play-song)
  (meta-defun meta-up-element :mode mingus-browse-mode mingus-open-parent))
#+end_src

*** Printing
:PROPERTIES:
:ID:       7e2f9ad8-6c30-40db-bdbd-9ba3acd70b2a
:END:
#+begin_src emacs-lisp
(setq lpr-command "gtklp")
(setq lpr-add-switches "-C \"emacs-print\"")
(setq pdf-misc-print-programm "gtklp")
(setq pdf-misc-print-programm-args '("-C \"emacs-print\""))
#+end_src
*** Calendar
:PROPERTIES:
:CREATED:  [2020-01-09 Thu 19:41]
:ID:       581abcb2-4a7a-4b0e-b9b9-a0dc6281748b
:END:
Meta bindings for calendar
#+begin_src emacs-lisp
(use-package calendar
  :if init-flag
  :requires meta-functions
  :config
  (meta-defun meta-down :mode calendar-mode calendar-forward-week)
  (meta-defun meta-up :mode calendar-mode calendar-backward-week)
  (meta-defun meta-forward :mode calendar-mode calendar-forward-day)
  (meta-defun meta-backward :mode calendar-mode calendar-backward-day)
  (meta-defun meta-down-element :mode calendar-mode calendar-forward-year)
  (meta-defun meta-up-element :mode calendar-mode calendar-backward-year)
  (meta-defun meta-forward-element :mode calendar-mode calendar-forward-month)
  (meta-defun meta-backward-element :mode calendar-mode calendar-backward-month))
#+end_src
*** Yaml
:PROPERTIES:
:CREATED:  [2020-05-26 Tue 00:46]
:ID:       6a369aa7-2cfb-4866-b238-c2a2ad5758bc
:END:

#+begin_src emacs-lisp
(use-package yaml-mode
  :if init-flag
  :straight t)
#+end_src

** News & email
:PROPERTIES:
:ID:       b53c6b66-4a7c-4eae-ab26-e010fdeb3534
:END:
*** =Elfeed=
:PROPERTIES:
:ID:       9bc385e2-0ed2-460b-875e-be9ad19144a3
:END:
#+begin_src emacs-lisp
(use-package elfeed
  :if init-flag
  :straight t
  :demand t
  :bind (:map elfeed-search-mode-map
	      ("q" . delete-frame)
	      ("r" . elfeed-search-update--force)
	      ("R" . elfeed-search-fetch)
	      ("t" . elfeed-search-untag-all-unread)
	      ("T" . elfeed-search-tag-all-unread)
	      ("b" . yant/elfeed-capture-entry)
	      ("<tab>" . elfeed-quick-peek-current-item)
	      ("B" . (lambda () (interactive)
		       (elfeed-search-tag-all 'opened)
		       (meta-up)
		       (elfeed-search-browse-url))))
  :config
  (use-package quick-peek
    :straight t
    :demand t
    :init
    (defun elfeed-quick-peek-current-item ()
      "Show quick peek of current elfeed item or hide if one is already shown."
      (interactive)
      (require 'elfeed-show)
      (let* ((entry (elfeed-search-selected :ignore-region))
	     (text (and entry
			(with-temp-buffer 
			  (elfeed-show-mode)
			  (setq elfeed-show-entry entry)
			  (elfeed-show-refresh)
			  (read-only-mode -1)
			  (setq-local fill-column 120)
			  (fill-region (point-min) (point-max) 'center)
			  (buffer-string)))))
	(unless (> (quick-peek-hide (point)) 0)
	  (when text (quick-peek-show text nil nil)))))
    (define-advice elfeed-search-untag-all-unread (:after (&rest args) hide-quickpeek)
      "Hide all quick peek overlays in buffer."
      (quick-peek-hide))
    (advice-add 'yant/elfeed-capture-entry :after #'elfeed-search-untag-all-unread@hide-quickpeek)
    (add-hook 'elfeed-search-update-hook #'elfeed-search-untag-all-unread@hide-quickpeek))

  (use-package org-capture-pop-frame
    :defer t
    :config
    (define-advice ocpf--org-capture (:around (old-fun orig-fun &optional goto keys) suppress-pop-frame-maybe)
      "Suppress pop-up frame when ``yant/suppress-pop-frame'' is non nil."
      (if (or (bound-and-true-p yant/suppress-pop-frame)
	      ;; not doing the following check not only makes a frame appear
	      ;; shortly, but also assigns header text to random other frame 
	      (member :immediate-finish (assoc keys org-capture-templates)))
	  (funcall orig-fun goto keys)
	(funcall old-fun orig-fun goto keys))))
  
  (defun yant/elfeed-capture-entry ()
    "Capture selected entries into inbox."
    (interactive)
    (elfeed-search-tag-all 'opened)
    (meta-up)
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
	       do (elfeed-untag entry 'unread)
	       when (elfeed-entry-link entry)
	       do (flet ((raise-frame nil nil))
		    (let ((yant/suppress-pop-frame t)
			  ;; (content (elfeed-deref (elfeed-entry-content entry)))
			  ;; (content-type (elfeed-entry-content-type entry))
                          )
		      ;; (setq content-text (with-temp-buffer (when content
		      ;; 					     (if (eq content-type 'html)
		      ;; 						 (elfeed-insert-html content)
		      ;; 					       (insert content)))
		      ;; 					   (let ((org-babel-min-lines-for-block-output 0)) ;; handle org-mode syntax in body
		      ;; 					     (org-escape-code-in-region (point-min) (point-max)))
                      ;;                                      (unless (string-empty-p (buffer-string))
                      ;;                                        (goto-char (point-min))
                      ;;                                        (insert "#+begin_src org\n\n")
                      ;;                                        (goto-char (point-max))
                      ;;                                        (insert "\n\n#+end_src"))
		      ;; 					   (buffer-string)))
		      
		      (org-protocol-capture (list :template "B"
						  :url it
						  :title (format "%s: %s"
								 (elfeed-feed-title (elfeed-entry-feed entry))
								 (elfeed-entry-title entry))
                                                  :elfeed-data entry
						  ;; :body content-text
                                                  )))))
      (mapc #'elfeed-search-update-entry entries)
      (unless (use-region-p) (forward-line))))
  
  (defvar elfeed-search-default-filter "+unread -hide @2month -video -science -course -chinese -emacs +jobs"
    "Default filter in elfeed search window.")
  (setq elfeed-search-filter elfeed-search-default-filter)
  (setq elfeed-sort-order 'ascending)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-date-format '("%d %b, %a, %H:%M" 20 :left))
  (unless (boundp 'elfeed-search-mode-hook) (setq elfeed-search-mode-hook nil))
  ;; (add-hook 'elfeed-search-mode-hook (lambda () (toggle-truncate-lines +1)))

  (require 'elfeed-search)
  (define-advice elfeed-search-live-filter (:around (oldfun &optional arg) default-filter-maybe)
    "Set `elfeed-search-filter' to `elfeed-search-default-filter' when invoked with C-u prefix argument."
    (interactive "P")
    (setq elfeed-search-filter (if arg elfeed-search-default-filter elfeed-search-filter))
    (call-interactively oldfun))
  
  (use-package elfeed-org
    :straight t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Org/rss.org"))))
#+end_src

Sort entries by Gnus-like score 

#+begin_src emacs-lisp
(use-package elfeed-score
  :if init-flag
  :straight t
  :after elfeed
  :config
  (elfeed-score-enable nil)
  (define-key elfeed-search-mode-map "=" elfeed-score-map)
  (setq elfeed-search-print-entry-function #'elfeed-score-print-entry))
#+end_src

And group them by rss feed

#+begin_src emacs-lisp
  (use-package elfeed-score
    :config
    (defun yant/elfeed-group-by-feed (entry1 entry2)
      (let ((time1 (elfeed-entry-date entry1))
	    (time2 (elfeed-entry-date entry2))
	    (rss1 (elfeed-entry-feed-id entry1))
	    (rss2 (elfeed-entry-feed-id entry2)))
	(or (string> rss1 rss2)
	    (and (string= rss1 rss2)
		 (> time1 time2)))))

    (setf elfeed-search-sort-function (lambda (a b)
					(let ((scorea (elfeed-score--get-score-from-entry a))
					      (scoreb (elfeed-score--get-score-from-entry b)))
					  (or (< scorea scoreb)
					      (and (= scorea scoreb)
						   (yant/elfeed-group-by-feed a b)))))))
#+end_src

Save elfeed buffer on quit to make sure that database is more likely saved if Emacs crashes.

#+begin_src emacs-lisp
(use-package elfeed
  :if init-flag
  :config
  (defun yant/elfeed-save-and-quit ()
    "Save elfeed database and quit."
    (interactive)
    (elfeed-db-save-safe)
    (delete-frame))
  (bind-key "q" #'yant/elfeed-save-and-quit elfeed-search-mode-map))
#+end_src

*** =Notmuch=
:PROPERTIES:
:ID:       f6ca2367-45c4-45bc-acec-49837cadc5ac
:END:

I was using notmuch-tree-mode for a while, but find it not very comfortable. 
Especially in threads with many small messages, which could otherwise appear all together in notmuch-show-mode. 
Can be still occasionally useful to navigate the complicated threads though. 

#+begin_src emacs-lisp
(use-package notmuch
  :straight t
  :config
  (use-package boon
    :if init-flag
    :config
    (defun yant/notmuch-show-view-part ()
      "Search and open part at point or html part of the message."
      (interactive)
      (save-excursion
	(beginning-of-line)
	(if (looking-at "^[ ]*\\[[^\\[]+]$")
	    (notmuch-show-view-part)
	  (beginning-of-buffer)
	  (re-search-forward "text/html")
	  (notmuch-show-view-part))))
    (use-package meta-functions
      :config
      ;; consider notmuch-tree-to-message-pane to run functions in message pane
      (meta-defun meta-scroll-up :mode notmuch-tree-mode scroll-other-window)
      (meta-defun meta-scroll-down :mode notmuch-tree-mode scroll-other-window-down)
      (meta-defun meta-recenter-top-bottom :mode notmuch-tree-mode (with-selected-window (other-window-for-scrolling) (recenter-top-bottom)))
      (meta-defun meta-new-line :mode notmuch-tree-mode (if notmuch-tree-message-window (notmuch-tree-show-message-out) (notmuch-tree-show-message-in)))
      (meta-defun meta-down :mode notmuch-tree-mode (progn
						      (notmuch-tree-next-matching-message)
                                                      (unless (notmuch-tree-get-message-id)
							(notmuch-tree-prev-matching-message))))
      (meta-defun meta-up :mode notmuch-tree-mode (progn
						    (notmuch-tree-prev-matching-message)
                                                    (unless (notmuch-tree-get-message-id)
						      (notmuch-tree-next-matching-message))))
      (meta-defun meta-down-element :mode notmuch-tree-mode notmuch-tree-next-message)
      (meta-defun meta-up-element :mode notmuch-tree-mode notmuch-tree-prev-message)

      (meta-defun meta-down :mode notmuch-search-mode notmuch-search-next-thread)
      (meta-defun meta-up :mode notmuch-search-mode notmuch-search-previous-thread)
      (meta-defun meta-down-element :mode notmuch-search-mode notmuch-search-show-thread)
      (meta-defun meta-up-element :mode notmuch-search-mode ignore)
      
      (meta-defun meta-down-element :mode notmuch-show-mode (notmuch-show-next-message))
      (meta-defun meta-up-element :mode notmuch-show-mode (notmuch-show-previous-message)))

    (defun notmuch-tree-close-and-quit ()
      "Close the current message in notmuch-tree and quit the tree buffer."
      (interactive)
      (notmuch-tree-close-message-window)
      (kill-buffer (current-buffer)))

    (defun notmuch-tree-from-search-thread-and-focus-on-message ()
      "Switch to tree view of the thread at point and activate the message window."
      (interactive)
      (notmuch-tree-from-search-thread)
      (other-window 1))
    
    (bind-keys :map notmuch-search-mode-map
	       ("r" . notmuch-refresh-this-buffer)
	       ("C-c C-u" . notmuch-search-unread)
	       ("C-c C-d" . notmuch-search-done)
               ("C-c C-a" . notmuch-search-hide)
               ("C-c C-f" . notmuch-search-nolist)
	       ("C-c C-S-d" . notmuch-search-delete)
               ("<RET>" . notmuch-search-show-thread)
	       :map notmuch-show-mode-map
	       ("v" . yant/notmuch-show-view-part)
	       ("J" . notmuch-show-next-message)
	       ("K" . notmuch-show-previous-message)
	       ("C-c C-u" . notmuch-show-unread)
	       ("C-c C-d" . notmuch-show-done)
               ("C-c C-a" . notmuch-show-hide)
               ("C-c C-f" . notmuch-show-nolist)
	       ("C-c C-S-d" . notmuch-show-delete)
               :map notmuch-tree-mode-map
               ("v" . (lambda () (interactive) (if (window-live-p notmuch-tree-message-window)
					      (with-selected-window notmuch-tree-message-window
						(yant/notmuch-show-view-html-part)))))
               ("q" . notmuch-tree-close-and-quit)
               ("C-c C-u" . notmuch-tree-unread)
	       ("C-c C-d" . notmuch-tree-done)
               ("C-c C-a" . notmuch-tree-hide)
               ("C-c C-f" . notmuch-tree-nolist)
	       ("C-c C-S-d" . notmuch-tree-delete))))
#+end_src
**** =Sendmail= setup
:PROPERTIES:
:ID:       48f4a6a2-a480-4d4f-9ad4-99da5667a15f
:END:
- multiple accounts
  #+begin_src emacs-lisp
(setq send-mail-function 'sendmail-send-it)
;;autochoose account name for msmtp
(defun cg-feed-msmtp ()
  (if (message-mail-p)
      (save-excursion
	(let* ((from (save-restriction
		       (message-narrow-to-headers)
		       (message-fetch-field "from")))
	       (account (cond
			 ;; I use email address as account label in ~/.msmtprc
			 ((string-match "yantar92@gmail.com" from) "yantar92@gmail.com")
			 ((string-match "ihor_radchenko@alumni.sutd.edu.sg" from) "ihor_radchenko@alumni.sutd.edu.sg"))))
	  (setq message-sendmail-extra-arguments (list '"-a" account)))))) ; the original form of this script did not have the ' before "a" which causes a very difficult to track bug --frozencemetery
(add-hook 'message-send-mail-hook 'cg-feed-msmtp)
(setq message-sendmail-envelope-from 'header)
(setq mail-specify-envelope-from 't)
(setq mail-envelope-from 'header)
(setq message-make-forward-subject-function 'message-forward-subject-fwd)
(setq notmuch-fcc-dirs '(("ihor_radchenko@alumni.sutd.edu.sg" . "Office365/Sent +sent -unread")
			 ("yantar92@gmail.com" . "Gmail/Sent +sent -unread")))
  #+end_src
- automatic email signing
  I have to skip signing for some email accounts, because the server appends some text to messages. Even though the resulting message is correct, but some email clients are not able to open these messages properly. They show the appended text and unreadable attachment.
  #+begin_src emacs-lisp
(setq mml-default-sign-method "pgp")
(setq notmuch-crypto-process-mime t)

(defvar yant/mml-do-not-sign-accounts-list '("ihor_radchenko@alumni.sutd.edu.sg" "yantar92@gmail.com")
  "List of accounts, where the messaged should not be signed.")

(defun yant/mml-secure-message-sign-pgpmime-maybe ()
  "Sign the message unless the sending account is in `yant/mml-do-not-sign-accounts-list'."
  (let ((from (save-restriction
		(message-narrow-to-headers)
                (message-fetch-field "from"))))
    (unless (-first (lambda (el) (string-match el from)) yant/mml-do-not-sign-accounts-list)
      (mml-secure-message-sign-pgpmime))))

(add-hook 'message-send-hook #'yant/mml-secure-message-sign-pgpmime-maybe)
  #+end_src
- async mail sending
*************** TODO Make it work
*************** END

#+BEGIN_SRC emacs-lisp
;; (use-package async
;;   :if init-flag
;;   :straight t
;;   :config
;;   (use-package smtpmail-async
;;     :config
;;     (setq message-send-mail-function 'message-send-mail-with-sendmail)))
#+END_SRC
**** Search via helm
:PROPERTIES:
:ID:       9d973bbc-f8ce-4c35-87e5-67c6a3bebe49
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :config
  (use-package helm-notmuch
    :straight t))
#+end_src
**** Tagging of sent messages
:PROPERTIES:
:ID:       42f1433a-3c25-47d4-b81a-76579130a611
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (unbind-key "C-c C-s" notmuch-message-mode-map)
  (bind-key  "C-c C-c"
	     (lambda()
	       (interactive)
	       (notmuch-mua-send-and-exit)
	       (start-process "Update tags"
			      nil
			      "/home/yantar92/bin/notmuch-new-messages-list-silent.sh"))
	     notmuch-message-mode-map))
#+end_src
**** Tagging functions
:PROPERTIES:
:ID:       54d9479f-a0a4-456f-bf4b-7adc2812c17b
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :config
  (defun notmuch-show-delete ()
    (interactive)
    (let ((tags (seq-remove (lambda (el) (string-match-p "[0-9]\\{4\\}" el)) ; remove year tags
			    (seq-difference (notmuch-show-get-tags) '("inbox" "todo" "attachment" "sent" "unread" "spam" "spam_server" "maillist" "deleted")))))
      (when (or (member "listinbox" tags)
		(seq-empty-p tags)
		(yes-or-no-p "Really delete?"))
	(notmuch-show-tag-message "+deleted" "-inbox" "-todo" "-listinbox"))))

  (defun notmuch-show-unread()
    (interactive)
    (notmuch-show-tag-message "+unread"))

  (defun notmuch-show-nolist()
    (interactive)
    (notmuch-show-tag-message "+inbox" "-listinbox" "+nolist"))

  (defun notmuch-show-done()
    (interactive)
    (notmuch-show-tag-message "-todo" "-inbox" "-listinbox"))

  (defun notmuch-show-hide()
    (interactive)
    (notmuch-show-tag-message "-todo"))

  (defun notmuch-tree-unread()
    (interactive)
    (notmuch-tree-tag '("+unread")))

  (defun notmuch-tree-nolist()
    (interactive)
    (notmuch-tree-tag '("+inbox \"-listinbox\"") "+nolist"))

  (defun notmuch-tree-done()
    (interactive)
    (notmuch-tree-tag '("-todo" "-inbox" "-listinbox")))

  (defun notmuch-tree-hide()
    (interactive)
    (notmuch-tree-tag '("-todo")))

  (defun notmuch-tree-delete()
    (interactive)
    (let ((tags (seq-remove (lambda (el) (string-match-p "[0-9]\\{4\\}" el)) ; remove year tags
			    (seq-difference (notmuch-tree-get-tags) '("inbox" "todo" "attachment" "sent" "unread" "spam" "spam_server" "maillist" "deleted")))))
      (when (or (member "listinbox" tags)
		(seq-empty-p tags)
		(yes-or-no-p "Really delete?"))
	(notmuch-tree-tag '("+deleted" "-inbox" "-todo" "-listinbox")))))

  (defun notmuch-search-hide()
    (interactive)
    (notmuch-search-tag '("-todo")))

  (defun notmuch-search-delete ()
    (interactive)
    (let ((tags (seq-remove (lambda (el) (string-match-p "[0-9]\\{4\\}" el)) ; remove year tags
			    (seq-difference (notmuch-search-get-tags) '("inbox" "todo" "attachment" "sent" "unread" "spam" "spam_server" "maillist" "deleted")))))
      (when (or (member "listinbox" tags)
		(seq-empty-p tags)
		(yes-or-no-p "Really delete?"))
	(notmuch-search-tag '("+deleted" "-inbox" "-todo" "-listinbox")))))

  (defun notmuch-search-unread()
    (interactive)
    (notmuch-search-tag '("+unread")))

  (defun notmuch-search-done()
    (interactive)
    (notmuch-search-tag '("-todo" "-inbox" "-listinbox")))

  (defun notmuch-search-nolist()
    (interactive)
    (notmuch-search-tag '("+inbox" "-listinbox" "+nolist"))))
#+end_src
**** Quit frame instead of bury buffer
:PROPERTIES:
:ID:       b87ec258-7b7e-4898-b828-ab8be4d474f9
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defvar-local notmuch-frame nil
    "Non nil means that frame was invoked from system (not from inside emacs).")
  (defadvice notmuch-refresh-this-buffer (around update-notmuch-frame activate)
    "Preserve `notmuch-frame' value after refresh."
    (let ((notmuch-frame-old notmuch-frame))
      ad-do-it
      (setq notmuch-frame notmuch-frame-old)))
  (bind-key "q" (lambda()
		  (interactive)
		  (if notmuch-frame
		      (delete-frame)
		    (notmuch-bury-or-kill-this-buffer)))
	    notmuch-search-mode-map)
  (bind-key  "q"
	     'notmuch-bury-or-kill-this-buffer
	     notmuch-show-mode-map))
#+end_src
**** Inline display
:PROPERTIES:
:ID:       47d58119-8dc4-48e2-b3c3-81cc955242fc
:END:
- inline view
- html renderer
  #+begin_src emacs-lisp
(when init-flag
  (custom-set-variables
   '(mm-external-terminal-program "kitty")
   '(mm-inline-large-images-proportion 0.4)
   '(mm-inline-media-tests
     (quote
      (("image/p?jpeg" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote jpeg)
	   handle)))
       ("image/png" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote png)
	   handle)))
       ("image/gif" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote gif)
	   handle)))
       ("image/tiff" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote tiff)
	   handle)))
       ("image/xbm" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote xbm)
	   handle)))
       ("image/x-xbitmap" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote xbm)
	   handle)))
       ("image/xpm" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote xpm)
	   handle)))
       ("image/x-xpixmap" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote xpm)
	   handle)))
       ("image/bmp" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote bmp)
	   handle)))
       ("image/x-portable-bitmap" mm-inline-image
	(lambda
	  (handle)
	  (mm-valid-and-fit-image-p
	   (quote pbm)
	   handle)))
       ("text/plain" mm-inline-text identity)
       ("text/enriched" mm-inline-text identity)
       ("text/richtext" mm-inline-text identity)
       ("text/x-patch" mm-display-patch-inline identity)
       ("text/x-diff" mm-display-patch-inline identity)
       ("application/emacs-lisp" mm-display-elisp-inline identity)
       ("application/x-emacs-lisp" mm-display-elisp-inline identity)
       ("application/x-shellscript" mm-display-shell-script-inline identity)
       ("application/x-sh" mm-display-shell-script-inline identity)
       ("text/x-sh" mm-display-shell-script-inline identity)
       ("application/javascript" mm-display-javascript-inline identity)
       ("text/dns" mm-display-dns-inline identity)
       ("text/x-org" mm-display-org-inline identity)
       ("text/html" mm-inline-text-html
	(lambda
	  (handle)
	  mm-text-html-renderer))
       ("text/x-vcard" mm-inline-text-vcard
	(lambda
	  (handle)
	  (or
	   (featurep
	    (quote vcard))
	   (locate-library "vcard"))))
       ("message/delivery-status" mm-inline-text identity)
       ("message/rfc822" mm-inline-message identity)
       ("message/partial" mm-inline-partial identity)
       ("message/external-body" mm-inline-external-body identity)
       ("text/.*" mm-inline-text identity)
       ("application/x-.?tar\\(-.*\\)?" ignore identity)
       ("application/zip" ignore identity)
       ("audio/wav" mm-inline-audio
	(lambda
	  (handle)
	  (and
	   (or
	    (featurep
	     (quote nas-sound))
	    (featurep
	     (quote native-sound)))
	   (device-sound-enabled-p))))
       ("audio/au" mm-inline-audio
	(lambda
	  (handle)
	  (and
	   (or
	    (featurep
	     (quote nas-sound))
	    (featurep
	     (quote native-sound)))
	   (device-sound-enabled-p))))
       ("application/pgp-signature" ignore identity)
       ("application/x-pkcs7-signature" ignore identity)
       ("application/pkcs7-signature" ignore identity)
       ("application/x-pkcs7-mime" ignore identity)
       ("application/pkcs7-mime" ignore identity)
       ("multipart/alternative" ignore identity)
       ("multipart/mixed" ignore identity)
       ("multipart/related" ignore identity)
       ("image/.*" mm-inline-image
	(lambda
	  (handle)
	  (and
	   (mm-valid-image-format-p
	    (quote imagemagick))
	   (mm-with-unibyte-buffer
	     (mm-insert-part handle)
	     (let
		 ((image
		   (ignore-errors
		     (if
			 (fboundp
			  (quote create-image))
			 (create-image
			  (buffer-string)
			  (quote imagemagick)
			  (quote data-p))
		       (mm-create-image-xemacs
			(mm-handle-media-subtype handle))))))
	       (when image
		 (setcar
		  (cdr handle)
		  (list "image/imagemagick"))
		 (mm-image-fit-p handle)))))))
       ("audio/.*" ignore ignore)
       ("image/.*" ignore ignore)
       (".*" mm-inline-text mm-readable-p))))
   '(mm-inlined-types
     (quote
      ("text/calendar" "image/.*" "text/.*" "message/delivery-status" "message/rfc822" "message/partial" "message/external-body" "application/emacs-lisp" "application/x-emacs-lisp" "application/pgp-signature" "application/x-pkcs7-signature" "application/pkcs7-signature" "application/x-pkcs7-mime" "application/pkcs7-mime" "application/pgp")))
   '(mm-text-html-renderer (quote w3m))

   '(send-mail-function (quote sendmail-send-it))
   )
  (setq mm-text-html-renderer-alist '((shr . mm-shr)
				      (w3 . mm-inline-text-html-render-with-w3)
				      (w3m . mm-inline-text-html-render-with-w3m)
				      (w3m-standalone . mm-inline-text-html-render-with-w3m-standalone)
				      (gnus-w3m . gnus-article-html)
				      (links mm-inline-render-with-file mm-links-remove-leading-blank "links" "-dump" file)
				      (lynx mm-inline-render-with-stdin nil "qutebrowser-call.sh")
				      (html2text mm-inline-render-with-function html2text)))
  ;; Inline images?
  (setq mm-attachment-override-types '("image/.*"))
  ;; No HTML mail
  (setq mm-discouraged-alternatives '("text/html" "text/richtext" "text/rtf" "application/zip" "image/vnd.djvu" "application/x-dvi" "application/postscript" ))
  ;; Don't start a browser for text/html only mail
  (setq mm-automatic-display
	'("text/plain" "text/enriched"
	  "image/.*" "message/delivery-status" "message/rfc822"
	  "text/x-patch" "application/pgp-signature" "application/emacs-lisp"))
  (setq mm-inline-large-images 'resize))
  #+end_src
**** =Notmuch= hello
:PROPERTIES:
:ID:       645a5628-289a-4373-9668-b79e10738215
:END:
#+begin_src emacs-lisp
(when init-flag
  (setq notmuch-hello-sections '(notmuch-hello-insert-header notmuch-hello-insert-saved-searches
                                                             notmuch-hello-insert-alltags)
	notmuch-saved-searches '((:name "todo" :query "tag:todo and tag:inbox" :sort-order newest-first)
				 (:name "work" :query "tag:todo or tag:inbox and not tag:private" :sort-order newest-first)
				 (:name "inbox" :query "tag:inbox" :key "i" :sort-order newest-first)
				 (:name "all mail" :query "*" :key "a"))))
#+end_src
**** Opening large threads
:PROPERTIES:
:CREATED:  [2019-12-21 Sat 14:34]
:ID:       ec8e6f0d-bb74-40fc-9088-becd7fa36d86
:END:

Notmuch is known to have poor performance on long threads ([[notmuch:id:87fttpy0n5.fsf@mechane.wlandry.net][as reported in maillist]])
Here are some workarounds

#+begin_src emacs-lisp
(setq-default notmuch-show-indent-content nil)
#+end_src

**** TODO Show accept/decline buttons for calendar invitations
:PROPERTIES:
:ID:       1735faf3-9249-43bd-ae32-8f30500210fe
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (use-package notmuch-calendar-x))
#+end_src

**** TODO Interaction with org
***** Capture mail to org task
:PROPERTIES:
:ID:       2d9b8481-b46c-47a9-9d19-6408c6a1e82d
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defun capture-mail()
    "Capture mail to org mode."
    (interactive)
    (org-store-link nil)
    (org-capture nil "e")
    )
  (bind-key "t" 'capture-mail notmuch-show-mode-map)
  (bind-key "t" 'capture-mail notmuch-tree-mode-map))
#+end_src
***** TODO Org mode functionality when writing messages
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 16:16]
:ID:       119b23b6-1881-4446-847d-7baffbfc2c89
:END:
:LOGBOOK:
- State "TODO"       from              [2018-09-06 Thu 10:11]
:END:

**** TODO Use footnote mode in emails
:PROPERTIES:
:CREATED:  [2019-07-19 Fri 22:01]
:ID:       82254965-b804-41ef-922f-f82cbe77dbb8
:END:

#+begin_src emacs-lisp
(use-package footnote
  :if init-flag
  :hook (message-mode . footnote-mode)
  :init
  (setq footnote-prefix [(control ?c) ?f]))
#+end_src

**** Faster address completion
:PROPERTIES:
:ID:       e6129084-9c4d-4bb8-8b20-c4a900112408
:END:

Tip from [[id:notmuchmail_2019_emacs][[notmuchmail] (2019) Emacstips]]
Using [[id:github_aperezdc_aperez_notmuc_addrl_c_addres][aperezdc [Github] Aperezdc Notmuch-Addrlookup-C: Address Lookup Tool for Notmuch in C Using Glib and Libnotmuch]]

#+begin_src emacs-lisp
(use-package notmuch-address
  :after notmuch
  :if init-flag
  :config
  (setq notmuch-address-command "~/bin/notmuch-addrlookup"))
#+end_src

**** Appearance
:PROPERTIES:
:CREATED:  [2020-04-27 Mon 10:50]
:END:

***** Message header face
:PROPERTIES:
:CREATED:  [2020-04-27 Mon 10:50]
:ID:       954ebb7a-56bd-43e1-8bcc-0590e99fed3b
:END:

#+begin_src emacs-lisp
(use-package message
  :custom-face
  (notmuch-message-summary-face ((t (:foreground ,(face-foreground 'header-line))))))
#+end_src

*** Mail host address
:PROPERTIES:
:CREATED:  [2019-12-23 Mon 12:34]
:ID:       676cf766-9c21-4561-bb05-35df617c4333
:END:
Not sure why I need to set it, but I don't like "i-did-not-set--mail-host-address--so-tickle-me" inserted in my emails.
#+begin_src emacs-lisp
(setq mail-host-address "localhost")
#+end_src

*** Warning when I try to send a message mentioning attachments in text, but without actual attachments
:PROPERTIES:
:CREATED:  [2020-05-05 Tue 15:01]
:ID:       dbd472e2-2ab2-4a8d-bd6c-d28acc48e2dc
:END:

#+begin_src emacs-lisp
(use-package message-attachment-reminder
  :if init-flag
  :straight t)
#+end_src


Automatically translate non-English and non-Russian/Ukrainian titles.
*************** TODO Make it async
*************** END

#+begin_src emacs-lisp
(when init-flag 
  (use-package guess-language
    :straight t
    :custom
    (guess-language-languages '(en ru))
    :config
    (defun yant/guess-language-string (string)
      "Guess language in the specified STRING."
      (s-trim-right 
       (shell-command-to-string (s-concat "/home/yantar92/bin/detect-language \"" string "\"")))))

  (use-package memoize
    :straight t
    :config
    (defun yant/translate-string (string)
      "Automatically translate STRING using trans shell command."
      (s-trim (shell-command-to-string (format "trans -no-warn -b \"%s\"" title))))
    (memoize #'yant/translate-string)
    (memoize #'yant/guess-language-string))

  (defun elfeed-search-print-entry--auto-translate-chinese (entry)
    "Print ENTRY to the buffer."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title (if (and (elfeed-tagged-p 'chinese entry)
			   (member (yant/guess-language-string title) '("zh-cn" "ko")))
                      (yant/translate-string title)
		    title))
	   (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
	   (feed (elfeed-entry-feed entry))
	   (feed-title
	    (when feed
	      (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
	   (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
	   (tags-str (mapconcat
		      (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
		      tags ","))
	   (title-width (- (window-width) 10 elfeed-search-trailing-width))
	   (title-column (elfeed-format-column
			  title (elfeed-clamp
				 elfeed-search-title-min-width
				 title-width
				 elfeed-search-title-max-width)
			  :left)))
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (when feed-title
	(insert (propertize feed-title 'face 'elfeed-search-feed-face) " "))
      (when tags
	(insert "(" tags-str ")"))))

  (setq elfeed-search-print-entry-function #'elfeed-search-print-entry--auto-translate-chinese)
  )
#+end_src

*** COMMENT Org-mode in messages (via =org-msg=)
    :PROPERTIES:
    :ID:       90e6045d-c09e-4022-bd59-33084bd68114
    :END:

[2020-08-11 Tue] It does not seem to handle quotes of quotes from last emails very well

[[github_jeremy-compostella_jerem_compos_org_msg_orgms][org-msg]] make it possible to write email in org-mode and export it to html when sending.

#+begin_src emacs-lisp 
(use-package org-msg
  :straight t
  :config
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:Ihor Radchenko email:nil \\n:t"
	org-msg-startup "hidestars inlineimages"
	org-msg-greeting-fmt ""
	org-msg-text-plain-alternative t
        org-msg-signature "Ihor Radchenko,
PhD,
Center for Advancing Materials Performance from the Nanoscale (CAMP-nano)
State Key Laboratory for Mechanical Behavior of Materials, Xi'an Jiaotong University, Xi'an, China
Email: yantar92@gmail.com, ihor_radchenko@alumni.sutd.edu.sg")
  (org-msg-mode))
#+end_src

Make company completion work in notmuch.
Credit: [[id:github_jeremy-compostella_notmuc_compan_suppor_org_msg][jeremy-compostella [Github] Notmuch Company Support in Org-Msg-Edit-Mode · Issue #53 · Jeremy-Compostella Org-Msg]]
#+begin_src emacs-lisp 
(defun arvindsv/org-msg-notmuch-company (old-fn &rest args)
  ;; Cheat and say that this buffer, which should be org-msg-edit-mode, is derived from message-mode.
  (cl-letf (((symbol-function 'derived-mode-p) (lambda (mode) (if (eq mode 'message-mode) t (derived-mode-p mode)))))
    (apply old-fn args)))

(advice-add 'notmuch-company :around #'arvindsv/org-msg-notmuch-company)

(add-hook 'org-msg-edit-mode-hook #'notmuch-company-setup)
#+end_src

Fix saving sent messages ([[https://github.com/jeremy-compostella/org-msg/issues/58#issuecomment-675185846][credit]])
#+begin_src emacs-lisp
(use-package org-msg
  :if init-flag
  :config
  (remove-hook 'notmuch-mua-send-hook #'notmuch-mua-message-send-hook))
#+end_src

** Browser
   :PROPERTIES:
   :ID:       ef9c93cd-e760-407c-82cf-2aeffa7a11ad
   :END:

I gave up using Google Chrome and Firefox in my daily browsing long time ago in exchange of qutebrowser providing better control over the browser behaviour and customisation.
That went pretty well except some cases when I have to use poorly designed government websites requiring mainstream browsers to even directly prohibiting anything other than Chrome, Firefox, or Edge.
Though torbrowser is usually sufficient to handle those.

However, despite nice featured of qutebrowser, I miss closer integration with Emacs.
There are userscripts, but I would ideally like to control the internals of browser directly from Emacs.
This struggle turned my attention to emacs-application-framework [[id:78e3b460-84dd-402f-9b54-e9805e81fa74][Emacs application framework]] offering integrating python programs into Emacs. Since qutebrowser is written in python. I opened an [[https://github.com/manateelazycat/emacs-application-framework/issues/369][issue]], but it turned out that qutebrowser does not play well with Emacs application framework.

Emacs application framework provides its own implementation of keyboard-driven browser, so I am giving it a try.

#+begin_src emacs-lisp
(use-package eaf
  :if init-flag
  :load-path "~/Dist/emacs-application-framework"
  :custom
  (eaf-find-alternate-file-in-dired t)
  :config
  (eaf-bind-key insert_or_open_link_new_buffer "H" eaf-browser-keybinding)
  (eaf-bind-key insert_or_open_link "h" eaf-browser-keybinding)
  (eaf-bind-key insert_or_close_buffer "C-x q" eaf-browser-keybinding)
  (eaf-bind-key insert_or_view_source "w" eaf-browser-keybinding)
  (setq eaf-browser-keybinding (delete '("v" . "insert_or_view_source") eaf-browser-keybinding))

  (setq eaf-browser-search-engines '(("duckduckgo" . "https://duckduckgo.com/?q=%s")))
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-default-search-engine 'duckduckgo))
#+end_src

** Org mode
:PROPERTIES:
:ID:       58045c39-ffd5-4ccc-bc9d-49048c437f42
:END:
This config is inspired by [[http://doc.norang.ca/org-mode.html][Bernt Hansen's config]].
*************** TODO Describe the workflow
:PROPERTIES:
:ID:       2b1456f8-c2fe-41ef-8d3d-99aa4adf362e
:END:
*************** END

#+begin_src emacs-lisp
(use-package org
  :if (or init-flag org-export-flag org-tangle-flag)
  :demand t)
#+end_src

*** Workflow
:PROPERTIES:
:CREATED:  [2020-04-08 Wed 15:48]
:END:
**** Project management
:PROPERTIES:
:ID:       8cef1ba5-d5ea-4ad1-955b-932952c77b0c
:END:
I need to deal with many projects running at the same time in my work. Hence, I need some good structure for all these projects to keep track of deadlines, have all the notes to be able to recall what is going on in the project after some time.
***** Tags
****** General org mode tags
:PROPERTIES:
:ID:       adc6f5ae-183f-4c5f-97e8-7bfe18f028d2
:END:
#+begin_src emacs-lisp
(setq org-tag-alist (quote (("COMMON" . ?c)
			    ("PhD" . ?p)
			    ("INBOX" . ?i)
			    ("TRACK" . ?t)
			    ("BOOKMARK" . ?b)
			    ("ORG" . ?o)
			    ("NOEXPORT" . ?n)
			    ("NODEADLINE" . ?d)
			    ("SKIP" . ?s)
                            ("NOARCHIVE" . ?a)
                            ("ARCHIVEALL" . ?A)
                            ("NOCLOCK" . ?k)
			    ("ignore" . ?g)
                            ("REFILE" . ?r)
			    ("AREA" . ?E)
                            ("@home" . ?h)
                            ("@work" . ?w))))
(setq org-tags-exclude-from-inheritance '("ATTACH" "NOCLOCK" "REFILE" "AREA"))
#+end_src
- =COMMON= :: General task
- =PhD= :: Related to work/PhD
- =INBOX= :: Need to be processed (for new captured tasks)
- =TRACK= :: The link from this task/item should be monitored for changes in the internet
*************** TODO Need to add automatic handling of this
:PROPERTIES:
:ID:       27eb85b6-114f-437f-9424-b28d400f6aa9
:END:
*************** END
- =BOOKMARK= :: Contains a link
- =ORG= :: if the task is not finished - include the org file linked during agenda creation if todo keyword is =NEXT=.The purpose of this tag is reduce the file size: I had a large database of books, which I've read/will read. The file with all the authors included was more than =2Mb=, which took forever to open and, more importantly, made my agenda view build/update time *few minutes*. So, I created separate project for different authors and kept the links to that projects with =ORG= tag assigned, so that I can add the author book list to file/agenda view if the project is =NEXT=.
*************** TODO add link management system
*************** TODO need to implement this (ORG tag)
:PROPERTIES:
:ID:       648e5339-0732-4464-80de-90a8f5f72467
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"       [2018-09-20 Thu 22:32]
:END:
Text properties: =modification-hooks=, =insert-in-front-hooks=, =insert-behind-hooks=
*************** END
- =NOEXPORT= :: Do not export an item
- =NODEADLINE= :: Do not show these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view
- =SKIP= :: Some projects/sub-projects contains tasks, which can be done independently to each other. I want to see these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view even if the projects they belong to have =NEXT= tasks.
- =NOARCHIVE= :: Do not archive a task. This in not inherited.
- =ARCHIVE= :: Prevent task from unfolding (e.g. task contains bulky data, I do not want to see)
- =ARCHIVEALL= :: Do not archive individual tasks in the subtree. Only do it all together.
- =NOCLOCK= :: prevent entry from being clocked in automatically (after child task clock out [[id:d1afb1ae-a3a4-45b4-8186-8e7242e0edc1][Clocking & logging]]). This is not inherited.
- =DEFAULT= :: Do not list the task in GTD agenda
- =REFILE= :: can be refile target even if it is not project/sub-project
- =AREA= :: Some projects are not "real" projects, but rather areas of interest. The difference with normal projects is that areas are not expected to be ever finished. Thus, it has little point to keep them in weekly review together with projects. However, they can be stuck, as any other project.
****** TODO Tags for everything
****** TODO try to implement multiple files/buffers in the same buffer via text properties like modification hooks |- (Special Properties - GNU Emacs Lisp Reference Manual) :BOOKMARK:
:PROPERTIES:
:CREATED:  [2018-02-12 Mon 00:51]
:Source:   https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html#Special-Properties
:END:
:LOGBOOK:
CLOCK: [2018-02-12 Mon 00:51]--[2018-02-12 Mon 00:52] =>  0:01
:END:
modified b
******* TODO may be useful |- (multifiles.el/multifiles.el at master · magnars/multifiles.el)             :BOOKMARK:
:PROPERTIES:
:CREATED:  [2018-02-12 Mon 00:56]
:Source:   https://github.com/magnars/multifiles.el/blob/master/multifiles.el
:END:
fun create-or
***** Tasks
:PROPERTIES:
:ID:       d38441a2-1431-44db-b831-8cdec011b1dc
:END:
The task is any item with todo keyword and no subtask.
#+begin_src emacs-lisp
(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (member (org-get-todo-state) org-todo-keywords-1)
	    (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
#+end_src
- keywords for not done tasks: =TODO=, =NEXT=, =DOING=, =REVIEW=, =SOMEDAY=, =WAITING=, =HOLD=, =CANCELLED=, =DONE=, =FAILED=, =MERGED=
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "DOING(o)" "REVIEW(e)" "|" "DONE(d!)" "FAILED(f@/!)" "MERGED(m!)" )
	      (sequence "SOMEDAY(s)" "WAITING(w@/!)" "HOLD(h@/!)" "|" "FROZEN(z@/!)" "CANCELLED(c@)" ))))
;; set the tags assigned to specific keywords. Not nesessary, but used by a lot of code for filtering later - hence why not
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("SOMEDAY") ("CANCELLED" . t))
	      ("WAITING" ("SOMEDAY") ("CANCELLED") ("WAITING" . t))
	      ("HOLD" ("SOMEDAY") ("CANCELLED") ("WAITING") ("HOLD" . t))
              ("SOMEDAY" ("CANCELLED") ("WAITING") ("HOLD") ("SOMEDAY" . t))
	      (done ("SOMEDAY") ("WAITING") ("HOLD"))
	      ("TODO" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD"))
	      ("NEXT" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD"))
              ("REVIEW" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD"))
              ("DOING" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD"))
	      ("DONE" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD"))
	      ("FAILED" ("SOMEDAY") ("WAITING") ("CANCELLED") ("HOLD")))
	     ))
#+end_src
  - TODO(t) :: task which needs to be reviewed and marked with one of the following keywords. TODO tasks are generally tasks I may consider doing, but do not know any details about what they are and how to proceed with doing them.
  - NEXT(n) :: Task which needs to be done next
*************** #todo_keyword #DOING
:PROPERTIES:
:ID:       66396995-13e9-4dfa-854e-476c71a4faa9
:END:
  - DOING(o) :: A task I am working on, but do not expect to finish quickly (e.g. reading book). Marking this task =DOING =-> =DOING=, reschedules it to tomorrow. Marking a task DOING if it had other keyword and not scheduled, schedules it for today and asks for effort estimate. 
*************** END
*************** TODO make it reschedule according to repeater instead
*************** END
  #+begin_src emacs-lisp
(defun org-trigger-doing (arg)
  "Restore DOING keyword after DOING->DONE or DOING->DOING change and handle setting DOING.
^DOING->DOING: If the task does not have effort estimate, set it.
^DOING->DOING: If the task is unscheduled, schedule it today.
 DOING->DOING: If the task is unscheduled or has no repeater, schedule it for tomorrow.
 DOING->DOING: If the task has a repeater, re-schedule it accordingly
 DOING->DONE/REVIEW:  Cancel repeater and mark the task DONE."
  (when (and (eq (plist-get arg :type) 'todo-state-change)
	     (not (string= (plist-get arg :from) "DOING"))
             (string= (plist-get arg :to) "DOING"))
    (unless (org-with-point-at (plist-get arg :position) (org-element-property :scheduled (org-element-at-point)))
      (org-schedule nil "."))
    (unless (org-with-point-at (plist-get arg :position) (org-element-property :EFFORT (org-element-at-point)))
      (org-set-effort)))
  (when (and (eq (plist-get arg :type) 'todo-state-change)
	     (string= (plist-get arg :from) "DOING")
             (or (string= (plist-get arg :to) "DOING")
		 (member (plist-get arg :to) org-done-keywords)))
    (let* ((pos (plist-get arg :position))
	   (schedule-info (org-with-point-at pos (org-element-property :scheduled (org-element-at-point)))))
      (when schedule-info
	(let ((repeater (or (org-with-point-at pos (org-get-repeat))
			    "+1d")))
          (if (member (plist-get arg :to) org-done-keywords)
              (org-schedule nil ".+0d") ;; revert the default re-schedule triggered by DONE
            (org-set-property "SHOWFROMDATE"
			      (ts-format "%Y-%m-%d"
					 (ts-parse-org
					  (org-read-date nil nil (s-replace "." "" repeater)))))) ;; do not reschedule (I am still working on the task), but show later
	  (when (member (plist-get arg :to) org-done-keywords)
	    (if (y-or-n-p (format "Trying to mark DOING task as %s. Proceed? " (plist-get arg :to)))
		(org-with-point-at pos
		  (org-cancel-repeater)
                  (org-todo (plist-get arg :to)))
	      (org-todo "DOING")))))
      (when (and (marker-buffer org-clock-marker)
		 (marker-position org-clock-marker)
		 (equal (marker-position pos)
			(org-with-point-at org-clock-marker (org-back-to-heading 't))))
	(org-clock-out)))))
(add-hook 'org-trigger-hook #'org-trigger-doing)
  #+end_src
  - REVIEW(e) :: A task is basically done, but should be reviewed (i.e. consider putting to knowledge base). Unschedule the task when set.
  - WAITING(w) :: I am waiting for someone/something which does not depend on me to start the task (should add comment about reason). The command triggers unscheduling the task.
  - HOLD(h) :: I am not going to do this task for now because of lack of time/low priority. The command triggers unscheduling the task.
  - FROZEN(z) :: I should have been done, but it haven't and not because of me. It might be in the future, but unlikely. 
  - SOMEDAY(s) :: This task appears to be interesting and worth doing but does not have to be done at all. The command triggers unscheduling the task if it is scheduled and clocking out.
#+begin_src emacs-lisp
(defun yant/unschedule-maybe ()
  "Unschedule task when it keyword is changed to SOMEDAY."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components)))))
    (when (member mystate (list "SOMEDAY" "HOLD" "WAITING" "REVIEW"))
      (org-schedule '(4)))))
(add-hook 'org-after-todo-state-change-hook 'yant/unschedule-maybe 'append)

(defun org-trigger-someday (arg)
  "Handle setting SOMEDAY todo keyword.
Unschedule when SOMEDAY is set."
  (when (and (eq (plist-get arg :type) 'todo-state-change)
	     (not (string= (plist-get arg :from) "SOMEDAY"))
             (string= (plist-get arg :to) "SOMEDAY"))
    (let ((pos (plist-get arg :position)))
      (when (and (marker-buffer org-clock-marker)
		 (marker-position org-clock-marker)
		 (equal (marker-position pos)
			(org-with-point-at org-clock-marker (org-back-to-heading 't))))
	(org-clock-out)))))
(add-hook 'org-trigger-hook #'org-trigger-someday)
#+end_src
  - CANCELLED(c) :: I will never do this task because of what is in the comment
  - DONE(d) :: self explanatory
  - FAILED(f) :: there is some outcome and can mark done, but the outcome is not positive, though can get some conclusions out of it
  - MERGED(m) :: become a part of other task. The link to the task is added to =MERGED-WITH= property. The motivation of adding this state is that I sometimes create a duplicate task, find out that it is duplicate, and confused which state to set. It is just faster to set =MERGED= without deciding if it is =CANCELLED= (which is not really) or =DONE= (which is also not).
  #+begin_src emacs-lisp
(defun org-trigger-merged (arg)
  "Prompt and insert a link to related task when changing to MERGED state."
  (when (and (eq (plist-get arg :type) 'todo-state-change)
	     (string= (plist-get arg :to) "MERGED")
	     (not (string= (plist-get arg :from) (plist-get arg :to))))
    (let* ((pos (plist-get arg :position)))
      (org-with-point-at pos
	(org-set-property "MERGED-WITH" "undefined")
        (when (re-search-forward (org-re-property "MERGED-WITH") nil 'noerror)
          (replace-match "" nil nil nil 3)
          (funcall-interactively #'org-insert-link))))))
(add-hook 'org-trigger-hook #'org-trigger-merged)
  #+end_src
*************** TODO Prompt for the link to new task, default is clocked in task. Use helm search. Store link in property
*************** END

In some cases, I do not want to have logging on CANCELLED/FAILED/HOLD/WAITING.
For example, a task to listen music with outcome of FAILED mostly have the same meaning - I do not like the music.
Writing the note is useless in such a case.
So, I define =:LOGGING:= property in some subtrees to avoid logging.

***** Inline tasks
:PROPERTIES:
:ID:       54ee8e08-0cb5-4104-94c2-948be5830c4e
:END:
I use inline tasks to add temporary todo state (instead of notes). It should be removed once done and placed into notes when archiving.
*************** TODO Implement this on inline task done
*************** END
#+begin_src emacs-lisp
(use-package org-inlinetask)
(setq org-inlinetask-default-state "TODO")
#+end_src

It seems that inline tasks interferes with =org-outline-regexp=.
Fix it:

#+begin_src emacs-lisp
(defun org-outline-regexp-no-inline ()
  "Return string matching an non-inline task heading.
The maximum number of levels is controlled by `org-inlinetask-min-level'."
  (let* ((org-inlinetask-min-level (- org-inlinetask-min-level 1))
	 (nstars (if org-odd-levels-only
		     (1- (* org-inlinetask-min-level 2))
		   org-inlinetask-min-level)))
    (format "^\\(\\*\\{1,%d\\}\\)[ \t]+" nstars)))
;; (define-advice org-back-to-heading (:around (oldfun &optional args) skip-inlinetasks)
;;   "Ignore preceding inline tasks when calling outline-back-to-heading."
;;   (if (org-inlinetask-in-task-p)
;;       (funcall oldfun args) ;; inside inlinetask - just go to heading
;;     (let ((outline-regexp (org-outline-regexp-no-inline)))
;;       (funcall oldfun args))))
;; (advice-remove 'org-back-to-heading #'org-back-to-heading@skip-inlinetasks)
#+end_src

By default, org-mode does not allow storing links to inline headings.
It is really strange. 
I force org-mode to store link to inline headings by adding inline heading store link function.
*************** TODO report to org-mode 
:PROPERTIES:
:ID:       8764bf9c-51f1-439e-88aa-8650b8e0f83a
:END:
*************** END

#+begin_src emacs-lisp
(defun org-inlinetask-store-link (oldfun &rest args)
  "Store link to inlinetask at point."
  (if (and (derived-mode-p 'org-mode)
	   (org-inlinetask-in-task-p))
      (let ((org-inlinetask-min-level 10000))
	(apply oldfun args))
    (apply oldfun args)))

(advice-add 'org-store-link :around #'org-inlinetask-store-link)
#+end_src
***** TODO Task dependencies 
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 06:10]
:ID:       d982166c-a450-4625-8211-ded63dc03f2d
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 17:59]
:END:
Some of the tasks cannot be done until some condition is met. Before that, it does not make too much sense to show it in agenda.
I use [[http://www.nongnu.org/org-edna-el/][org-edna]] for managing dependencies. On top of blocked tasks management, it allows to schedule tasks on trigger. It introduces two new properties: =TRIGGER= and =BLOCKER= (see [[id:598c2b16-2eb8-404a-b7e9-00969a1c4d72][Properties]] for details)
#+BEGIN_SRC emacs-lisp
(use-package org-edna
  :straight t
  :diminish org-edna-mode
  :config
  (org-edna-mode))
#+END_SRC

*************** TODO rewrite using org-depend, as suggested in https://www.reddit.com/r/orgmode/comments/hljpl3/any_one_uses_org_edna/fwzhldp/
*************** END

This can be useful, for example, when watching a series.
I may add multiple TODOs for different series, but it usually make sense to watch them in sequence.
I can do it using =org-edna=
#+begin_src emacs-lisp
(use-package org-edna
  :bind (:map org-mode-map
	      ("C-c C-x M-p" . yant/org-set-preceding-task))
  :config
  (defun yant/org-set-preceding-task ()
    "Make task at point follow other task.

The current task will be marked WAITING and cannot be marked DONE
until the other task is completed.
Its :SUMMARY: property will contain the information about the blocker
Completing the other task will automatically set the current task to
NEXT and schedule it the same day."
    (interactive)
    (let ((uuid (org-id-prompt-id))
	  (cur-uuid (org-id-get-create)))
      (unless uuid (user-error "Did not get a uuid"))
      (org-todo "WAITING")
      (org-set-property "BLOCKER" (format "ids(%s)" uuid))
      (org-set-property "SUMMARY" (format "Blocked by %s" (org-with-point-at (org-id-find uuid 'marker) (org-get-heading t t t t))))
      (org-with-point-at (org-id-find uuid 'marker)
	(org-set-property "TRIGGER" (format "ids(%s) todo!(NEXT) scheduled!(\".\") delete-property!(\"SUMMARY\")" cur-uuid))))))
#+end_src

Also, the projects require all the children to be done by default.
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src
In addition, I force all the check-boxes to be checked before a task can be marked done. 
Otherwise, there is not much point in check-boxes for me.
#+begin_src emacs-lisp
(use-package org
  :custom
  (org-enforce-todo-checkbox-dependencies t))
#+end_src

***** Habits
:PROPERTIES:
:ID:       fa036b84-f68e-485b-943c-d5d9ad79c516
:END:

Habits are regular tasks which are treated specially in agenda to show if I missed it.
#+begin_src emacs-lisp
(use-package org-habit)
(setq org-habit-graph-column 120)
#+end_src

Any tasks can be made a habit by adding an appropriate properties.
I have two ways to do it:
- through [[id:e3d02bee-a924-4808-9a2f-fe577065038d][capture]]
- calling a custom function
#+begin_src emacs-lisp
(defun yant/org-task-convert-to-habit ()
  "Make task at point a habit."
  (interactive)
  (org-with-wide-buffer
   (if (not (org-entry-is-todo-p))
       (when (y-or-n-p (format "Current entry is not a task ("%s").\nChange todo state?" (org-get-heading 'no-tags)))
	 (funcall-interactively #'org-todo))
     (cl-mapc #'org-set-property
	      '("STYLE" "REPEAT_TO_STATE" "LOGGING" "ARCHIVE")
	      '("habit" "NEXT" "DONE(!)" "%%S_archive_%%y.org::* Habits")))))
(bind-key "C-c C-x h" #'yant/org-task-convert-to-habit org-mode-map)
#+end_src

Allow checklists to be reset in recurring tasks when =:RESET_CHECK_BOXES:= is =t=
#+begin_src emacs-lisp
(use-package org-checklist
  :config
  (add-to-list 'org-default-properties "RESET_CHECK_BOXES"))
#+end_src

Do not show consistency graph in agenda
#+begin_src emacs-lisp
(define-advice org-habit-insert-consistency-graphs (:override () disable) #'ignore)
#+end_src

***** Projects
:PROPERTIES:
:ID:       3edce153-2927-4a2d-8b45-87d9a6151913
:END:
The project is an item with todo keyword and subtask.
#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask or :REFILE: tag."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (and (not (org-inlinetask-at-task-p))
		     (member (org-get-todo-state) org-todo-keywords-1))
	    (setq has-subtask t))))
      (and is-a-task has-subtask))))
#+end_src
This approach is useful in the case if I place some todo under the wrong item during refiling. It will appear in the project list in such a case. Project cannot be =DONE= if any of subtasks is =TODO=, =NEXT=, =WAITING= or =HOLD= (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
****** Top level project
:PROPERTIES:
:ID:       aa2f80d5-d05c-418f-ac41-e1c6a138afcb
:END:
The project without parent projects.
#+begin_src emacs-lisp
(defun bh/find-project-task ()
  "Move point to the parent (project) task if any."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))
(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
			      (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
	  nil
	t))))
#+end_src

****** Sub-project
:PROPERTIES:
:ID:       32faf7a0-7af7-4bd9-973b-814549420e07
:END:
The project with parent projects.
#+begin_src emacs-lisp
(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
	(is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq is-subproject t))))
    (and is-a-task is-subproject)))
#+end_src
- if any task below is =NEXT= and the project is =TODO= then need to change to =NEXT= (it means that we need to do some task from this sub-project next)
  #+begin_src emacs-lisp
(defun yant/mark-todo-parent-tasks-next ()
  "Visit each parent task and change TODO states to NEXT."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components)))))
    (when (member mystate (list "NEXT"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	    (unless (string= (org-get-todo-state) "NEXT")
	      (org-todo "NEXT"))))))
    (when (member mystate (list "TODO"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) (list "DONE"))
	    (org-todo "TODO")))))))
(add-hook 'org-after-todo-state-change-hook 'yant/mark-todo-parent-tasks-next 'append)
  #+end_src
****** TODO Standard projects
**** Journal
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 18:19]
:ID:       46346e6b-4ed8-4570-bf4c-05639c125046
:END:
:LOGBOOK:
CLOCK: [2019-07-29 Mon 13:33]--[2019-07-29 Mon 14:06] =>  0:33
- State "NEXT"       from              [2018-10-23 Tue 18:50]
:END:

Sometimes, I do some trial tasks for my projects or just try random things with programming.
These things are unlikely to go into my actual notes or projects files.
Not always though.
It is always frustrating when I remember trying something and want to move it to actual notes of project file, but lose what I did.

Journal seems to be a good solution for it.
I can dump all kind of staff there instead of having it spread over the bash history or just lost.
I can write notes, run shell commands, calculations, etc without loosing what I have done.
I may not even need to run terminal in such a case!

I have tried [[https://github.com/bastibe/org-journal][org-journal]], but it does not really work for me because it creates too many files. A simple =date-tree= capture works just fine.

#+begin_src emacs-lisp
(use-package org-capture
  :if init-flag
  :after org
  :requires org
  :config
  (defvar yant/org-journal-file "~/Org/Journal.org"
    "Filename of the journal file")
  (use-package doct
    :defer t
    :config
    (asoc-put! org-capture-templates
	       "j"
               (cdar (doct '("Journal entry"
			     :keys "j"
			     :type entry
			     :file yant/org-journal-file
			     :datetree t
			     :clock-in t
			     :clock-resume t
			     :jump-to-captured t
			     :template
			     ("* %?"
			      ":PROPERTIES:"
			      "CREATED: %U"
			      ":END:\n"))))
               'replace)))
#+end_src

**** TODO Files
:PROPERTIES:
:ID:       f1be655e-5fc4-44b5-8197-22ce9457e489
:END:
- TODO.org :: store new entries, general home and work entries, want todo some time entries
  #+begin_src emacs-lisp
(when init-flag
  (defun gtd-open ()
    (interactive)
    (find-file "~/Org/TODO.org")))
              #+end_src
- notes.org :: all kind of generally useful information
               #+begin_src emacs-lisp
(when init-flag
  (defun notes-open ()
    (interactive)
    (find-file "~/Org/notes.org")))
               #+end_src
- articles.org :: notes on research articles
- rss.org :: rss entries for [[id:9bc385e2-0ed2-460b-875e-be9ad19144a3][Elfeed]]
- *contacts.org* :: my contacts /via/ =org-contacts=
- *.org :: project specific entries
- all of it is in =agenda_files=
- we can add new org files and remove existing
#+begin_src emacs-lisp
(when init-flag
(defun add-buffer-to-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (end-of-buffer)
	  (newline)
	  (insert file_name)
	  (message "%S is added to agenda_files" file_name)
	  )
	(when pos
	  (message "%S is already in agenda_files" file_name))
	)
      )
    )
  )
(defun add-current-buffer-to-agenda-files ()
  (interactive)
  (add-buffer-to-agenda-files (current-buffer))
  )
(defun remove-buffer-from-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (message "%S is not in agenda_files" file_name))
	(when pos
	  (beginning-of-buffer)
	  (delete-matching-lines file_name)
	  (message "%S is deleted from agenda_files" file_name)
	  )
	)
      )
    )
  )
(defun remove-current-buffer-from-agenda-files ()
  (interactive)
  (remove-buffer-from-agenda-files (current-buffer))
  ))
#+end_src
**** Links
:PROPERTIES:
:ID:       7122dce7-7d3e-4167-a444-8811d588db42
:END:
***** NEXT Link description function
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:27]
:ID:       bd43272d-9ef4-45a6-85ab-bebbef75c18b
:END:
:LOGBOOK:
CLOCK: [2019-08-03 Sat 00:01]--[2019-08-03 Sat 00:02] =>  0:01
- State "NEXT"       from "TODO"       [2019-05-07 Tue 10:34]
:END:

#+begin_src emacs-lisp
(defun yant/org-make-link-description-function (link desk)
  "Return description of the link LINK according to :desk link property.
Return DESK if :desk is not set."
  (let ((fun (org-link-get-parameter (car (split-string link ":")) :desk)))
    (if (functionp fun)
	(funcall fun link desk)
      desk)))

(setq org-link-make-description-function #'yant/org-make-link-description-function)
#+end_src

***** External
:PROPERTIES:
:ID:       e74697d9-3d3e-4db4-8a4c-e9cad8f73d23
:END:
****** External apps
:PROPERTIES:
:ID:       2fe2cfaf-3ad4-4b87-99b1-2897e7c0bf20
:END:
Adjust some of the external application programs
#+begin_src emacs-lisp
(setq org-file-apps '((directory . emacs)
		      ("\\.mm\\'" . default)
		      ("\\.x?html?\\'" . default)
		      ("\\.pdf\\'" . default)
		      ("\\.mp4\\'" . "mpv %s")
		      ("\\.tiff?\\'" . "/home/yantar92/bin/feh-open %s")
		      ("\\.png?\\'" . "/home/yantar92/bin/feh-open %s")
		      )
      )
#+end_src
****** =Pdf-view= links
:PROPERTIES:
:ID:       f6b6301d-6ccb-4ee1-a454-ca6f5af845ea
:END:
Store links to pages in pdf
#+begin_src emacs-lisp
(use-package org-pdftools
  :straight t
  :after org
  :demand t
  :config
  (org-pdftools-setup-link))

(add-to-list 'org-file-apps '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))

(setq org-file-apps  (delete '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))) org-file-apps ))
#+end_src
****** TODO Inkscape links
:PROPERTIES:
:CREATED:  [2018-10-21 Sun 14:05]
:ID:       824be892-df30-4c07-bf02-93a234fb7885
:END:
Open and preview inkscape svg files.
Copy paste from https://github.com/jkitchin/scimax/blob/master/scimax-inkscape.el
#+BEGIN_SRC emacs-lisp
(use-package scimax-inkscape)
#+END_SRC

****** Links to attached files
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 21:46]
:ID:       1460419f-52b8-4687-955c-936a1f99ae7c
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-04-24 Wed 17:15]
- State "TODO"       from              [2018-07-23 Mon 15:33]
- State "TODO"       from              [2018-07-10 Tue 22:49]
CLOCK: [2018-07-09 Mon 21:47]--[2018-07-09 Mon 23:02] =>  1:15
- State "TODO"       from              [2018-07-09 Mon 21:47]
:END:

I have symlinks to the attached files stored in the directory tree mimicking org file structure (see [[id:9361bc68-010b-45f1-bddd-4638d6344758][Store files in folder structure, following my org tree structure]])
However, they can be moved upon refiling.
Hence, it is better to avoid =file= links to the attached files.
Therefore, I define a new link type to the attached files of the current entry.
Note that if helm-find-files is used in emacs, it is possible to =C-c C-f= while selecting an image link - it will show the preview of images in separate buffer (idea from [[https://www.reddit.com/r/emacs/comments/9dh45j/preview_images_while_helmfindfiles/][reddit]]).

*************** TODO need to use caching for =org-attach-dir-symlink=. slowing down flycheck too much
*************** END

#+BEGIN_SRC emacs-lisp
(defmacro org-with-point-at-org-buffer (&rest body)
  "If in agenda, put the point into the corresponding org buffer."
  `(cond ((eq major-mode 'org-agenda-mode)
	  (when-let ((marker (org-get-at-bol 'org-hd-marker)))
	    (org-with-point-at marker
	      ,@body)))
         ((eq major-mode 'org-mode)
          (org-with-wide-buffer
	   ,@body))
	 (t (display-warning :warning "Trying to call org function in non-org buffer."))))

(setq org-link-file-path-type 'relative)

(defun yant/process-att-abbrev (arg)
  "Return `org-attach-dir' for the current entry."
  (s-concat (f-slash
	     ;; (org-attach-dir-symlink 'CREATE)
             (let ((org-attach-dir-suppress-extra-checks t)) (org-attach-dir))
             )
	    arg))

(add-to-list 'org-link-abbrev-alist (cons "att" "attachment"))

;; (defun org-att-link-complete (&optional arg)
;;   "Completion function for att: link."
;;   (let* ((ref-dir (org-attach-dir 'CREATE))
;; 	 (filelink (let ((default-directory (f-slash ref-dir)))
;; 		     (org-file-complete-link)))
;; 	 (filepath (apply #'s-concat (cdr (s-split ":" filelink)))))
;;     (format "att:%s" filepath)))

;; (org-link-set-parameters "att"
;; 			 :complete #'org-att-link-complete)
#+END_SRC

Just links to the current entry are not always sufficient. I sometimes want to link a file from another entry.

#+begin_src emacs-lisp
(defun yant/process-att-id-abbrev (arg)
  "Return `org-attach-dir' for the entryin att-id: link type."
  (let ((id (car (s-split ":" arg)))
        (file (cadr (s-split ":" arg))))
    (s-concat (f-slash (let ((org-attach-dir-suppress-extra-checks t))
			 (org-with-point-at (org-id-find id 'marker)
			   (org-attach-dir 'CREATE))))
	      file)))

(add-to-list 'org-link-abbrev-alist (cons "att-id" "file:%(yant/process-att-id-abbrev)"))

(defun org-att-id-skip-function ()
  "Test if an entry contains attachments. Move point to next candidate location."
  (if (yant/org-task-has-attachments-p)
      't
    (and (search-forward org-attach-auto-tag nil 'noerror)
	 (beginning-of-line)
         (backward-char))))

(defun org-att-id-prompt-id ()
  "Prompt for the id during completion of att-id: link.
If there is an id: link in `org-store-link-plist' suggest that heading.
Show parent project as top (or second top) suggestion."
  (let (parent-project
	saved-id)
    (when (eq major-mode 'org-mode)
      (org-with-point-at (point)
	(org-back-to-heading)
	(while (and (not parent-project)
		    (org-up-heading-safe))
	  (when (and (bh/is-project-p)
		     (not (bh/is-subproject-p)))
            (setq parent-project (list (s-join "/"
					       (mapcar (lambda (str) (replace-regexp-in-string "/" "\\\\/" str))
						       (append (list (f-filename (buffer-file-name (buffer-base-buffer))))
							       (org-get-outline-path 'with-self 'use-cache))))))))))
    (when (string= "id" (plist-get org-store-link-plist :type))
      (org-with-point-at (org-id-find (cadr (split-string (plist-get org-store-link-plist :link) ":")) 'marker)
	(setq saved-id (list (s-join "/"
				     (mapcar (lambda (str) (replace-regexp-in-string "/" "\\\\/" str))
					     (append (list (f-filename (buffer-file-name (buffer-base-buffer))))
						     (org-get-outline-path 'with-self 'use-cache))))))))
    (let ((org-refile-history (append saved-id parent-project))
	  (org-refile-cache nil)
	  (org-refile-target-verify-function #'org-att-id-skip-function))
      (let ((prompt-ans (org-refile-get-location "Link to attachment from")))
	(prog1
	    (org-id-get (seq-find #'markerp
				  prompt-ans)
			'create))))))

(defun org-att-id-link-complete (&optional arg)
  "Completion function for att-id: link."
  (let* ((id (org-att-id-prompt-id))
	 (ref-dir (org-with-point-at (org-id-find id 'marker)
		    (org-attach-dir 'CREATE)))
	 (filelink (let ((default-directory (f-slash ref-dir)))
		     (org-file-complete-link)))
	 (filepath (apply #'s-concat (cdr (s-split ":" filelink)))))
    (format "att-id:%s:%s" id filepath)))

(defun org-att-id-link-description (link desc)
  "Return description of an att-id: link."
  (when-let ((id (nth 1 (s-split ":" link)))
	     (file (nth 2 (s-split ":" link))))
    (org-with-point-at (org-id-find id 'marker)
      (when-let ((heading (org-get-heading 'no-tags 'no-todo 'no-priority 'no-comment)))
	(s-concat heading ":" file)))))

(org-link-set-parameters "att-id"
			 :complete #'org-att-id-link-complete
                         :desk #'org-att-id-link-description)

#+end_src

***** Internal
:PROPERTIES:
:ID:       5aebc1b8-8d85-4254-b177-c216c053e8f3
:END:
****** Links by ID
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:05]
:ID:       0f7c34bc-bc56-4bbf-954e-b0e03e5240a2
:END:

#+begin_src emacs-lisp
(use-package org-id)
(setq org-id-method (quote uuidgen))
(setq org-id-link-to-org-use-id 't)
#+end_src
****** =id:= link completion
:PROPERTIES:
:CREATED:  [2019-05-07 Tue 10:05]
:ID:       ffb27a1a-735e-4398-b230-a71fc4df0023
:END:

#+begin_src emacs-lisp
(defvar org-id-history nil
  "ID completion history for id: link type.")

(defun org-id-prompt-id ()
  "Prompt for the id during completion of att-id: link."
  (org-id-get-with-outline-path-completion '((org-agenda-files :maxlevel . 100)))
  ;; (let ((org-refile-history org-id-history)
  ;; 	(org-refile-cache nil)
  ;; 	(org-refile-target-verify-function nil))
  ;;   (let ((prompt-ans (org-refile-get-location "Select org entry")))
  ;;     (prog1
  ;; 	  (or (org-id-get (seq-find #'markerp
  ;; 				    prompt-ans)
  ;; 			  'create)
  ;;             (user-error "Cannot find ID of the entry: %s" prompt-ans))
  ;; 	(setq org-id-history org-refile-history)
  ;; 	(setq org-id-cache org-refile-cache))))
  )

(defun org-id-link-complete (&optional arg)
  "Completion function for id: link."
  (let* ((id (org-id-prompt-id)))
    (format "id:%s" id)))

(defun org-id-link-desk (link desk)
  "Description function for id: link."
  (or desk
      (let ((id (cadr (split-string link ":"))))
	(org-with-point-at (org-id-find id 'marker)
	  (org-get-heading 'stip 'all 'the 'extra)))))

(org-link-set-parameters "id"
			 :complete #'org-id-link-complete
                         :desk #'org-id-link-desk)
#+end_src

****** TODO Footnotes
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 21:45]
:ID:       343d5ae5-613f-4c1e-998d-91e5cd325053
:END:
:LOGBOOK:
- State "TODO"       from              [2018-10-23 Tue 21:45]
:END:

#+begin_src emacs-lisp
(setq org-footnote-section nil)
#+end_src
****** =Src= block links
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 14:37]
:ID:       b1ca3ea7-39ec-4489-8a67-8a01d4d61398
:END:

The links to run =src= blocks.
Useful if I want to run an =src= block when working on entry.
Having a link, which runs blocks, allows to simply =C-c C-o= on the heading to follow this link.





#+BEGIN_SRC emacs-lisp  
(defun org-link-babel-follow (name &optional return-info)
  "Run src block NAME from babel:name link.
The NAME is parsed as in #+CALL: specification.
The src block should be in the same org file."
  (let* ((call (with-temp-buffer
		 (interactive)
		 (org-mode)
		 (insert "#+CALL: " (format "%s" (org-link-unescape name)) "\n")
		 (beginning-of-buffer)
		 (org-element-babel-call-parser (point-max) (list (point-min)))
		 ))
	 (info (org-babel-lob-get-info call)))
    (if return-info
	info
      (flet ((org-babel-insert-result (result &optional result-params info hash lang) nil))
	(org-babel-execute-src-block nil info)))))

(defun org-link-babel-complete ()
  "Complete babel: link at point."
  (let* ((name (completing-read "Source block name: " (org-babel-src-block-names)))
	 (block-info (org-link-babel-follow (format "%s()" name) 'return-info))
         (block-lang (car block-info))
         (block-default-params (nth 2 block-info))
         (block-params (nth 2 (org-link-babel-follow (format "%s()" name) 'return-info))) ;; call again to make a new sequence
         (lang-headers-var (intern (concat "org-babel-header-args:" block-lang)))
         (lang-headers (when (boundp lang-headers-var) (eval lang-headers-var t)))
	 (headers-w-values (org-babel-combine-header-arg-lists
			    org-babel-common-header-args-w-values lang-headers))
         (headers (mapcar (apply-partially #'format ":%s") (mapcar #'symbol-name (mapcar #'car headers-w-values))))
         params)
    (while (not params)
      (setq params (org-completing-read "Header Arg: " (cons (format "Default: %s" block-params) headers)))
      (unless (string= params (format "Default: %s" block-params))
	(let* ((args (cdr (assoc (intern (substring params 1)) headers-w-values)))
	       (args (if (listp args) args nil))
	       (arg (org-completing-read
		     (format "%s: " params)
		     (append (and args (mapcar #'symbol-name (apply #'append args)))
			     (list (alist-get (intern params) block-params))))))
          (setf (alist-get (intern params) block-params) arg)
          (setq params nil))))
    (setq params (seq-difference block-params block-default-params))
    (let ((var-params (alist-get :var params)))
      (setq params (seq-difference params (list (cons :var (alist-get :var params)))))
      (when params (setq params (s-join " " (mapcar (lambda (el) (format "%s %s" (car el) (cdr el))) params))))
      (when var-params (setq var-params (format "%s" var-params)))
      (format "babel:%s[%s](%s)" name (or params "") (or var-params "")))))

(org-link-set-parameters "babel"
			 :follow #'org-link-babel-follow
                         :complete #'org-link-babel-complete)
#+end_src
***** Active links
:PROPERTIES:
:ID:       98951f47-3da1-4be0-9e01-93607a3df065
:END:

I sometimes use elisp: links to execute a meaningful action required to start working on a task.
For example, checking email require opening notmuch window (I prefer to not bind such action to a key in order to break destructing habit of checking email mindlessly).

Do not ask every time I try to evaluate elisp: links
#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :config
  (setq org-link-elisp-confirm-function nil))
#+end_src

***** NEXT Org-ref
:PROPERTIES:
:ID:       f944c2c8-f1fa-49ea-ab24-bf1b018013f1
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-10-10 Wed 11:43]
- State "TODO"       from              [2018-03-12 Mon 18:04]
:END:
#+begin_src emacs-lisp
(use-package org-ref
  :if init-flag
  :straight t
  :demand t
  :init
  (use-package bibtex-completion :demand t)
  (use-package lv :straight t)
  (setq org-ref-show-citation-on-enter nil) ;; this slows down org mode a lot otherwise
  :config
  (setq org-latex-prefer-user-labels t)
  (setq org-ref-show-broken-links nil) ;; it makes typing very slow if 't
  (use-package org-ref-pdf)
  (use-package org-ref-url-utils)
  (setq org-ref-bibliography-notes "~/Books/articles/articles.org"
	bibtex-completion-notes-path "~/Books/articles/articles.org"
	org-ref-default-bibliography '("~/Books/References.bib")
	org-ref-pdf-directory "~/Books/articles/_symlinks/"
	bibtex-completion-library-path org-ref-pdf-directory)
  (setq reftex-default-bibliography (quote ("~/Books/References.bib")))
  (bind-key* "C-c ]" #'org-ref-helm-insert-cite-link)
  (bind-keys :map org-mode-map
	     ("C-c [" . org-ref-helm-insert-ref-link))
  (bind-keys :map bibtex-mode-map ("C-c [" . helm-bibtex))
  (use-package org-ref
    :config
    (add-to-list 'org-ref-bibtex-journal-abbreviations '("PMAG" "Philosophical Magazine" "Philos. Mag."))
    (add-to-list 'org-ref-bibtex-journal-abbreviations '("MRSBEA" "MRS Bulletin" "MRS Bull."))
    (add-to-list 'org-ref-bibtex-journal-abbreviations '("ExtrMechL" "Extreme Mechanics Letters" "Extreme Mech. Lett."))
    (add-to-list 'org-ref-bibtex-journal-abbreviations '("PRMHBS" "Physical Review Materials" "Phys. Rev. Mater."))
    ))
#+end_src

***** SOMEDAY search in article PDFs
:PROPERTIES:
:CREATED:  [2018-10-10 Wed 11:37]
:SHOWFROMDATE: 2018-10-11 18:00
:ID:       160da641-39cb-4ce9-b41f-da015d2fd0e8
:END:
:LOGBOOK:
CLOCK: [2019-07-20 Sat 22:04]--[2019-07-20 Sat 22:34] =>  0:30
CLOCK: [2018-10-10 Wed 12:30]--[2018-10-10 Wed 12:40] =>  0:10
:END:

- need to modify the lib to show abstracts (=recollqq -A=)

#+BEGIN_SRC emacs-lisp
(use-package helm-recoll
  :if init-flag
  :straight t
  :config
  (helm-recoll-create-source "docs" "~/.recoll")
  (bind-key* "C-c }" 'helm-recoll-docs))
#+END_SRC
***** TODO Backlinks
:PROPERTIES:
:CREATED:  [2020-04-21 Tue 14:50]
:ID:       248307ef-49c4-4fa9-a812-ab9acb643be4
:END:

It is handy to be able to find all other headlines having links to current headline.
=org-super-links= package does exactly this. 

*************** TODO this package does not support actual org-insert-link interface
*************** END


#+begin_src emacs-lisp :tangle no
(use-package org-super-links
  :straight (org-super-links :type git :host github :repo "toshism/org-super-links")
  )
#+end_src
**** LaTeX integration
:PROPERTIES:
:CREATED:  [2020-05-05 Tue 23:00]
:END:
***** CDLaTeX
:PROPERTIES:
:CREATED:  [2020-05-05 Tue 23:00]
:ID:       6807bed8-dc56-4f1a-adde-e1f2942786dd
:END:

Additional auto-typing for LaTeX fragments directly inside org. 
This includes:
1. C-c { for inserting environment
2. TAB for LaTeX abbrev expansion
3. _ and ^ automatically adds curly braces
4. ` inserts Greek symbols
5. ' inserts LaTeX accents

#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :init
  (use-package cdlatex
    :straight t
    :config
    (require 'texmathp))
  :hook (org-mode . org-cdlatex-mode)
  :config
  (diminish 'org-cdlatex-mode (s-concat
			       " "
			       (propertize "CD"
					   'face `((:height 0.5)))
			       (propertize (all-the-icons-fileicon "tex" :v-adjust 0.04)
					   'face `((
						    :family "file-icons"
						    ;; :height 1.4
						    )))))
  (diminish 'org-cdlatex-mode)
  )
#+end_src

**** TODO Properties
:PROPERTIES:
:ID:       598c2b16-2eb8-404a-b7e9-00969a1c4d72
:END:
#+begin_src emacs-lisp
(setq org-use-property-inheritance '("ORG-TIME-BONUS-ON-DONE" "ORG-TIME-BALANCE-MULTIPLIER" "SORT" "SHOWDATES" "SHOWFROMDATE" "SHOWFROMTIME" ))
#+end_src
- =:SHOWFROMTIME:= (always inheriting) :: The purpose of this is to be able to assign specific projects for different days of week or, say, show the home items only in the evening of weekdays and not annoy it at work when I cannot do it any way. Hence, I can focus on the items I really need to do now in this agenda.
     Additionally, the time of the day after midnight is treated specially here. If =org-extend-today-until= is not 0 and the current time is before its value, the current time is still considered to be yesterday.
     #+begin_src emacs-lisp
(setq org-extend-today-until 4)
(setq org-use-effective-time t) ; respect `org-extend-today-until' when setting time-stamps

(add-to-list 'org-default-properties "SHOWFROMTIME")
(defun org-agenda-skip-before-SHOWFROMTIME-property ()
  "Skip agenda item if :SHOWFROMTIME: property is set and time of day is before it"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (let* ((showfromtime (apply 'encode-time
				  (-replace nil 0
					    (parse-time-string (or (org-entry-get (point) "SHOWFROMTIME" 'inherit)
								   "00:00:01")))))
             (daystart (apply 'encode-time
			      (-replace nil 0
					(parse-time-string (or (and org-extend-today-until (format "%s:00:01" org-extend-today-until))
							       ("00:00:01"))))))
	     (currenttime (apply 'encode-time
				 (-replace nil 0
					   (parse-time-string (format-time-string "%T"))))))
	(when (and (time-less-p currenttime showfromtime)
		   (time-less-p currenttime daystart))
          (setq currenttime (apply 'encode-time (-replace nil 0
							  (parse-time-string (format-time-string "23:59:59"))))))
	(when (time-less-p currenttime showfromtime)
	  next-headline)))))
     #+end_src
- =:SHOWFROMDATE:= :: The purpose of this is to be able to postpone the scheduled tasks for future if I cannot do it. The property is formatted as an org date.
     This property is especially useful if there is something more pressing, so that there is a temptation to reschedule less pressing event to another day. If the more pressing task is done earlier than expected, the postponed tasks can be still find in normal agenda view (not in the [[id:ff70b03f-3876-4b2b-9aab-c3209bd31cb8][focused]] one).
*************** TODO maybe move showing overlay in agenda to appearance
*************** END
     #+begin_src emacs-lisp
(require 'org-agenda)
(add-to-list 'org-default-properties "SHOWFROMDATE")
(bind-key "C-c C-f" #'org-command-set-SHOWFROMDATE-property org-mode-map)
(bind-key "C-c C-f" #'org-command-set-SHOWFROMDATE-property org-agenda-mode-map)
(add-to-list 'org-agenda-bulk-custom-functions '(?F org-command-set-SHOWFROMDATE-property))

(defun org-command-set-SHOWFROMDATE-property (&optional arg)
  "Command to set :SHOWFROMDATE property for the org entry at point.
	 If NOT-IN-AGENDA is not nil, do not check whether we are in agenda now."
  (interactive "P")
  (if (equal major-mode 'org-agenda-mode)
      (progn
	(org-agenda-check-no-diary)
	(let* ((marker (or (org-get-at-bol 'org-marker)
			   (org-agenda-error)))
	       (buffer (marker-buffer marker))
	       (pos (marker-position marker))
	       (inhibit-read-only t)
	       ts)
	  (org-with-remote-undo buffer
	    (with-current-buffer buffer
	      (widen)
	      (goto-char pos)
	      ;; (org-fold-show-context 'agenda)
	      (funcall-interactively 'org-command-set-SHOWFROMDATE-property arg)
	      (setq ts (org-entry-get (point) "SHOWFROMDATE")))
	    (org-agenda-show-new-time marker ts " P"))))
    (let ((property "SHOWFROMDATE"))
      (if (equal arg '(4))
	  (org-entry-delete (point) property)
	(let ((value (org-read-property-value property))
	      (fn (cdr (assoc-string property org-properties-postprocess-alist t))))
	  (setq org-last-set-property property)
	  (setq org-last-set-property-value (concat property ": " value))
	  ;; Possibly postprocess the inserted value:
	  (when fn (setq value (funcall fn value)))
	  (unless (equal (org-entry-get nil property) value)
	    (org-entry-put nil property value)))))))

(defun org-set-SHOWFROMDATE-property (PROMPT &rest args)
  "Read :SHOWFROMDATE: property."
  (org-read-date nil nil nil PROMPT))

(add-to-list 'org-property-set-functions-alist '("SHOWFROMDATE" . org-set-SHOWFROMDATE-property))

(defun org-agenda-skip-before-SHOWFROMDATE-property ()
  "Skip agenda item if :SHOWFROMDATE: property is set and the day is before it"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (let ((showfromdate (org-read-date 't 't (or (org-entry-get (point) "SHOWFROMDATE")
						   "")))
	    (currenttime (org-read-date 't 't "")))
	(if (time-less-p currenttime showfromdate)
	    next-headline
	  nil)))))
     #+end_src
- =:SHOWDATES:= (always inheriting) :: It contains dairy =sexps= to set when the project should be shown. For example, I may want to work on Saturday once or twice, but the working items should not be shown on weekend normally. Hence, I can define it. Or some things can only be done on specific dates (say, going to some shop, which is open few days a week only)
     #+begin_src emacs-lisp
(add-to-list 'org-default-properties "SHOWDATES")
(defun org-agenda-skip-noshowdates()
  "Skip agenda item if :SHOWDATES: property sexp is not matching today"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	  (entry (org-entry-get (point) "SHOWDATES" 'inherit))
	  (date (diary-make-date (nth 4 (decode-time)) (nth 3 (decode-time)) (nth 5 (decode-time)))))
      (let ((result (and entry (pcase (eval (car (read-from-string entry)))
				 ((and (pred listp) res)
				  (cdr res))
				 (res res)))))
	(if (and entry (not result))
	    next-headline
	  nil)))))

(defun yant/daysofweek (&rest days)
  "Return 't if any of the listed weekdays (Mon, Tue, Wed, Thu, Fri, Sat, Sun) is today. Work only in the context of :SHOWDATES: property."
  (let ((data (list
	       (if (member "Mon" days) '(7 7 24 2017) nil)
	       (if (member "Tue" days) '(7 7 25 2017) nil)
	       (if (member "Wed" days) '(7 7 26 2017) nil)
	       (if (member "Thu" days) '(7 7 27 2017) nil)
	       (if (member "Fri" days) '(7 7 28 2017) nil)
	       (if (member "Sat" days) '(7 7 29 2017) nil)
	       (if (member "Sun" days) '(7 7 30 2017) nil))))
    (some #'(lambda (&rest args) (apply #'diary-cyclic (car args))) (remove nil data))))
     #+end_src
- =:CREATED:= :: Entry creation time. Inserted for all the new captures.
- =:BLOCKER:= :: Conditions to be met before allowing the entry to be
                 marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
- =:TRIGGER:= :: Actions to be done when the item is marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
- =:MERGED-WITH:= :: If the task is marked =MERGED=, contains a link to the new task
- =:SOURCE:= :: The link to the file/URL, which this task refers to
**** NEXT Attach
:PROPERTIES:
:ID:       bb8263f5-8ef4-4444-941c-9ffbb338185d
:END:
:LOGBOOK:
CLOCK: [2019-04-24 Wed 15:43]--[2019-04-24 Wed 15:46] =>  0:03
- State "NEXT"       from "TODO"       [2018-09-20 Thu 22:31]
- State "TODO"       from "NEXT"       [2018-09-20 Thu 22:17]
:END:
#+begin_src emacs-lisp
(use-package org-attach
  :config
#+end_src
***** Default attachment directory + multi-selection for attach
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 16:12]
:ID:       3a0ca96a-3ce5-4f72-ba38-16990342fb5a
:END:

I try to store every possibe file in an attachment dir.
The new files are usually coming from my Downloads (=yant/org-attach-default-source)= directory.

#+BEGIN_SRC emacs-lisp
(defvar yant/org-attach-default-source "~/Downloads/"
  "Default directory to attach the files from.")

(define-advice org-attach-attach (:around (oldfun files &rest args) start-from-default-directory)
  "Look for new attachments from `yant/org-attach-default-source' directory instead of `default-directory'."
  (interactive
   (list
    (mapcar #'directory-file-name (helm-read-file-name "File to keep as an attachment:"
						       :initial-input (or (progn
									    (require 'dired-aux)
									    (dired-dwim-target-directory))
									  (and yant/org-attach-default-source
									       (f-slash yant/org-attach-default-source))
									  default-directory)
						       :marked-candidates t))
    current-prefix-arg
    nil))
  (unless (listp files) (setq files (list files)))
  (mapc (lambda (file) (apply oldfun file args)) files))
#+END_SRC

***** Make it possible to attach directories (not only files)
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 16:37]
:END:

The default =org-attach-attach= function does not allow to attach directories.
I made it so in the interactive specification in [[id:3a0ca96a-3ce5-4f72-ba38-16990342fb5a][Default attachment directory]].

***** TODO Automatically insert link at point after adding new attachment
:PROPERTIES:
:CREATED:  [2020-07-07 Tue 19:11]
:ID:       96a327b6-d204-433c-af62-d3700d46674a
:END:

The most common scenario working with attachments is when I want to add an attachment and immidiately insert the corresponding =attachment:= link. 
So, it makes sense to copy the link to added attachment into link ring.

#+begin_src emacs-lisp
(use-package org-attach
  :if init-flag
  :after org
  :custom
  (org-attach-store-link-p 'attached))
#+end_src

***** NEXT Store files in folder structure, following my org tree structure
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:11]
:ID:       9361bc68-010b-45f1-bddd-4638d6344758
:header-args: :tangle ~/Git/org-attach-fs/org-attach-fs.el
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"          [2018-01-01 Mon 13:17]
:END:

*************** TODO view attachments in dired just by hitting inter on .org file - simulate symlink folders / virtual filesystem
*************** END

I usually have a huge numbers of files, related to my projects. I would like to use attach to associate the files with the proper entry, but searching them later in my Dropbox is a pain because of the way Org saves the attachments.
It makes more sense for me to make attachments follow the org tree structure in the project by default (unless I change the attach folder to something else).

This can be done if we make attachment by creating a symbolic link to the attach folder in the place, according to the headline path.
This way allows to keep all the file attached to the project accessible with relative paths.

*************** TODO I do not handle the situation when the entry uid is being changed..
Try to look in symlinks?
*************** END

For the implementation, the idea is keeping all the actual attachments in a common folder for all the org files according to their uuid. As a result, I can safely refile tasks between different org files without worrying about moving the attachments around (assuming that there is not change in the task ids).

#+begin_src emacs-lisp :tangle "~/.emacs.d/config.el"
(use-package org-attach-fs :after org :demand t)
#+end_src

This is separate package now. All the code below is exported to =org-attach-fs.el=
*************** NEXT rewrite to use lexical binding
*************** END
#+begin_src emacs-lisp
;;; org-attach-fs.el --- Mirror org heading heirarchy to store attachments

;; Version: 0.0
;; Author: Ihor Radchenko <yantar92@gmail.com>
;; Created: 14 March 2020

;;; Commentary:

;; This package aims to store symlinks to org attachments under folder
;; structure reflecting current org heading hierarchy.
;; The package started as my personal Emacs config and assumes that
;; all the attachments can be accessed from any org file. This
;; corresponds to the following config:
;; (setq org-attach-method 'mv)
;; (setq org-attach-id-dir "~/.data/")
;; (setq org-id-locations-file
;;       (f-join org-attach-id-dir ".org-id-locations"))
#+end_src

#+begin_src emacs-lisp
(require 'f)
(require 'org-attach)
#+end_src

#+begin_src emacs-lisp :tangle "~/.emacs.d/config.el"
(setq org-attach-method 'mv)
(setq org-attach-id-dir "~/.data/")
(setq org-id-locations-file
      (f-join org-attach-id-dir ".org-id-locations"))
#+end_src

The above does not follow the task hierarchy of the tasks.
To implement this, for each task, I store the symlinks to the child tasks in the task's attachment directory.
Therefore, apart from the attachments, I have =yant/org-attach-symlinks-directory= folder in the task's attach dir.
This folder contains a back reference to the attachment dir (if there are attachments) =yant/org-attach-attachments-symlink-directory= and symlinks to the corresponding symlink folders of the children with attachments somewhere down the hierarchy.

Now, it is trivial to create the attachment hierarchy for any org file. I just make folders pointing to the =yant/org-attach-symlinks-directory= of the top level tasks either in the same folder with the org file or in =yant/org-attach-file-symlink-path= (file local).

#+BEGIN_SRC emacs-lisp
;; (setq org-attach-file-list-property nil)

(defvar-local yant/org-attach-file-symlink-path nil
  "Path to directory where the symlink hierarchy is created for the current org buffer.
It is intended to be set as a file-local variable.
Use `default-directory' if nil.")
(put 'yant/org-attach-file-symlink-path 'safe-local-variable 'stringp)

(defvar yant/org-attach-attachments-symlink-directory "_data"
  "Name of the symlink to the attach file folder.")
(defvar yant/org-attach-symlinks-directory ".org.symlinks"
  "Name of the folder containing symlinks to the entry children attach folders.")

(define-advice org-attach-file-list (:filter-return (filelist) remove-boring-files)
  "Remove local variable file and boring symlinks from the attachment file list."
  (let ((symlinks-directory yant/org-attach-symlinks-directory))
    (remove "flycheck_.dir-locals.el" ;; not sure where this constant is defined
	    (remove dir-locals-file
		    (remove symlinks-directory
			    filelist)))))

(defun yant/outline-get-next-sibling (&optional subtree-end)
  "A faster version of `outline-get-next-sibling'.
Bound search by SUBTREE-END if non nil."
  (let* ((level (funcall outline-level))
	 (sibling-regex (concat "^\\*\\{" (format "%d" level) "\\}[^*]"))
         (bound (or subtree-end (point-max))))
    (re-search-forward sibling-regex bound 'noerror)))

(defun yant/org-entry-name-cleanup-for-dir ()
  "Format entry name to make a directory. Return nil if the entry name is empty."
  (org-with-wide-buffer
   (let* ((entry-name (replace-regexp-in-string "[/<>|:&/]" "-" ;; make sure that entry title can be used as a directory name
						(org-get-heading 'NO-TAGS 'NO-TODO 'NO-PRIORITY 'NO-COMMENT)))
          (entry-name (replace-regexp-in-string " +\\[.+\\]$" "" ;; remove statistics cookies
						entry-name
						))
          (entry-name (replace-regexp-in-string org-link-bracket-re "\\2" ;; only leave the link names
						entry-name
						)))
     (unless (seq-empty-p entry-name) ;; prevent empty folders
       (set-text-properties 0 (length entry-name) nil entry-name)
       entry-name))))

(defun yant/org-subtree-has-attachments-p ()
  "Return non nil if the subtree at point has an attached file."
  (org-with-wide-buffer
   (when (eq major-mode 'org-mode) (org-back-to-heading))
   (let ((subtree-end (save-excursion (org-end-of-subtree))))
     (re-search-forward (format "^\\*+ +.*?[ 	]+.*?:%s:.*?$" org-attach-auto-tag) subtree-end 'noerror))))

(defun yant/org-task-has-attachments-p ()
  "Return non nil if the task at point has an attached file."
  (org-with-wide-buffer
   (when (eq major-mode 'org-mode) (org-back-to-heading))
   (or (member org-attach-auto-tag (org-get-tags nil t))
       (let ((dir (let ((org-attach-dir-suppress-extra-checks t)) (org-attach-dir))))
	 (and dir
	      (org-attach-file-list dir))))))

(defvar yant/--processed-entry-ids nil
  "Variable used to store processed entry ids in `org-attach-dir@yant/org-attach-ensure-attach-dir-symlink'")

(define-advice org-attach-dir (:filter-return (dir) yant/org-attach-ensure-attach-dir-symlink)
  "Make sure that the attach DIR for the current entry has a link in the org structure based directory structure.
The DIR is ensured to be in the symlink mirror dir structure for the entry.
Do nothing if `org-attach-dir-suppress-extra-checks' is non-nil."
  (prog1
      (and dir
	   (f-slash dir))

    (when (and (equal major-mode 'org-mode)
	       dir
	       (not (bound-and-true-p org-attach-dir-suppress-extra-checks)) ;; an option to make `org-attach-dir' faster if needed
	       (f-exists-p dir)
	       (f-dir-p dir))
      (let* ((attach-path dir)
	     (symlinks-directory (f-slash (f-join dir
						  yant/org-attach-symlinks-directory)))
	     (attachments-symlink-directory (f-slash (f-join symlinks-directory
							     yant/org-attach-attachments-symlink-directory)))
	     (org-id (org-id-get nil 'create))
	     (entry-name (yant/org-entry-name-cleanup-for-dir))
	     (attach-dir-inherited-p (or (not (org-entry-get (point) "ID"))
					 (and  (org-entry-get-with-inheritance "DIR")
					       (not (org-entry-get (point) "DIR")))
					 (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
					      (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))))) ;; only consider if the entry is the child
	     (org-attach-dir-recursive-p (bound-and-true-p org-attach-dir-recursive-p))) ;; keep track if this is the initial call of the function
	(unless org-attach-dir-recursive-p (setq yant/--processed-entry-ids nil))
	(unless (member org-id yant/--processed-entry-ids)
	  (add-to-list 'yant/--processed-entry-ids org-id)
	  (unless attach-dir-inherited-p
	    (when (f-file-p symlinks-directory)
	      (error (format "File exist in place of dir: %s" symlinks-directory)))
	    (when (and (f-exists-p attachments-symlink-directory)
		       (not (f-symlink-p (directory-file-name attachments-symlink-directory))))
	      (error (format "Not a symlink: %s" attachments-symlink-directory)))

	    ;; update dirs
	    (unless (f-exists-p symlinks-directory)
	      (f-mkdir symlinks-directory))
	    (unless (or (f-exists-p attachments-symlink-directory)
			(not (yant/org-task-has-attachments-p)))
              ;;(debug)
	      (f-symlink attach-path (directory-file-name attachments-symlink-directory)))
	    (when (and (f-exists-p attachments-symlink-directory)
		       (not (yant/org-task-has-attachments-p)))
	      (f-delete (directory-file-name attachments-symlink-directory)))

	    ;; add to parent entry attachment dir
	    (unless (seq-empty-p entry-name) ;; prevent empty folder names
	      (org-with-wide-buffer
	       (let ((entry-symlink-name (if (org-up-heading-safe)
					     (directory-file-name (f-join (let ((org-attach-dir-recursive-p t))
									    (org-attach-dir 'CREATE))
									  yant/org-attach-symlinks-directory
									  entry-name))
					   (or yant/org-attach-file-symlink-path (hack-local-variables))
                                           (when yant/org-attach-file-symlink-path
                                             (unless (file-exists-p yant/org-attach-file-symlink-path) (f-mkdir yant/org-attach-file-symlink-path)))
					   (directory-file-name (f-join (or yant/org-attach-file-symlink-path
									    default-directory)
									entry-name)))))
		 (if (not (f-exists-p entry-symlink-name))
                     (progn
                       ;;(debug)
		       (f-symlink symlinks-directory (directory-file-name entry-symlink-name)))
		   (unless (f-symlink-p entry-symlink-name)
		     (error (format "File exists: %s" entry-symlink-name)))))))

	    ;; check children
            (when (yant/org-subtree-has-attachments-p)
	      (let ((dirs (delete (directory-file-name attachments-symlink-directory)
				  (f-directories symlinks-directory))))
		(org-with-wide-buffer
		 (org-back-to-heading)
		 (let ((subtree-end (save-excursion (org-end-of-subtree))))
		   (forward-line 1)
		   (when (re-search-forward org-heading-regexp subtree-end t)
		     (while (< (point) subtree-end)
		       (when (yant/org-entry-name-cleanup-for-dir)
			 (let ((child-dir (f-join symlinks-directory (yant/org-entry-name-cleanup-for-dir))))
			   (when (yant/org-subtree-has-attachments-p)
			     (unless (member child-dir dirs)
                               (let ((org-attach-dir-recursive-p t))
				 (org-attach-dir 'CREATE)))
			     (setq dirs (delete child-dir dirs)))))
		       (or (yant/outline-get-next-sibling subtree-end)
			   (goto-char subtree-end))))))
		(mapc (lambda (d)
			(let ((dir (f-long d)))
			  (when (f-symlink-p (directory-file-name dir))
			    (f-delete dir) ; delete the dirs, which do not point to children
			    )))
		      dirs)))))))))

(advice-remove 'org-attach-dir #'org-attach-dir@yant/org-attach-ensure-attach-dir-symlink)
#+END_SRC

Now, when I have the mirror attach folder structure, it make sense to open this structure on =org-attach-reveal= instead of opening the actual attach dirs.

*************** HOLD [#A] because of org-attach API change, need to rewrite                                       :HOLD:
:PROPERTIES:
:SHOWFROMDATE: 2020-05-23
:END:
:LOGBOOK:
- State "HOLD"       from "NEXT"          [2020-05-30 Sat 14:24]
:END:
*************** END


#+BEGIN_SRC emacs-lisp
(defun org-attach-dir-symlink (&optional create-if-not-exists-p no-fs-check no-data-dir)
  "Return symlink based path to the attach dir of current entry.
Do not append symlink to data directory if NO-DATA-dir is not nil."
  (org-with-point-at-org-buffer
   (when create-if-not-exists-p
     (let ((symlink (org-attach-dir-symlink nil nil no-data-dir)))
       (when (not (f-exists-p symlink))
	 (org-attach-dir 't))
       symlink))
   (let* ((entry-name (yant/org-entry-name-cleanup-for-dir))
	  (attach-dir-inherited-p (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
				       (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))));; only consider if the entry is the child
          (entry-path (and entry-name
			   (f-join entry-name (if no-data-dir "" yant/org-attach-attachments-symlink-directory)))))
     (if attach-dir-inherited-p
	 (org-with-wide-buffer
          (org-up-heading-safe) ;; if this is false, something went really wrong
	  (org-attach-dir-symlink create-if-not-exists-p nil no-data-dir))
       (unless (seq-empty-p entry-name) ;; prevent empty folders
	 (org-with-wide-buffer
	  (if (org-up-heading-safe)
	      (let ((head-path (org-attach-dir-symlink create-if-not-exists-p nil 't)))
		(when head-path (f-slash (f-join head-path entry-path))))
	    (f-slash (f-join (or yant/org-attach-file-symlink-path
				 default-directory)
			     entry-path)))))))))

(define-advice org-attach-reveal (:around (OLDFUN) reveal-symlink)
  "Go to symlink attach dir structure instead of an actual attach dir."
  (let ((dir (org-attach-dir-get-create))
	(attach-dir-inherited-p (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
				     (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))));; only consider if the entry is the child
	)
    ;; (org-attach-dir@yant/org-attach-ensure-attach-dir-symlink dir)
    (org-attach-sync)
    ;; (cl-letf (((symbol-function 'org-attach-dir-get-create) (if (yant/org-task-has-attachments-p)
    ;; 								(lambda (&rest args) (org-attach-dir-symlink 't nil nil))
    ;; 							      (lambda (&rest args)
    ;; 								(if (yant/org-subtree-has-attachments-p)
    ;; 								    (org-attach-dir-symlink 't nil 't)
    ;; 								  dir
    ;; 								  )))))
    ;;   (when attach-dir-inherited-p (org-attach-tag 'off))
    ;;   (funcall OLDFUN))
    (when attach-dir-inherited-p (org-attach-tag 'off))
    (funcall OLDFUN)
    ))
(advice-remove 'org-attach-reveal #'org-attach-reveal@reveal-symlink)
;; (advice-add 'org-attach-reveal-in-emacs :around #'org-attach-reveal@reveal-symlink)
#+END_SRC
Files, out of the folder structure, will appear in my agenda to attach them to the relevant project (unless explicitly specified in special variable).

*************** TODO implement this
*************** END

#+begin_src emacs-lisp

(provide 'org-attach-fs)

;;; org-attach-fs.el ends here

#+end_src

****** TODO handle cases when we need files in the same dir with the org file [[id:9dc72877-1e7b-4084-a262-6e39b08ced49][LaTeX class]]
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 12:40]
:END:
:LOGBOOK:
CLOCK: [2018-07-09 Mon 12:40]--[2018-07-09 Mon 12:41] =>  0:01
:END:
****** SOMEDAY in org-attach, put the attachments directly into symlink if no children of the entry
:PROPERTIES:
:CREATED:  [2018-08-26 Sun 22:40]
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-08-27 Mon 08:39]
:END:

****** Do not abbreviate file names (to avoid strange folders defined in [[id:9361bc68-010b-45f1-bddd-4638d6344758][org attachments]])
:PROPERTIES:
:CREATED:  [2018-07-25 Wed 17:28]
:ID:       7e252121-b5ba-4f9e-ba55-6eabb75d9a47
:END:
:LOGBOOK:
- Refiled on [2020-04-09 Thu 17:42]
:END:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda ()
      (advice-add 'find-file-noselect :around #'dired-find-file@disable-abbreviate-file-name)))
#+END_SRC
***** DONE Make =:ATTACH_DIR_INHERITED:= work again                                                                                          :NOARCHIVE:
CLOSED: [2020-08-11 Tue 22:10]
:PROPERTIES:
:CREATED:  [2019-07-27 Sat 17:03]
:ID:       58e525e8-18e5-4eb0-8e6d-f8e10ee8f2f1
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"          [2020-08-11 Tue 22:10]
- State "NEXT"       from "HOLD"         [2020-08-11 Tue 22:10]
:END:

#+begin_src emacs-lisp
(define-advice org-attach-dir (:filter-return (dir) yant/org-attach-use-attach-dir-inheritance -100)
  "Use :ATTACH_DIR_INHERIT: property."
  (let ((attach-dir-inherited (and (org-entry-get-with-inheritance "ATTACH_DIR_INHERIT")
  				   (not (org-entry-get (point) "ATTACH_DIR_INHERIT" nil))
				   (org-with-point-at org-entry-property-inherited-from (org-attach-dir)))))
    (or attach-dir-inherited
  	dir)))
;; (advice-remove 'org-attach-dir #'org-attach-dir@yant/org-attach-use-attach-dir-inheritance)
#+end_src

***** Saving web pages into notes
:PROPERTIES:
:CREATED:  [2017-12-30 Sat 22:20]
:ID:       8e1af85e-3e47-40c3-9b33-34a5e848b483
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2018-09-06 Thu 20:53]
- State "TODO"       from              [2017-12-30 Sat 22:20]
:END:

Sometimes, I want to save certain interesting online articles to disk to make sure that all the content and comments are preserved regardless of the website changes.

****** org-webtools
:PROPERTIES:
:CREATED:  [2019-04-23 Tue 23:44]
:ID:       f8a52437-48d9-418a-a00d-c1af5680c230
:END:
:LOGBOOK:
- State "DONE"       from "NEXT"       [2019-04-24 Wed 15:43]
CLOCK: [2019-04-24 Wed 15:23]--[2019-04-24 Wed 15:43] =>  0:20
- State "NEXT"       from "TODO"       [2019-04-23 Tue 23:45]
:END:

With =org-webtools=, I can download and attach web pages to an entry or even insert them converted into org format.

*************** TODO make the web-pages open on C-c C-o
*************** END


#+begin_src emacs-lisp
(use-package org-web-tools
  :if init-flag
  :straight (org-web-tools :host github :repo "alphapapa/org-web-tools"
			   :fork (:host github :repo "yantar92/org-web-tools"))
  :bind (:map org-mode-map
	      ("C-c C-S-u a" . org-web-tools-archive-attach)
	      ("C-c C-S-u o" . org-web-tools-archive-view)
	      ("C-c C-S-u i" . org-web-tools-insert-web-page-as-entry))
  :init (use-package org-web-tools-archive)
  :config
  ;; (setq org-web-tools-archive-fn #'org-web-tools-archive--wget-tar)
  (setq org-web-tools-archive-wget-options
	(append (-remove-item  "--execute robots=off" org-web-tools-archive-wget-options) (list "--max-redirect=100")))
  (setq org-web-tools-archive-wget-html-only-options
	(append (-remove-item  "--execute robots=off" org-web-tools-archive-wget-html-only-options) (list "--max-redirect=100")))
  (setq org-web-tools-pandoc-sleep-time 1.0))
#+end_src

***** =_epilogue=
:PROPERTIES:
:ID:       fdd42cf4-96cb-4c9f-b855-3fb8437f9d9c
:END:
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** Agenda & scheduling
:PROPERTIES:
:ID:       ff70b03f-3876-4b2b-9aab-c3209bd31cb8
:END:
#+begin_src emacs-lisp
(require 'org-agenda)
(setq org-agenda-restore-windows-after-quit t)
(setq org-agenda-window-setup 'only-window)
(setq org-agenda-todo-list-sublevels t)
(setq org-agenda-show-inherited-tags t)
(setq org-agenda-search-headline-for-time nil)
(setq org-agenda-use-time-grid nil)
(setq org-directory "~/Org")
(setq org-agenda-files "~/Org/agenda_files")
(setq org-deadline-warning-days 30)
(setq org-agenda-span 'day)
(setq org-agenda-sorting-strategy '((agenda deadline-down time-up habit-up priority-down timestamp-down category-keep)
				    (todo priority-down category-keep)
				    (tags priority-down category-keep)
				    (search category-keep)))
(setq org-agenda-tags-todo-honor-ignore-options t)
(setf org-agenda-sticky t)
(setq org-agenda-skip-scheduled-if-deadline-is-shown 'not-today
      org-agenda-skip-deadline-prewarning-if-scheduled t)
(setq org-habit-show-habits-only-for-today t) ; do not show habits in future if scheduled withing agenda time range. E.g. do not show future habits in week view/calendar
#+end_src

Agendas is my main entry point into daily work. This is where I pickup tasks to work on during the day. I generally use a combination of GTD and "Eating Live Frogs: Do the Worst Thing First" (see [[id:8d4483f2-7a4f-4508-b403-f8635e33a34e][Rainer König: Orgmode-TV: How do I plan my days]], [[id:979c767f-0355-4b6d-86a1-1e10d5fa9202][The Ultimate Guide to Personal Productivity Methods]]), though I am not disciplined enough to follow the latter precisely. In addition, I sometimes use [[id:ee371af1-c478-49d1-9814-1eb78242a341][Pomodoro]], [[id:435d7660-576f-42d0-88fd-9882f494712c][Time blocking]] (kind of), and [[id:38d9103d-a969-4c69-ae0e-a9a50912fba0][Bonus/penalty based time management]]. These methods works fine for me at this point, though many more methods do exist [[id:979c767f-0355-4b6d-86a1-1e10d5fa9202][The Ultimate Guide to Personal Productivity Methods]].

- I use several agenda views
  - Focused daily agenda :: When we mark the item scheduled, it means that we need to start working on it from that day. However, it leads to a situation when there are so many items being active in agenda that it is useful to focus on what we need to do during the day. That's why I need an additional agenda which focuses on what I really need to do today, but not what I need to start today and what I have started to do which is the case for default daily agenda. See [[id:a6054643-449e-48d7-afff-4155465efc19][Focused daily agenda]].
    
    Indeed, this agenda may as well grow over time. So, I always try to keep it as short as possible: just daily chores + really important things I need to work on. If this agenda grows too much, I consider marking some tasks as HOLD or WAITING and come back to them when I finish the more important tasks. Ideally, there should be no more than 3 big tasks (not chores) to work on each day. Similar concepts are discussed in [[id:6cd01980-7d3f-47c8-8d2f-f2ab43c8b08c][Dave Lee — GTD sucks for creative work. Here's an...]]

  - Normal daily agenda :: Standard agenda with minor tweaks. A can work on it when/if I finish with focused agenda.
  - Inbox agenda view for captured tasks :: The new tasks and notes I added recently. They must be refiled somewhere. I am not trying to do tasks from here rightaway, but rather just classify the tasks to look at them later in appropriate time. For example, looking into some youtube bookmarks rightaway would not be wise.
  - Hanging tasks :: The new tasks, which have been refiled, but I did not look into details yet. For example, there can be some online bookmarks I plan to look into, but I only looked into their title so far. I will need some small time to decide if I even want to work on those and when I want to do it. This is the lowest priority agenda during a day. I may or may not look into it on daily basis.
  - Full agenda for GTD self-check :: see [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]].
  - List of projects agenda :: List of all active projects.

I use different skip functions here in agenda to filter the agenda. Some of them are used, some of them are just kept here for future if I need them.
  #+begin_src emacs-lisp
(defun bh/skip-non-stuck-projects-and-non-next-subprojects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
					;      (if (bh/is-project-p)
      (if (and (bh/is-project-p)
	       (not (member (org-get-todo-state) (list "SOMEDAY")))
	       (or (not (bh/is-subproject-p))
		   (member (org-get-todo-state) (list "NEXT" "DOING"))))
	  (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
		 (has-next ))
	    (save-excursion
	      (forward-line 1)
	      (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ \\(NEXT\\|DOING\\) " subtree-end t))
		(unless (member "WAITING" (org-get-tags nil t))
		  (setq has-next t))))
	    (if has-next
		next-headline
	      nil)) ; a stuck project, has subtasks but no next task
	next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  ;;  (if (save-restriction (bh/skip-non-stuck-projects-and-non-next-subprojects))
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((and (bh/is-project-p) (not (bh/is-subproject-p)))
	nil)
       (t
	subtree-end)))
    ))
(defun bh/skip-non-tasks ()
  "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
	nil)
       (t
	next-headline)))))
(defun bh/skip-subprojects ()
  "Show non-subproject tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((not (bh/is-subproject-p))
	nil)
       (t
	next-headline)))))

(defun yant/org-is-habit-p (&optional subtree-end pom)
  "Faster implementation of `org-is-habit-p'.
Returns t if entry at POM is habit.
SUBTREE-END is used as end of the entry if not nil."
  (save-excursion
    (and pom (goto-char pom))
    (re-search-forward "^ *:STYLE: +habit"
		       (or subtree-end
			   (save-excursion (or (outline-next-heading) (point-max))))
		       t)))

(defun bh/skip-habits ()
  "Skip habits"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (yant/org-is-habit-p next-headline)
	  next-headline
	nil))))

(defun bh/skip-nohabits ()
  "Skip not habits."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (yant/org-is-habit-p next-headline)
	  nil
	next-headline))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
	next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
	     (member "WAITING" (org-get-tags nil t)))
	next-headline)
       ((bh/is-project-p)
	next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
	next-headline)
       (t
	nil)))))
(defun zin/org-agenda-skip-tag (tag &optional others)
  "Skip all entries that correspond to TAG.
      If OTHERS is true, skip all entries that do not correspond to TAG."
  (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
    (if others
	(if (not (member tag (org-get-tags-at)))
	    next-headline
	  nil)
      (if (member tag (org-get-tags-at))
	  next-headline
	nil))))
  #+end_src
  #+begin_src emacs-lisp
(set-face-attribute 'org-agenda-structure nil
		    :height 120
                    :foreground "firebrick")
(set-face-attribute 'org-agenda-date-today nil
                    :foreground "dark goldenrod")


(defvar bh/hide-scheduled-and-waiting-next-tasks 't)
(setq org-agenda-skip-function nil)
(define-advice org-agenda-skip (:before (&rest args) make-sure-right-org-environment)
  ""
  )
(setq org-agenda-custom-commands
      (quote (("a" nil
	       agenda ""
	       ((org-agenda-skip-function '(or
					    (zin/org-agenda-skip-tag "HOLD")
                                            (zin/org-agenda-skip-tag "WAITING")
					    (org-agenda-skip-before-SHOWFROMDATE-property)
					    (org-agenda-skip-before-SHOWFROMTIME-property)
					    (org-agenda-skip-noshowdates)
                                            (org-agenda-skip-entry-if 'nottodo 'any)))))
	      ("p" "Projects" tags-todo "-CANCELLED-AREA"
	       ((org-agenda-overriding-header "Project list\n")
		(org-agenda-prefix-format "%?-12t")
		(org-agenda-skip-function 'bh/skip-non-projects)
		(org-agenda-sorting-strategy
		 '(todo-state-down effort-up category-keep))))
	      ("d" "Focus daily agenda" agenda ""
	       ((org-agenda-overriding-header "Focused daily agenda")
		(org-agenda-skip-function '(or
					    (zin/org-agenda-skip-tag "HOLD")
					    (yant/org-agenda-skip-nofocus)))))
	      ("i" "Inbox items"
	       ((tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "Inbox\n")
                       (org-agenda-files '("~/Org/inbox.org"))
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notscheduled)))
		       (org-agenda-prefix-format "S\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
                       (org-agenda-files '("~/Org/inbox.org")) 
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notdeadline)))
		       (org-agenda-prefix-format "D\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
                       (org-agenda-files '("~/Org/inbox.org")) 
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'scheduled 'deadline)))
		       (org-agenda-prefix-format "\t\t%-12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))))
              ("h" "Hanging tasks"
               ((tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT-SOMEDAY+TODO=\"TODO\""
			   ((org-agenda-overriding-header "All other active tasks")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits))))))))
              ("n" "NEXT and REVIEW tasks"
	       ((tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT-SOMEDAY+TODO=\"REVIEW\""
			   ((org-agenda-overriding-header "Tasks to review")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  ;; (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits))))))
		(tags-todo "-CANCELLED-HOLD-WAITING-SKIP-SOMEDAY+TODO=\"NEXT\""
			   ((org-agenda-overriding-header (concat "Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))
		(tags-todo "-CANCELLED-HOLD-WAITING+SKIP-SOMEDAY+TODO=\"NEXT\""
			   ((org-agenda-overriding-header (concat "Extra Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))))
	      ("v" "GTD overview"
	       ((agenda "-HOLD-SOMEDAY"
			((org-agenda-prefix-format "%-12s\t%-12:c\t%?-12t")
			 (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'any))))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "Inbox")
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))
			    (org-agenda-prefix-format "S\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
			    (org-agenda-prefix-format "D\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))
			    (org-agenda-prefix-format "\t\t%-12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags "/"
		      ((org-agenda-overriding-header "Tasks to Archive")
		       (org-agenda-prefix-format "%-12:c\t%?-12t")
		       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		       (org-tags-match-list-sublevels nil)))
		(tags-todo "-CANCELLED-WAITING-HOLD-SOMEDAY"
			   ((org-agenda-overriding-header "Stuck Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-stuck-projects-and-non-next-subprojects)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(category-keep))))
		(tags-todo "-CANCELLED+WAITING|HOLD"
			   ((org-agenda-overriding-header (concat "Waiting and Hold Tasks" ""))
			    (org-agenda-prefix-format "%-12:c\t%?-12t %(yant/format-summary-for-agenda)")
			    (org-use-tag-inheritance nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
			    (org-tags-match-list-sublevels nil)
			    (org-agenda-sorting-strategy
			     '(todo-state-down))))
		(tags-todo "-CANCELLED-HOLD-WAITING-SKIP-SOMEDAY+TODO=\"NEXT\""
			   ((org-agenda-overriding-header (concat "Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))
		(tags-todo "-CANCELLED-HOLD-WAITING+SKIP-SOMEDAY+TODO=\"NEXT\""
			   ((org-agenda-overriding-header (concat "Extra Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))
                (tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT-SOMEDAY+TODO=\"REVIEW\""
			   ((org-agenda-overriding-header "Tasks to review")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  ;; (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits))))))
		(tags-todo "-CANCELLED-AREA"
			   ((org-agenda-overriding-header "Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-projects)
			    (org-agenda-sorting-strategy
			     '(todo-state-down effort-up category-keep))))
                (tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT-SOMEDAY+TODO=\"TODO\""
			   ((org-agenda-overriding-header "All other active tasks")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits))))))
                (tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT+TODO=\"SOMEDAY\""
			   ((org-agenda-overriding-header "Someday tasks outside projects")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (bh/skip-subprojects)
							  (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits)))))))
	       nil))))
  #+end_src
***** Location contexts
:PROPERTIES:
:CREATED:  [2020-07-14 Tue 17:16]
:ID:       1d3102c9-e7bd-490d-9799-3b0c86cf07c0
:END:

Every agenda view is filtered by location context.
By location context, I mean tags like =@home=, =@work=, =@meeting=, etc
The tags imply that the tagged tasks can only be done when I am physically located in certain place.
Every time I build a new agenda (but not when I update it), I am asked about the current location context (from the list of available =@*= tags in agenda).

Also, no contexts are prompted in Inbox agenda.

#+begin_src emacs-lisp
(use-package org-agenda
  :if init-flag
  :after org
  :config

  (add-hook 'org-agenda-finalize-hook #'yant/org-agenda-filter-by-location-context)
  (setq org-agenda-persistent-filter t)
  
  (defun yant/org-agenda-filter-by-location-context ()
    "Filter current agenda by location context.
  This command offers all the @* tags.
  Only items without any @* tags and the items with selected @* tags will be shown in agenda."
    (interactive)
    (unless (eq major-mode 'org-agenda-mode) (user-error "Cannot run %s outside agenda view" this-command))
    (when (and (memq this-command '(org-agenda yant/org-agenda-filter-by-location-context))
	       (not (string= org-agenda-name "Inbox items")))
      (unless (local-variable-p 'org-global-tags-completion-table)
	(setq-local org-global-tags-completion-table
		    (org-global-tags-completion-table)))
      (let ((location-tags (seq-filter (apply-partially #'s-matches-p "^@.+") (mapcar #'car org-global-tags-completion-table)))
	    tags
	    tag-filter)
	(let ((completion-ignore-case t))
	  (setq tags (helm-comp-read
		      "Tags: " location-tags :must-match t :name "Select location context")))
	(when tags
	  (unless (listp tags) (setq tags (list tags)))
	  (let ((tags-exclude (seq-difference location-tags tags)))
	    (when tags-exclude
	      (setq org-agenda-tag-filter (mapcar (lambda (tag)
						    (concat "-" tag))
                                                  tags-exclude))
	      (org-agenda-filter-apply org-agenda-tag-filter 'tag t))))))))
#+end_src


***** Focused daily agenda
:PROPERTIES:
:ID:       a6054643-449e-48d7-afff-4155465efc19
:END:
This agenda show the items for the current day and time.

- all the items with deadline, according =org-deadline-warning-days=, unless the item is scheduled. If the item is scheduled, it is shown from the scheduled day.
  #+begin_src emacs-lisp
(defun org-agenda-skip-deadlines-before-schedule ()
  "Skip tasks, with deadline and scheduled in future and tasks without deadline."
  (require 'org-agenda)
  (save-restriction
    (let* ((tmp-deadline-time (flet ((org-back-to-heading (&rest args) t)) ; we should be at heading already and it consumes too much times otherwise
				(org-get-deadline-time (point))))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-deadline (time-to-days tmp-deadline-time))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (when (or
	     (not tmp-deadline-time)
	     (and
	      tmp-scheduled-time
	      tmp-deadline-time
	      (> tmp-cur-schedule tmp-cur-day)
	      ;;(> tmp-cur-deadline tmp-cur-day)
	      ))
	(re-search-forward (org-get-limited-outline-regexp) nil 'noerror)
	(point)))))
  #+end_src
- all [#A] priority items, with matching =:SHOWDATES:= and =:SHOWFROMTIME:=, unless they are scheduled in the future
  #+begin_src emacs-lisp
(defun org-agenda-skip-nonurgent ()
  (save-excursion
    (let* ((cur-priority (org-entry-get (point) "PRIORITY"))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (unless (and (string-equal cur-priority "A")
		   (or (not tmp-scheduled-time)
		       (<= tmp-cur-schedule tmp-cur-day)))
	(unless (re-search-forward "^\\*.+\\[#A\\]" nil 'noerror)
	  (re-search-forward org-outline-regexp nil 'noerror))
	(point)))))

(defun org-agenda-skip-nonurgent-fast ()
  (save-excursion
    (let ((element (org-element-at-point)))
      (unless (or (eq (car element) 'inlinetask)
		  (eq (car element) 'headline))
        (org-back-to-heading)
        (setq element (org-element-at-point)))
      (let* ((cur-priority (string (or (org-element-property :priority element)
				       org-default-priority)))
             (tmp-scheduled-time-element (org-element-property :raw-value
							       (org-element-property :scheduled
										     element)))
             (tmp-scheduled-time (and tmp-scheduled-time-element (org-parse-time-string tmp-scheduled-time-element)))
	     (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	     (tmp-cur-day (time-to-days (apply #'encode-time
					       (append '(0 0 0)
						       (list (nth 1 org-agenda-current-date))
						       (list (nth 0 org-agenda-current-date))
						       (list (nth 2 org-agenda-current-date)))))))
	(unless (and (string-equal cur-priority "A")
		     (or (not tmp-scheduled-time)
			 (<= tmp-cur-schedule tmp-cur-day)))
	  (unless (re-search-forward "^\\*.+\\[#A\\]" nil 'noerror)
	    (re-search-forward (org-get-limited-outline-regexp) nil 'noerror))
	  (point))))))
  #+end_src
  
*************** SOMEDAY [#A] debug =org-agenda-skip-nonurgent-fast=                                              :SOMEDAY:
:PROPERTIES:
:SHOWFROMDATE: 2019-08-06
:END:
:LOGBOOK:
CLOCK: [2019-05-06 Mon 12:49]--[2019-05-06 Mon 14:14] =>  1:25
CLOCK: [2019-05-06 Mon 11:34]--[2019-05-06 Mon 11:53] =>  0:19
- State "NEXT"       from "TODO"       [2019-05-05 Sun 18:42]
:END:
*************** END
- none of [#C] priority items
#+BEGIN_SRC emacs-lisp
(defun org-agenda-skip-lowpriority ()
  (save-restriction
    (widen)
    (let* (
	   (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (cur-priority (org-entry-get (point) "PRIORITY")))
      (if (string-equal cur-priority "C")
	  next-headline
	nil))))
#+END_SRC
- all the items scheduled for today and matching =:SHOWFROMTIME:=
  #+begin_src emacs-lisp
(defun org-agenda-skip-not-today ()
  "Skip items which are not scheduled today or scheduled earlier today."
  (save-restriction
    (widen)
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (scheduleddate (subseq (decode-time (org-get-scheduled-time (point))) 3 6))
	   (currentdate	(list (nth 1 org-agenda-current-date) (nth 0 org-agenda-current-date) (nth 2 org-agenda-current-date)))
           (scheduledhourend (org-element-property
			      :hour-end
			      (org-element-property
                               :scheduled
                               (org-element-at-point))))
           (currenthour (string-to-number (format-time-string "%H"))))
      (if (and (equal scheduleddate currentdate)
	       (or (not scheduledhourend)
		   (<= currenthour scheduledhourend)))
	  nil
        next-headline))))
  #+end_src
- all items scheduled in the past or today with DOING todo keyword, respecting =:SHOWFROMTIME:= and =:SHOWDATES:=
- items from diary/with timestamps (shown by default in org)
- habits
*************** TODO can I do it with standard org capabilities? (at least, partially)
#+begin_src emacs-lisp :tangle no
(setq org-agenda-skip-deadline-prewarning-if-scheduled t)
 (setq org-agenda-skip-scheduled-if-done t)
 (setq org-agenda-skip-timestamp-if-done t)
#+end_src
*************** END

  #+begin_src emacs-lisp
(defun yant/org-agenda-skip-nofocus()
  "Filter tasks for focus agenda."
  (and
   (or
    (and
     ;; (not (equal "DOING" (org-get-todo-state)))
     (org-agenda-skip-nonurgent) ; show urgent items
     (bh/skip-nohabits) ; and habits
     )
					;  if day and time are appropriate
    (org-agenda-skip-before-SHOWFROMTIME-property)
    (org-agenda-skip-before-SHOWFROMDATE-property)
    (org-agenda-skip-noshowdates))
   (or
    (org-agenda-skip-not-today) ; and items, scheduled for today
    (org-agenda-skip-before-SHOWFROMTIME-property) ; if time is appropriate (day is, since it is scheduled)
    (org-agenda-skip-before-SHOWFROMDATE-property)
    (org-agenda-skip-lowpriority) ;; and the priorty is not [#C]
    )
   (or (org-agenda-skip-deadlines-before-schedule) ; always show deadlines, unless scheduled in future
       (org-agenda-skip-before-SHOWFROMTIME-property)
       (org-agenda-skip-before-SHOWFROMDATE-property))))
  #+end_src
***** Normal daily agenda
:PROPERTIES:
:ID:       f50074e7-42b2-4da5-9421-04ec9deccf07
:END:
This is a standard org mode agenda showing deadlines, schedules, diary items and items with timestamps.
#+begin_src emacs-lisp
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-include-inactive-timestamps nil)
#+end_src
***** GTD self-check
:PROPERTIES:
:ID:       d110dae9-f563-48bb-8293-a10b1afbe772
:END:
1. Full daily agenda without hold tasks
2. =INBOX= items to refile to other places
   - scheduled
   - with deadline
   - not scheduled
3. Next tasks which are not yet scheduled
4. Done tasks to archive, unless have =:NOARCHIVE:= tag.
5. Project list
6. Waiting and hold tasks, which are not scheduled
7. Other tasks which are not part of project or has =SKIP= tag. Useful to catch wrong refiles and look for the new things to do. Blocked tasks are not shown here.

***** Captured items, which should be refiled
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 22:28]
:ID:       18a47cca-2dfa-4e27-9814-a2edfd54a9f4
:END:
These items should have =:INBOX:= tag. Also, if both project and sub-project have =:INBOX:= tag, only topmost project should be refiled.
#+BEGIN_SRC emacs-lisp
(defun yant/org-agenda-inbox-items ()
  "Only show items with INBOX tag, which parents does not have this tag."
  (save-excursion
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point)))
	    (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	    result)
	(if (not (member "INBOX" (org-get-tags-at)))
	    next-headline
	  (while (and (not result)
		      (org-up-heading-safe))
	    (when (member "INBOX" (org-get-tags-at))
	      (setq result next-headline)))
	  result)))))
#+END_SRC

Since my org files are really very large, it usually takes a lot of time to rebuild agenda. In the case of refiling, the =org-agenda-refile= rebuilds the agenda after each refiling, which really slows down my refile workflow. Hence, I disable redoing the current agenda after running =org-agenda-refile= or =org-agenda-bulk-action=.

#+begin_src emacs-lisp
(defun yant/org-agenda-refile (&optional arg)
  (interactive "P")
  (funcall-interactively #'org-agenda-refile arg nil 'no-update))

(bind-key "C-c C-w" #'yant/org-agenda-refile org-agenda-mode-map)
(bind-key "C-c w" #'yant/org-agenda-refile org-agenda-mode-map)

(define-advice org-agenda-bulk-action (:around (oldfun &optional arg) disable-org-agenda-redo)
  "Disable `org-agenda-redo' for all the bulk actions."
  (flet ((org-agenda-redo () "" nil))
    (funcall oldfun)))
#+end_src

***** TODO Ever standing project list
***** TODO [#A] org-timeline
:PROPERTIES:
:CREATED:  [2019-07-11 Thu 14:51]
:ID:       2e34a6d8-e1c6-4261-aaf0-40764571b445
:SHOWFROMDATE: 2019-08-02
:END:
:LOGBOOK:
CLOCK: [2019-07-12 Fri 17:10]--[2019-07-12 Fri 17:44] =>  0:34
CLOCK: [2019-07-12 Fri 17:01]--[2019-07-12 Fri 17:07] =>  0:06
:END:

The package idea is cool, but I would prefer vertical view. Need to write my own package later.

#+begin_src emacs-lisp
(use-package org-timeline
  :if init-flag
  :disabled
  :straight t
  :config
  (add-hook 'org-agenda-finalize-hook 'org-timeline-insert-timeline :append))
#+end_src

***** =CalFW=
:PROPERTIES:
:ID:       1d03f6e7-0f52-4aad-926e-a6762cd2d7dc
:END:
Agenda is excellent for short term planning, however it is not very useful if I need to schedule something, say, for 3 month later. I prefer something like normal calendar with short summary of the scheduled tasks to plan the task being scheduled.
#+begin_src emacs-lisp
(use-package calfw
  :if init-flag
  :straight t
  :config
  (use-package calfw-org
    :straight t
    :config
    (setq calendar-week-start-day 1)
    (defun cfw:open-calendar ()
      (interactive)
      (let ((cp
	     (cfw:create-calendar-component-buffer
	      :view 'week
	      :contents-sources
	      (list
	       (cfw:org-create-source)))))
	(switch-to-buffer (cfw:cp-get-buffer cp))))
    (use-package boon
      :config
      (bind-key "A" 'cfw:open-calendar 'boon-goto-map))
    (custom-set-faces
     '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
     '(cfw:face-header ((t (:foreground "#d0bf8f" :weight bold))))
     '(cfw:face-sunday ((t :foreground "#cc9393" :background "grey10" :weight bold)))
     '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "grey10" :weight bold)))
     '(cfw:face-holiday ((t :background "grey10" :foreground "#8c5353" :weight bold)))
     '(cfw:face-grid ((t :foreground "DarkGrey")))
     '(cfw:face-default-content ((t :foreground "#bfebbf" :height 0.7)))
     '(cfw:face-periods ((t :foreground "cyan")))
     '(cfw:face-day-title ((t :background "grey10")))
     '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
     '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
     '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
     '(cfw:face-today-title ((t :background "#7f9f7f" :weight bold)))
     '(cfw:face-today ((t :background: "grey10" :weight bold)))
     '(cfw:face-select ((t :background "#2f2f2f")))
     '(cfw:face-toolbar ((t :foreground "Steelblue4" :background "Steelblue4")))
     '(cfw:face-toolbar-button-off ((t :foreground "Gray10" :weight bold)))
     '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold))))
    ;; Unicode characters
    (setq cfw:fchar-junction ?╋
	  cfw:fchar-vertical-line ?┃
	  cfw:fchar-horizontal-line ?━
	  cfw:fchar-left-junction ?┣
	  cfw:fchar-right-junction ?┫
	  cfw:fchar-top-junction ?┯
	  cfw:fchar-top-left-corner ?┏
	  cfw:fchar-top-right-corner ?┓)))
#+end_src
***** TODO COMMENT =Gcal= - sync with Google calendar
:PROPERTIES:
:ID:       b66193fa-9189-4822-b68f-87f5bc30c3fd
:END:
:LOGBOOK:
- State "TODO"       from              [2019-05-10 Fri 00:23]
:END:
****** General setup
:PROPERTIES:
:ID:       9eda87f8-8e84-4b3d-b5a6-876ba287c7bb
:END:
#+begin_src emacs-lisp
(use-package org-gcal
  :if init-flag
  :straight t
  :config
  (setq org-gcal-down-days 360)
  (setq org-gcal-sync-idle-secs (* 60 20)) ; 20 min
  (defun org-gcal-sync-enable ()
    "Enable gcal idle sync."
    (interactive)
    (setq org-gcal-sync-timer
	  (run-with-idle-timer org-gcal-sync-idle-secs t
			       'org-gcal-sync)))
  (defun org-gcal-sync-disable ()
    "Disable mobile org idle sync."
    (interactive)
    (cancel-timer org-gcal-sync-timer))
  (org-gcal-sync-enable))
#+end_src
****** TODO Avoid duplicates in agenda for =gcal= entries and other entries

Usually, I have some events scheduled locally in my computer and some are scheduled in Google calendar. Of course, I want to see both. It is easy - just add my =gcal= org file to agenda. However, the problem appears when I want to see locally scheduled events in Google Calendar (for mobile notifications). In such a case I need to copy the entries from my local org files to =GCal=. In such a case, these entries appears in my local agenda twice, which is annoying.
****** Suppress =libnotify= notifications
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 21:18]
:ID:       a818576a-f55a-428b-86e9-0df97ae445c1
:END:
#+BEGIN_SRC emacs-lisp
(define-advice org-gcal--notify (:around (OLDFUN &rest args) org-gcal-force-message-notifications)
  "Force org-gcal to use message area notifications, not libnotify (it is too spammy)."
  (let ((alert-default-style 'message))
    (apply OLDFUN args)))
#+END_SRC
***** Handling different time zones in time stamps                                                :ARCHIVE:
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 18:36]
:END:
It is sometimes very annoying when org mode assumes that all the time
stamps are in local time zone. Foe example, I have a round flight, and
want to schedule it to not forget coming back ;). But the timing will
be shifted for return flight if I go to different time zone. Hence I
would like to have some way to fix the time zone of time stamp. I do
it by defining time stamp like =<YYYY-MM-DD HH:MM #TIMEZONE#>=, where
=TIMEZONE= is time zone as in =/usr/share/zoneinfo=.
It is implemented by wrapping the hook to correct the time around
=org-parse-time-string=, which seems to be enough to correct org mode
behavior. The stamps without time are not parsed (how?).
*************** NEXT [#A] Make sure it works
SCHEDULED: <2017-12-23 Sat>
:LOGBOOK:
CLOCK: [2017-12-24 Sun 15:55]--[2017-12-24 Sun 17:52] =>  1:57
CLOCK: [2017-12-24 Sun 15:24]--[2017-12-24 Sun 15:54] =>  0:30
CLOCK: [2017-12-24 Sun 15:00]--[2017-12-24 Sun 15:24] =>  0:24
CLOCK: [2017-12-24 Sun 11:51]--[2017-12-24 Sun 13:15] =>  1:24
CLOCK: [2017-12-24 Sun 09:26]--[2017-12-24 Sun 10:12] =>  0:46
CLOCK: [2017-12-24 Sun 08:23]--[2017-12-24 Sun 09:26] =>  1:03
CLOCK: [2017-12-24 Sun 08:01]--[2017-12-24 Sun 08:09] =>  0:08
:END:
- agenda does not use =org-parse-time-string= to find displayed string
  in timeline, even though task will be shown/not shown respecting time zone
*************** END
#+begin_src emacs-lisp :tangle no
;; force matching of time zone formatted time stamps
(setf org-scheduled-time-hour-regexp (concat "\\<" org-scheduled-string
					     " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(setf org-deadline-time-hour-regexp (concat "\\<" org-deadline-string
					    " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-parse-timezone)
  "Convert time stamp to local time if time zone information is present.
Do not handle time stamps without time.
Time zone is located like '<YYYY-MM-DD HH:MM #TIMEZONE#>'.
TIMEZONE is according to system timezone format (as accepted by `current-time-zone')."
  (let ((return-val (funcall oldfun s NODEFAULT)))
    (if (and (string-match org-ts-regexp0 s)
	     (not NODEFAULT))
	(if (string-match "#\\([^#]+\\)#" s)
	    (let ((result (decode-time (- (float-time (apply 'encode-time
							     return-val))
					  (- (car (current-time-zone nil (match-string 1 s)))
					     (car (current-time-zone)))))))
	      (setf (car result) 0)
              (append (butlast result 3) '(nil nil nil)))
	  return-val)
      return-val)))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-convert-atpm-to-24)
  "Honor am/pm format by `org-parse-time-string'."
  (let* ((match (string-match " *#[^#]+#" s)) ; avoid infinite recursion loop with time zone parsing in `org-get-time-of-day'
	 (timeofday (org-get-time-of-day (if match
					     (replace-match "" nil nil s)
					   s)
					 'string)))
    (if (or (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *" s)
	    (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *" s))
	(funcall oldfun (replace-match timeofday nil nil s) NODEFAULT)
      (funcall oldfun s NODEFAULT))))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-timestamp-parse-no-date)
  "Make `org-parse-time-string' work with time stamps without date (just consider today)."
  (when (and (not (string-match "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}" s))
	     (or (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *\\)" s)
		 (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *\\)" s)))
    (setf s (replace-match (concat (format-time-string "%Y-%m-%d %a " (org-matcher-time "<today>"))
				   "\\&")
			   nil nil s)))
  (funcall oldfun s NODEFAULT))

(define-advice org-get-time-of-day (:around (oldfun s &optional string mod24) org-timestamp-convert-to-local-timezone)
  "Convert time stamp with #TIMEZONE# to time stamp in local time zone."
  (if (string-match "#[^#]+#" s)
      (funcall oldfun (format-time-string "%Y-%m-%d %k:%M"
					  (apply #'encode-time
						 (org-parse-time-string s)))
	       string mod24)
    (funcall oldfun s string mod24)))
#+end_src
Unfortunately, =org-agenda-get-scheduled= has hard coded setting to
calculate time of the entry and not respecting =org-parse-timestring= or
=org-get-time-of-day=. Hence, I need to rewrite it just for sake of
changing =(concat (substring s (match-beginning 1)) " "))= into =(concat
(org-get-time-of-day s t) " ")).=
#+begin_src emacs-lisp :tangle no
(defun org-agenda-get-scheduled (&optional deadlines with-hour)
  "Return the scheduled information for agenda display.
Optional argument DEADLINES is a list of deadline items to be
displayed in agenda view.  When WITH-HOUR is non-nil, only return
scheduled items with an hour specification like [h]h:mm."
  (let* ((props (list 'org-not-done-regexp org-not-done-regexp
		      'org-todo-regexp org-todo-regexp
		      'org-complex-heading-regexp org-complex-heading-regexp
		      'done-face 'org-agenda-done
		      'mouse-face 'highlight
		      'help-echo
		      (format "mouse-2 or RET jump to Org file %s"
			      (abbreviate-file-name buffer-file-name))))
	 (regexp (if with-hour
		     org-scheduled-time-hour-regexp
		   org-scheduled-time-regexp))
	 (today (org-today))
	 (todayp (org-agenda-today-p date)) ; DATE bound by calendar.
	 (current (calendar-absolute-from-gregorian date))
	 (deadline-pos
	  (mapcar (lambda (d)
		    (let ((m (get-text-property 0 'org-hd-marker d)))
		      (and m (marker-position m))))
		  deadlines))
	 scheduled-items)
    (goto-char (point-min))
    (while (re-search-forward regexp nil t)
      (catch :skip
	(unless (save-match-data (org-at-planning-p)) (throw :skip nil))
	(org-agenda-skip)
	(let* ((s (match-string 1))
	       (pos (1- (match-beginning 1)))
	       (todo-state (save-match-data (org-get-todo-state)))
	       (donep (member todo-state org-done-keywords))
	       (show-all (or (eq org-agenda-repeating-timestamp-show-all t)
			     (member todo-state
				     org-agenda-repeating-timestamp-show-all)))
	       ;; SCHEDULE is the bare scheduled date, i.e., without
	       ;; any repeater if non-nil, or last repeat if SHOW-ALL
	       ;; is nil.  REPEAT is the closest repeat after CURRENT,
	       ;; if all repeated time stamps are to be shown, or
	       ;; after TODAY otherwise.  REPEAT only applies to
	       ;; future dates.
	       (schedule (if show-all (org-agenda--timestamp-to-absolute s)
			   (org-agenda--timestamp-to-absolute
			    s today 'past (current-buffer) pos)))
	       (repeat (cond ((< current today) schedule)
			     (show-all
			      (org-agenda--timestamp-to-absolute
			       s current 'future (current-buffer) pos))
			     (t
			      (org-agenda--timestamp-to-absolute
			       s today 'future (current-buffer) pos))))
	       (diff (- current schedule))
	       (warntime (get-text-property (point) 'org-appt-warntime))
	       (pastschedp (< schedule today))
	       (habitp (and (fboundp 'org-is-habit-p) (org-is-habit-p)))
	       (suppress-delay
		(let ((deadline (and org-agenda-skip-scheduled-delay-if-deadline
				     (org-entry-get nil "DEADLINE"))))
		  (cond
		   ((not deadline) nil)
		   ;; The current item has a deadline date, so
		   ;; evaluate its delay time.
		   ((integerp org-agenda-skip-scheduled-delay-if-deadline)
		    ;; Use global delay time.
		    (- org-agenda-skip-scheduled-delay-if-deadline))
		   ((eq org-agenda-skip-scheduled-delay-if-deadline
			'post-deadline)
		    ;; Set delay to no later than DEADLINE.
		    (min (- schedule
			    (org-agenda--timestamp-to-absolute deadline))
			 org-scheduled-delay-days))
		   (t 0))))
	       (ddays
		(cond
		 ;; Nullify delay when a repeater triggered already
		 ;; and the delay is of the form --Xd.
		 ((and (string-match-p "--[0-9]+[hdwmy]" s)
		       (> current schedule))
		  0)
		 (suppress-delay
		  (let ((org-scheduled-delay-days suppress-delay))
		    (org-get-wdays s t t)))
		 (t (org-get-wdays s t)))))
	  ;; Display scheduled items at base date (SCHEDULE), today if
	  ;; scheduled before the current date, and at any repeat past
	  ;; today.  However, skip delayed items and items that have
	  ;; been displayed for more than `org-scheduled-past-days'.
	  (unless (and todayp
		       habitp
		       (bound-and-true-p org-habit-show-all-today))
	    (when (or (and (> ddays 0) (< diff ddays))
		      (> diff org-scheduled-past-days)
		      (> schedule current)
		      (and (< schedule current)
			   (not todayp)
			   (/= repeat current)))
	      (throw :skip nil)))
	  ;; Possibly skip done tasks.
	  (when (and donep
		     (or org-agenda-skip-scheduled-if-done
			 (/= schedule current)))
	    (throw :skip nil))
	  ;; Skip entry if it already appears as a deadline, per
	  ;; `org-agenda-skip-scheduled-if-deadline-is-shown'.  This
	  ;; doesn't apply to habits.
	  (when (pcase org-agenda-skip-scheduled-if-deadline-is-shown
		  ((guard
		    (or (not (memq (line-beginning-position 0) deadline-pos))
			habitp))
		   nil)
		  (`repeated-after-deadline
		   (>= repeat (time-to-days (org-get-deadline-time (point)))))
		  (`not-today pastschedp)
		  (`t t)
		  (_ nil))
	    (throw :skip nil))
	  ;; Skip habits if `org-habit-show-habits' is nil, or if we
	  ;; only show them for today.  Also skip done habits.
	  (when (and habitp
		     (or donep
			 (not (bound-and-true-p org-habit-show-habits))
			 (and (not todayp)
			      (bound-and-true-p
			       org-habit-show-habits-only-for-today))))
	    (throw :skip nil))
	  (save-excursion
	    (re-search-backward "^\\*+[ \t]+" nil t)
	    (goto-char (match-end 0))
	    (let* ((category (org-get-category))
		   (inherited-tags
		    (or (eq org-agenda-show-inherited-tags 'always)
			(and (listp org-agenda-show-inherited-tags)
			     (memq 'agenda org-agenda-show-inherited-tags))
			(and (eq org-agenda-show-inherited-tags t)
			     (or (eq org-agenda-use-tag-inheritance t)
				 (memq 'agenda
				       org-agenda-use-tag-inheritance)))))
		   (tags (org-get-tags-at nil (not inherited-tags)))
		   (level
		    (make-string (org-reduced-level (org-outline-level)) ?\s))
		   (head (buffer-substring (point) (line-end-position)))
		   (time
		    (cond
		     ;; No time of day designation if it is only
		     ;; a reminder.
		     ((and (/= current schedule) (/= current repeat)) nil)
		     ((string-match " \\([012]?[0-9]:[0-9][0-9]\\)" s)
		      (concat (org-get-time-of-day s t) " "))
		     (t 'time)))
		   (item
		    (org-agenda-format-item
		     (pcase-let ((`(,first ,next) org-agenda-scheduled-leaders))
		       (cond
			;; If CURRENT is in the future, don't use past
			;; scheduled prefix.
			((> current today) first)
			;; SHOW-ALL focuses on future repeats.  If one
			;; such repeat happens today, ignore late
			;; schedule reminder.  However, still report
			;; such reminders when repeat happens later.
			((and (not show-all) (= repeat today)) first)
			;; Initial report.
			((= schedule current) first)
			;; Subsequent reminders.  Count from base
			;; schedule.
			(t (format next (1+ diff)))))
		     head level category tags time nil habitp))
		   (face (cond ((and (not habitp) pastschedp)
				'org-scheduled-previously)
			       (todayp 'org-scheduled-today)
			       (t 'org-scheduled)))
		   (habitp (and habitp (org-habit-parse-todo))))
	      (org-add-props item props
		'undone-face face
		'face (if donep 'org-agenda-done face)
		'org-marker (org-agenda-new-marker pos)
		'org-hd-marker (org-agenda-new-marker (line-beginning-position))
		'type (if pastschedp "past-scheduled" "scheduled")
		'date (if pastschedp schedule date)
		'ts-date schedule
		'warntime warntime
		'level level
		'priority (if habitp (org-habit-get-priority habitp)
			    (+ 99 diff (org-get-priority item)))
		'org-habit-p habitp
		'todo-state todo-state)
	      (push item scheduled-items))))))
    (nreverse scheduled-items)))
#+end_src
***** TODO Agenda bulk actions
:PROPERTIES:
:CREATED:  [2018-11-05 Mon 10:44]
:ID:       daa2a040-cd9e-4b07-be86-d549d566b42f
:END:

I routinely use the agenda feature to mark multiple tasks and perform an action on all of them.

For example, my typical archiving workflow involves going through archive candidates in my Full agenda for GTD self-check (see [[id:85dadb9c-2a7e-47cf-ba98-a0e73377653d][Archiving]]) using agenda follow mode and
I archive some of the tasks and mark some with :NOARCHIVE: tag (see [[id:adc6f5ae-183f-4c5f-97e8-7bfe18f028d2][General org mode tags]]).

By default, marking a task does not result in updated agenda follow buffer, so I fix it below.

[2020-05-14 Thu] Disabling since I am using categories now, which are verbose enough most of time.

#+begin_src emacs-lisp
;; (define-advice org-agenda-bulk-mark (:after (&rest args) update-follow-mode)
;;   "Update follow mode buffer after marking."
;;   (org-agenda-do-context-action))
;; (advice-add 'org-agenda-bulk-unmark :after #'org-agenda-bulk-mark@update-follow-mode)
#+end_src

*************** TODO send to mail list
*************** END

Further, I use =tags-todo= search to find all unscheduled tasks, which are also not marked as =NEXT=, and decide what to do with them.
Typically, I simply scatter them over a week or other period of time.
However, =tags-todo= search cannot be used for scattering via explicit check in =org-agenda-bulk-action=.
Disabling it (at least, until I find when that check is actually useful).

#+begin_src emacs-lisp
(define-advice org-agenda-bulk-action (:around (oldfun &optional arg) disable-org-agenda-check-type)
  "Always return 't when checking agenda type."
  (cl-letf (((symbol-function 'org-agenda-check-type) (lambda (&rest args) t)))
    (apply oldfun arg)))
#+end_src

***** Agenda search
:PROPERTIES:
:CREATED:  [2019-05-18 Sat 20:28]
:ID:       b646ef49-debd-41d1-b101-13d01db7f9f5
:END:

It is possible to search from agenda dispatcher not only in the org files, but also in archives (from [[https://blog.aaronbieber.com/2016/01/30/dig-into-org-mode.html][Dig Into Org Mode by Aaron Bieber]])
#+begin_src emacs-lisp
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+end_src

***** Show entry contents in agenda
:PROPERTIES:
:CREATED:  [2019-07-29 Mon 18:44]
:ID:       40f833b6-615e-410b-89eb-3ffaea1c5c30
:END:

Showing part of entry content can be important to immediately see some important information related to the task in agenda.
For example, this can be achieved using =org-agenda-entry-text-mode=.
However, this mode appears to clutter the agenda too much, as for me.

An alternative can be =org-quick-peek= package, which creates a temporary overlay showing the first lines of the task at point.

For a while, I tried to bind revealing the task contents in agenda on a key press (TAB).
However, I found myself missing earlier notes I sometimes add to my bookmark tasks.
When the bookmark is a long article, I may read it half way and save the location where I stopped in the task body.
Later, I just forget that I started reading and do not even check the task body...
The solution is to show the task contents of every task at point in agenda.
Also, hide the contents once task is clocked out.

*************** TODO auto-show the contents. make it minor-mode
*************** END

#+begin_src emacs-lisp
(setq org-agenda-start-with-entry-text-mode nil)
(use-package quick-peek
  :straight t)
(use-package org-quick-peek
  :if init-flag
  :straight (org-quick-peek :type git :host github :repo "alphapapa/org-quick-peek"
			    :fork (:host github :repo "yantar92/org-quick-peek"))
  :requires quick-peek
  :after org
  :bind (:map org-agenda-mode-map
	      ("<tab>" . org-quick-peek-agenda-current-item))
  :custom
  (org-quick-peek-show-lines 20)
  (org-quick-peek-show-drawers nil)
  (org-quick-peek-show-planning nil)
  (org-quick-peek-filter-functions (list (apply-partially #'s-replace-regexp "\n" "\n\n")
					 (apply-partially #'s-word-wrap 80)
					 #'s-trim
                                         (apply-partially #'s-replace-regexp "\n+" "\n")))
  :config

  (define-advice org-agenda-clock-in (:after (&rest args) quick-peek-maybe)
    "Show contents of the org-entry at point when there is any."
    (org-agenda-redo@org-quick-peek--hide-all)
    (org-quick-peek--agenda-show :quiet t))
  
  (defun yant/org-agenda-hide-org-quick-peek-overlays-from-clocking ()
    "Hide all org-quick-peek overlays in `org-agenda-buffer'."
    (dolist (agenda-buffer (mapcar #'get-buffer
				   (seq-filter (apply-partially  #'s-contains-p "*Org Agenda") 
					       (mapcar #'buffer-name (buffer-list)))))
      (when (buffer-live-p agenda-buffer)
	(with-current-buffer agenda-buffer
          (mapc (lambda (o)
		  (when (eq (overlay-get o 'type) 'org-agenda-clocking)
                    (quick-peek-hide)))
		(overlays-in (point-min) (point-max)))))))
  
  (add-hook 'org-clock-out-hook #'yant/org-agenda-hide-org-quick-peek-overlays-from-clocking))
#+end_src

***** Trying =org-ql=
:PROPERTIES:
:CREATED:  [2019-12-22 Sun 17:16]
:ID:       43d227d2-2032-4c56-b715-5065b31f1b0c
:END:
*************** TODO I do not really use =SHOWDATES=? think about it
*************** END

#+begin_src emacs-lisp
(add-to-list 'org-default-properties "SHOWDATES")

(defun yant/diary-sexp-match-showdate? (entry) ;; the ENTRY name is important, since it is used internally by calendar
  "Does current time match SHOWDATE?."
  (or (not entry) ;; no condition: match
      (let ((date (diary-make-date (nth 4 (decode-time)) (nth 3 (decode-time)) (nth 5 (decode-time)))))
	(pcase (eval (car (read-from-string entry)))
	  ((and (pred listp) res)
	   (when (cdr res) t))
	  (res (when res t))))))

(defun yant/now-after-showfromtime? (showfromtime)
  "Is time of the day after SHOWFROMTIME? Take into account `org-extend-today-until'."
  (let* ((now (ts-now))
	 (beginningofday (ts-parse (format "%s %s:00"
					   (ts-format "%Y-%m-%d" now)
					   (or org-extend-today-until 0))))
         (stillyesterday? (ts<= now beginningofday))
         (showfromtime (ts-parse (s-concat (ts-format "%Y-%m-%d " now)
					   showfromtime))))
    (or stillyesterday? (ts>= now showfromtime))))

(use-package org-ql
  :demand t
  :straight (org-ql :type git :host github :repo "alphapapa/org-ql"
	      :fork (:host github :repo "yantar92/org-ql"))
  :init (use-package org-ql-search :demand t)
  :config
  )

(defun yant/org-ql-focused-agenda-block (&rest args)
  "Return expression, suitable for `org-agenda-custom-commands', which matches focused agenda view."
  (org-ql-block
   '(and (todo)
	 (not (priority "C"))
	 (or (and (deadline auto) ;; deadline check first because deadlines are far more scarse in comparison with scheduled
		  (not (scheduled :from +1)))
	     (and (priority "A")
		  (scheduled :to 0) ;; these two are easy checks, do them before heavy property matches
		  (or (not (property "SHOWFROMDATE")) ;; non-inheriting property search can be cached efficiently. Hence do it first
		      (ts>= (ts-now) (ts-parse-org (property "SHOWFROMDATE"))))
		  (yant/now-after-showfromtime? (org-entry-get (point) "SHOWFROMTIME" 'inherit)) ;; I have more of this in cmp with SHOWDATES
		  (yant/diary-sexp-match-showdate? (org-entry-get (point) "SHOWDATES" 'inherit))
		  )
	     (and (scheduled :on 0)
		  (yant/now-after-showfromtime? (org-entry-get (point) "SHOWFROMTIME" 'inherit)))
	     (ts-active :on 0) ;; diary
	     ))))

(eval
 '(defun org-ql-skip-function (query)
    "Return a function for `org-agenda-skip-function' for QUERY.
Compared to using QUERY in `org-ql', this effectively turns QUERY
into (not QUERY)."
    (let* ((predicate (org-ql--query-predicate (org-ql--pre-process-query query))))
      (lambda ()
	;; This duplicates the functionality of `org-ql--select'.
	(let (orig-fns)
          (--each org-ql-predicates
            ;; Save original function mappings.
            (let ((name (plist-get it :name)))
              (push (list :name name :fn (symbol-function name)) orig-fns)))
          (unwind-protect
              (progn
		(--each org-ql-predicates
                  ;; Set predicate functions.
                  (fset (plist-get it :name) (plist-get it :fn)))
		;; Run query.
		;; FIXME: "If this function returns nil, the current match should not be skipped.
		;; Otherwise, the function must return a position from where the search
		;; should be continued."
		(funcall predicate))
            (--each orig-fns
              ;; Restore original function mappings.
              (fset (plist-get it :name) (plist-get it :fn))))))))
 'lexical)

(defun yant/org-ql-focused-agenda-query ()
  "Return org-ql skip function that matches focused agenda view."
  (org-ql-skip-function
   '(and (todo)
	 (not (priority "C"))
	 (or (and (deadline auto) ;; deadline check first because deadlines are far more scarse in comparison with scheduled
		  (not (scheduled :from +1)))
	     (and (priority "A")
		  (scheduled :to 0) ;; these two are easy checks, do them before heavy property matches
		  (or (not (property "SHOWFROMDATE")) ;; non-inheriting property search can be cached efficiently. Hence do it first
		      (ts>= (ts-now) (ts-parse-org (property "SHOWFROMDATE"))))
		  (yant/now-after-showfromtime? (org-entry-get (point) "SHOWFROMTIME" 'inherit)) ;; I have more of this in cmp with SHOWDATES
		  (yant/diary-sexp-match-showdate? (org-entry-get (point) "SHOWDATES" 'inherit))
		  )
	     (and (scheduled :on 0)
		  (yant/now-after-showfromtime? (org-entry-get (point) "SHOWFROMTIME" 'inherit)))
	     (ts-active :on 0) ;; diary
	     )
	 )))


(defun yant/org-ql-full-agenda-block (&rest args)
  "Return expression, suitable for `org-agenda-custom-commands', which lists all the active scheduled todo items."
  (org-ql-block
   '(and (todo)
	 (scheduled :to 0)
         (not (tags "HOLD")))))


;; how to do it? I do not want children to be listed if the parent is listed. But cannot give up tag inheritance
;; In normal agenda, it is achieved by `org-tags-match-list-sublevels' 
(defun yant/org-ql-inbox-block (&rest args)
  "Return expression, suitable for `org-agenda-custom-commands', which lists all the inbox items."
  (org-ql-block
   '(and (level 1)
	 (tags "INBOX"))))

;; changing the project definition. Either project tag or the sub-project with NEXT/DOING/REVIEW
(defmacro yant/org-ql-is-project-p ()
  "org-ql query to match a project."
  `(or (and (tag "project")
	    (todo))
       (and (todo "NEXT" "DOING" "REVIEW")
            (children (todo)))))

(defun yant/org-ql-stuck-projects-block (&rest args)
  "Return expression, suitable for `org-agenda-custom-commands', which lists all the stuck projects."
  (org-ql-block
   '(and (not (tags "HOLD" "WAITING"))
	 (yant/org-ql-is-project-p)
         (not (children (todo "NEXT" "DOING" "REVIEW"))))))

(defun yant/org-ql-waiting-and-hold-tasks-block (&rest args)
  "Return expression, suitable for `org-agenda-custom-commands', which lists all the waiting and hold tasks."
  (org-ql-block
   '(todo "HOLD" "WAITING")))

;; (defun yant/org-ql-next-tasks-block (&rest args)
;;   "Return expression, suitable for `org-agenda-custom-commands', which lists all the NEXT and REVIEW tasks in projects."
;;   (org-ql-block
;;    '(and (not (habit))
;; 	 ()
;; 	 )))


(add-to-list 'org-agenda-custom-commands
	     `("D" "Focused agenda (ql version)"
	       ((yant/org-ql-focused-agenda-block))
	       ((org-ql-block-header "Focused agenda(ql version)"))))


(add-to-list 'org-agenda-custom-commands
	     `("s" "Focus daily agenda (ql-skip version)" agenda ""
	       ((org-agenda-overriding-header "Focused daily agenda")
		(org-agenda-skip-function  (yant/org-ql-focused-agenda-query)))))


(add-to-list 'org-agenda-custom-commands
	     `("I" "Inbox (ql version)"
	       ((yant/org-ql-inbox-block))
	       ((org-ql-block-header "Inbox"))
               (list (f-join org-directory "inbox.org"))))

#+end_src

****** TODO use it |- (=alphapapa/org-ql=: An Org query language, and experimental code for a next-generation Org Agenda) :BOOKMARK:
:PROPERTIES:
:CREATED:  [2019-04-04 Thu 15:20]
:Source:   https://github.com/alphapapa/org-ql#org-ql-search
:END:
:LOGBOOK:
- Refiled on [2019-12-23 Mon 18:07]
:END:

***** Live (=helm-org-ql=) search in org
:PROPERTIES:
:CREATED:  [2020-03-29 Sun 22:02]
:ID:       1bc88aed-5729-4a0e-b52c-65e5d46f635b
:END:

#+begin_src emacs-lisp
(use-package org-ql
  :straight t
  :custom
  (helm-org-ql-reverse-paths nil)
  :init
  (use-package helm-org :straight t :demand t) ;; required by helm-org-ql
  :config
  (require 'helm-org-ql)
  )
#+end_src

**** TODO Contacts
:PROPERTIES:
:CREATED:  [2018-09-05 Wed 06:39]
:ID:       8074623d-bc14-43c7-908c-28213b2b6149
:END:
#+BEGIN_SRC emacs-lisp
(use-package org-contacts
  :init
  (setq org-contacts-files '("/home/yantar92/Org/contacts.org"))
  :config
  (use-package helm-org-contacts
    :straight (helm-org-contacts :host github :repo "tmalsburg/helm-org-contacts")))
#+END_SRC

*************** TODO make proper contacts link type
*************** END

**** TODO Column mode
:PROPERTIES:
:ID:       0d6d40dd-e4cb-4297-8695-6b66f2a1a706
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Sometimes, I forget what was happening with a task when I did it last time. Notes are useful in such a case.
However, I do not find it comfortable to look into notes (which are stored in drawer) every time I come back to the task. Instead, I use column mode to show the last stored note.

*************** TODO Put summary on top instead, use org-agenda-show-entry-text to see it then
*************** END

#+begin_src emacs-lisp
;; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%TODO %40ITEM(Task) %40SUMMARY(Summary)")

(defvar yant/last-note-taken ""
  "Text of the last note taken.")

(define-advice org-store-log-note (:before (&rest args) yant/org-store-last-note)
  "Store the last saved note into `yant/last-note-taken'."
  (let ((txt (buffer-string)))
    (while (string-match "\\`# .*\n[ \t\n]*" txt)
      (setq txt (replace-match "" t t txt)))
    (when (string-match "\\s-+\\'" txt)
      (setq txt (replace-match " " t t txt)))
    (when (string-match "\n" txt)
      (setq txt (replace-match " " t t txt)))
    (if (not (seq-empty-p txt))
	(setq yant/last-note-taken txt))))

(define-advice org-store-log-note (:after (&rest args) yant/org-save-last-note-into-summary-prop)
  "Save the last saved note into SUMMARY property."
  (when (and (not org-note-abort) (not (seq-empty-p yant/last-note-taken)))
    (if (eq major-mode 'org-agenda-mode)
	(org-with-point-at-org-buffer
	 (org-set-property "SUMMARY" (or yant/last-note-taken "")))
      (org-set-property "SUMMARY" (or yant/last-note-taken "")))
    (setq yant/last-note-taken nil)))
#+end_src
***** =__epilogue=
:PROPERTIES:
:ID:       0de5d1d1-568f-4991-a627-e1b46b4e481f
:END:
#+begin_src emacs-lisp
)
#+end_src
**** TODO Auto sort
:PROPERTIES:
:ID:       aa092c63-f695-4c03-8639-b34fa262d5fe
:END:
#+begin_src emacs-lisp
(use-package org-autosort
  :config
  (add-hook 'org-mode-hook #'org-autosort-sort-entries-in-file-maybe)
  (setq org-autosort-todo-cmp-order '("WAITING" "REVIEW" "DOING" "NEXT" "HOLD" "TODO" "SOMEDAY" "MERGED" "FAILED" "DONE" "CANCELLED"))
  (bind-key "C-c C-S-s" 'org-autosort-sort-entries-at-point org-mode-map)
  (add-to-list 'org-default-properties "SORT"))
#+end_src
**** Clocking & logging
:PROPERTIES:
:ID:       d1afb1ae-a3a4-45b4-8186-8e7242e0edc1
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
The main purpose of clocking for me is to control the time I spend for important projects and for other staff (like configuring Emacs ;)). Hence, it is important to do a continuous tracking of the tasks, which I can choose to do or not to do (e.g. it is useless to keep track of how much time I spend brushing my teeth in the morning).
A lot of time, the task I am doing is not useful to add to my org files explicitly (e.g. initial checks on some side project, which may or may not work; routine work). I use special tasks for all kinds of such activity:
- Organisation :: related to work, general
- Check =TORead= ... :: related to home, browsing, reading fiction, etc I start the activity from clocking in one of these tasks. Later, I clock in the task, which I am doing at the moment. Once it's done, clocking automatically comes back to higher level task (unless it is marked =:NOCLOCK=, see [[id:adc6f5ae-183f-4c5f-97e8-7bfe18f028d2][General org mode tags]]) or to one of the tasks above when I clocked out top level project.
     Captures are also clocked, but once done, clocking comes back to previously active task, if any, or to default task otherwise.
*************** TODO The default task is not being saved if I restart emacs
*************** END
*************** TODO Clock out from subtask from home is wrongly activating home task
*************** END
#+begin_src emacs-lisp
(use-package org-clock
  :after org
  :config
  (setq org-duration-format '(("h" . h:mm) ("min" . h:mm)))
  (setq org-clock-out-remove-zero-time-clocks t)
  (setq org-clock-out-when-done t)
  (setq org-clock-in-resume t)
  (setq org-clock-persist t)
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  (setq org-clock-persist-query-resume nil)
  (org-clock-persistence-insinuate)
  (defvar bh/keep-clock-running nil
    "Continue in default task if no task is clocked in.")
  (defvar bh/organization-task-id "Organization"
    "ID of default usefull work task.")
  (defvar yant/home-task-id "Homedef"
    "ID of default useless activity task.")

  (defun yant/punch-in-organization ()
    "Clock in Organization task."
    (interactive)
    (setq bh/keep-clock-running 'yant/punch-in-organization)
    (org-with-point-at (org-id-find bh/organization-task-id
				    'marker)
      (org-clock-in '(16))))

  (defun yant/punch-in-home ()
    "Clock in home (random activity) task."
    (interactive)
    (setq bh/keep-clock-running 'yant/punch-in-home)
    (org-with-point-at (org-id-find yant/home-task-id
				    'marker)
      (org-clock-in '(16))))

  (defun yant/punch-out nil
    "Set `org-clock-default-task' to nil and clock out."
    (save-excursion
      (setq bh/keep-clock-running nil)
      (when (org-clock-is-active)
	(org-clock-out))))

  (defun bh/clock-in-default-task ()
    (save-excursion
      (org-with-point-at org-clock-default-task
	(org-clock-in))))

  ;; (defun bh/clock-in-parent-task ()
  ;;   "Move point to the parent (project) task if any and does not have local tag NOCLOCK and clock in."
  ;;   (let ((parent-task))
  ;;     (save-mark-and-excursion
  ;; 	(save-restriction
  ;; 	  (widen)
  ;; 	  (while (and (not parent-task) (org-up-heading-safe))
  ;; 	    (when (and (member (nth 2 (org-heading-components)) org-todo-keywords-1)
  ;; 		       (not (member "NOCLOCK" (org-get-tags nil 'LOCAL))))
  ;; 	      (setq parent-task (point))))
  ;; 	  (if parent-task
  ;; 	      (org-with-point-at parent-task
  ;; 		(org-clock-in))
  ;; 	    (if bh/keep-clock-running
  ;; 		(bh/clock-in-default-task)
  ;; 	      (org-clock-out)))))))

  (defun yant/clock-out-maybe nil
    "Clock out and clock in to default task if `bh/keep-clock-running' is not nil."
    (when (and bh/keep-clock-running
	       (not org-clock-clocking-in)
	       (marker-buffer org-clock-default-task)
	       (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-default-task)))

  (add-hook 'org-clock-out-hook 'yant/clock-out-maybe 'append))
     #+end_src

Once I keep all my time tracked, I can calculate the estimated balance of my time. The idea is that I assign the weight to each task/project (=:ORG-TIME-BALANCE-MULTIPLIER:=), which is positive for useful tasks I do not want to do, and negative for fun tasks (they may be useful, but the purpose is to force myself doing what I do not like to do). All I need to do now, is to keep this balance positive.

***** Agenda log mode & clock report
:PROPERTIES:
:ID:       104927a5-4dea-4ee0-91d7-36afc6b15c7f
:END:
Reviewing previously clocked task is important to keep track of mistakes and clashes during clocking. I do it once per week.
#+begin_src emacs-lisp
(setq org-clock-report-include-clocking-task t)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src
- set up consistency checks (do not show too short clocking gaps)
  #+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      (plist-put org-agenda-clock-consistency-checks
		 :max-gap "2:00"))
  #+end_src
***** Logging
:PROPERTIES:
:ID:       973d6eff-3d91-48f0-a3b5-b438feccf28f
:END:
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-log-state-notes-insert-after-drawers t
      org-log-done 'time
      org-log-done-with-time t
      org-log-note-clock-out nil
      org-log-refile 'time
      org-log-reschedule nil)
(setq org-clock-into-drawer t)
#+end_src
- Do not create empty drawers
  #+begin_src emacs-lisp
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))
(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
  #+end_src
  - Relative to my [[id:d38441a2-1431-44db-b831-8cdec011b1dc][todo keyword structure]], it make sense that clocked task is always =NEXT= and scheduled
  #+begin_src emacs-lisp
(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (when (and (member (org-get-todo-state) (list "TODO" "DONE"))
	       (bh/is-task-p))
      "NEXT")))

(defun yant/schedule-maybe ()
  "Schedule task at point for today, unless it is already scheduled."
  (unless (or (and (boundp 'org-capture-mode) org-capture-mode)
	      (member "DEFAULT" (org-get-tags-at (point) 'local))
	      (org-get-scheduled-time (point)))
    (org-schedule nil ".")))

(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
(add-hook 'org-clock-in-hook #'yant/schedule-maybe)
  #+end_src
***** Display clocked in entry
:PROPERTIES:
:ID:       13012cf7-322e-4433-a22c-e81b7c5feda1
:END:
I do not show current task in Emacs, instead I use =awesome wm= widget. 
Hence, need to save current task in file. 
The widget shows clocked time and full path to the clocked tasks (i.e. =[hh:mm] Project/Subproject/Subsubproject/.../task=) or =[hh:mm] Capturing ...= for capturing (the title is being edited there and it does not make sense to keep that updated in widget as well).

#+begin_src emacs-lisp
(setq org-clock-mode-line-total (quote today))
(defvar yant/org-clocking-info-file "~/.org-clock-in"
  "File to save current clocking info.\nIt will be overwriten!")

(defun yant/task-fulltitle ()
  "Construct full path for the task at point."
  (when (fboundp 'org-mode)
    (save-mark-and-excursion
      (save-restriction
	(org-back-to-heading)
	(mapconcat #'identity (org-get-outline-path 'with-self 'cache) "||")))))

(defun yant/clocked-fulltitle ()
  "Construct string, describing currently clocked entry time and full path to this entry."
  (use-package org-clock)
  (if org-capture-mode
      (concat "Capturing " (plist-get org-capture-plist :description) "...")
    (yant/task-fulltitle)))
(setq org-clock-heading-function 'yant/clocked-fulltitle)

(defun yant/save-noclock ()
  "Save info, that there is no clocked in entry."
  (let ((backup-inhibited t))
    (with-temp-file yant/org-clocking-info-file
      (insert (format "\"No clocked in task\"\n%s" org-time-balance)))))

(defun yant/save-clocked ()
  "Save current clocked state into file."
  (if (org-clock-is-active)
      (save-mark-and-excursion
	(save-restriction
	  (let* ((buf yant/org-clocking-info-file)
		 (str (org-clock-get-clock-string))
                 (org-time-multiplier org-clock-multiplier)
                 (time-balance org-time-balance))
	    (with-temp-file buf
              (setq-local backup-inhibited t)
              (insert (format "%s\n%s\n%s" str time-balance org-time-multiplier))))))
    (yant/save-noclock))
  (async-start-process "Update balance widget" "/home/yantar92/bin/balance-monitor.sh" #'ignore))

(add-hook 'org-clock-in-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-out-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-cancel-hook 'yant/save-clocked 'append)
#+end_src
*************** TODO Do not need async-start-process here
*************** END
***** Efforts
:PROPERTIES:
:CREATED:  [2020-05-04 Mon 17:57]
:ID:       435d7660-576f-42d0-88fd-9882f494712c
:END:


For a long time, I did not find any use for effort estimates.
However, they do have uses in my workflow.

A frequent statement about effort estimates is that if you think that estimate is too much, you just split the task. However, even just the process of splitting generally takes unpredictable time when the task is an exploratory task. For me, as a researcher, such tasks are pretty common. I sometimes have a very rough idea about what should be done and cannot predict how much time each step of a research project is going to take. Things in research fail more often than not and a trivial task may turn out to take 10 times more time that expected. An alternative approach to setting efforts is coming from timeboxing approach when a task is expected to be worked on for a certain period of time per day. However, working on some tasks in research, I can often get a momentum and work on a single task for a single day. Notifications for exceeding the effort are unwanted in such scenario. On the other hand, some tasks may be very difficult to start and not having any time estimate on the task may be discouraging (if there was an effort, at least one can convince himself to work on such task for *some* time). Hence, setting *some* effort estimate on stale tasks is useful.

1. When a task is very large, but cannot be splitted, it is useful to dedicate certain time I plan to spend working on the task. Having this time really helps to start working on the task since I am not demoralised by size of the task. Such tasks are marked with =DOING= todo keyword (see [[id:66396995-13e9-4dfa-854e-476c71a4faa9][#todo_keyword #DOING]])

2. Because of structure of my agenda (see [[id:a6054643-449e-48d7-afff-4155465efc19][Focused daily agenda]]), I often arrive to my list of NEXT tasks late in the evening. However, many of those tasks are not quite easy to do and I am too tired to start them. In these cases, it is useful to filter the agenda showing NEXT tasks only to "easy" tasks, which do not take too much time/effort. Effort estimates can be used in such scenario to mark tasks, which will take a long time (1 hour of longer). I can then simply filter agenda by effort less than one hour to quickly get the tasks I can do when I am tired (but not tired enough to not do anything).

I would like to highlight that this second use-case is extremely important to avoid spending time mindlessly browsing websites like YouTube or reddit. I'd better do something easy yet potentially useful than spend time in completely useless manner.


****** Notify when clocked in time exceeds effort estimate
:PROPERTIES:
:CREATED:  [2020-05-04 Mon 14:44]
:ID:       f9bed201-dd79-4a3a-8822-c6c52fea87d3
:END:

[2020-05-03 Sun] Mode-line display is also linked to notification when the clocked-in time exceeds effort estimate. Hence, I still display the task in mode-line for the sole purpose of enabling notification.

*************** TODO report in mail-list about mode-line display dependence of effort notification
*************** END

#+begin_src emacs-lisp
(use-package org-clock
  :if init-flag
  :config
  (use-package pomidor
    :defer t
    :config
    (setq org-clock-sound pomidor-sound-overwork))
  (unless org-clock-sound (setq org-clock-sound "~/Org/alert.wav"))
  ;; this is not a default value, 't will still trigger notification
  ;; when clocked in time exceeds effort estimate, while not triggering
  ;; showing the current task in modeline or frame title.
  (setq org-clock-clocked-in-display 't))
#+end_src

***** Clocking history
:PROPERTIES:
:ID:       9e2c7a88-8a56-4213-b458-ccebcd59812a
:END:
Sometimes I need to jump to some urgent task. After it is done, I hate searching for the last task buffer and start clocking it again. Hence, I use clocking history and quick key combination to clock in task from recent clocked in tasks.
#+begin_src emacs-lisp
(setq org-clock-history-length 23)
(use-package boon
  :config
  (use-package helm-org
    :bind (:map boon-goto-map
		("p" . helm-org-agenda-files-headings))
    :config
    (defun dfeich/helm-org-clock-in (marker)
      "Clock into the item at MARKER"
      (with-current-buffer (marker-buffer marker)
	(goto-char (marker-position marker))
	(org-clock-in)))
    (nconc helm-org-headings-actions
           (list
            (cons "Clock into task" #'dfeich/helm-org-clock-in)))
    (bind-key "C-c i" #'dfeich/helm-org-clock-in helm-org-headings-map)
    (setq helm-org-format-outline-path t
	  helm-org-show-filename t
          helm-org-ignore-autosaves t)
    ))
#+end_src
***** Automatic clock-out on idle
:PROPERTIES:
:CREATED:  [2020-05-04 Mon 13:31]
:ID:       397733e4-a1e4-48f4-80cd-cadb57905d69
:END:

Sometimes, I clock in some task in the evening, but fall asleep. 
That excess clocked time is not useful.
So, let Emacs automatically clock out the current task when Emacs is idle for a long time
#+begin_src emacs-lisp
(use-package org-clock
  :if init-flag
  :custom
  (org-clock-auto-clockout-timer (* 60 60 2)) ; 2 hours
  :config
  (org-clock-auto-clockout-insinuate))
#+end_src

***** Pomodoro technique
:PROPERTIES:
:ID:       ee371af1-c478-49d1-9814-1eb78242a341
:END:
Sometimes I need to do important task, but I just hate it. I tend to do anything, but not that freaking task. In this case, =pomodoro= works for me - I just switch between the task and something I like.
About: [[https://habrahabr.ru/post/323576/][habr]]
#+begin_src emacs-lisp
(use-package pomidor
  :if init-flag
  :straight t
  :bind (([f7] . pomidor))
  :config
  (setq alert-default-style 'libnotify))
#+end_src
***** Bonus/penalty based time management
:PROPERTIES:
:CREATED:  [2018-07-21 Sat 16:40]
:ID:       38d9103d-a969-4c69-ae0e-a9a50912fba0
:END:
The idea is to assign time bonus/penalty during working on different tasks, so that the total balanced time spent under all the tasks (=org-time-balance=) is kept positive.
Similar concept is described [[id:8a2ae3c3-69b0-495b-b796-9c9916dc40c6][here]].

I calculate the effective time by setting =ORG-TIME-BALANCE-MULTIPLIER= property for various tasks.
If the value is positive then the task is useful. Otherwise, it is negative and I do not want to spend too much time doing such tasks.
The property can be different for various classes of tasks allowing to avoid/promote doing various tasks.
Setting =ORG-TIME-BALANCE-MULTIPLIER= for every single task is annoying, so I make it inherited during calculation.

It does not make sense to set =ORG-TIME-BALANCE-MULTIPLIER= for tasks like buying something in the shop.
I just do not clock them in.
Instead, I use =ORG-TIME-BONUS-ON-DONE= property to add fixed extra time for finishing the task (only =DONE= keyword is considered).

Also, during exceptionally procrastinated days time balance may go overboard and become terribly negative. If the balance becomes too negative, it is infuriating to see how much I need to makeup. The solution is introducing the idea of /lossage/. When time balance becomes too negative, it is no longer decreased, but the lossage is increased. Later, when the time balance becomes large and positive, it stops growing until the lossage is back to 0.

Similar idea is used by John Wiegley in [[id:4dda6631-cace-441d-bc4c-a3d778a09d30][Emacs SF: 2019-07-24: All Things Org-Mode - Multiple Speakers]]
He tracks his clocking time daily to have an idea how long he worked relative to his daily goal (8 hours).
This idea is not applicable for my work though. Research is often not regularly structured - I can work during weekdays, weekends, at night time when I suddenly get some idea, etc. In such a way, it is important for me to maintain some average work/leisure balance rather than work certain number of hours every workday.

*************** TODO the bonus cannot be correctly handled when we need to update the time after certain point
*************** END



#+begin_src emacs-lisp
(defvar org-time-balance nil
  "Weighted time spent for all the tasks in agenda files.")
(defvar org-time-balance-persistant-p t
  "Non nil means that `org-time-balance' is saved between emacs sessions.")
(defvar org-time-balance-save-time nil
  "Time of the last save of `org-time-balance'.")
(defvar org-time-balance-update-time nil
  "Time of the last update of `org-time-balance'.")
(defvar org-time-balance-storage (concat user-emacs-directory ".org-time-balance")
  "File used to store time balance between sessions.")

(defvar org-time-balance-lower-bound (* 60 2 -1) ; -2 hours
  "Lower bound of possible value of time balance.")
(defvar org-time-balance-lossage nil
  "Time lossage accumulating when `org-time-balance' reaches `org-time-balance-lower-bound'.")
(defvar org-time-balance-upper-bound (* 60 10) ; 10 hours
  "Upper bound of possible value of time balance when `org-time-balance-lossage' is positive.
Growing time balance will be reducing `org-time-balance-lossage' when
`org-time-balance' exceeds this value and `org-time-balance-lossage'
is positive.")
(defvar org-time-balance-upper-bound-rigid (* 60 30) ; 30 hours
  "Rigit upper bound of possible value of time balance.
Growing time balance will be reducing `org-time-balance-lossage' when
`org-time-balance' exceeds this value.")

(defun org-load-time-balance-session ()
  "Load the current org-time-balance if `org-time-balance-persistant-p' is non nil."
  (if (not org-time-balance-persistant-p)
      (setq org-time-balance 0
	    org-time-balance-lossage 0)
    (load org-time-balance-storage)
    (unless org-time-balance (setq org-time-balance 0))
    (unless org-time-balance-lossage (setq org-time-balance-lossage 0))
    (message "Loading time-balance... %d hours" (/ org-time-balance 60))))

(defun org-save-time-balance-session ()
  "Save the current org-time-balance if `org-time-balance-persistant-p' is non nil."
  (when (and org-time-balance-persistant-p
	     org-time-balance)
    (setq org-time-balance-save-time (or org-time-balance-update-time (current-time)))
    (with-temp-file org-time-balance-storage
      (insert "(setq org-time-balance " (prin1-to-string org-time-balance) ")" "\n")
      (insert "(setq org-time-balance-lossage " (prin1-to-string org-time-balance-lossage) ")" "\n")
      (insert "(setq org-time-balance-save-time '" (prin1-to-string org-time-balance-save-time) ")"))))

(defun org-get-time-balance-multiplier-at-point ()
  "Get value of :ORG-TIME-BALANCE-MULTIPLIER property of an item at point or return 1."
  (save-excursion
    (save-restriction
      (let  ((multiplier (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)))
	(if (seq-empty-p multiplier)
	    1
	  (string-to-number multiplier))))))

(defun org-get-org-time-bonus-on-done-at-point ()
  "Get value of :ORG-TIME-BONUS-ON-DONE: property of an item at point or return 0."
  (save-excursion
    (save-restriction
      (let  ((bonus (org-entry-get (point) "ORG-TIME-BONUS-ON-DONE")))
	(if (seq-empty-p bonus)
	    0
	  (string-to-number bonus))))))

(defun org-get-org-time-bonus-at-point ()
  "Get time bonus on done for an item at point.
Return the value of :ORG-TIME-BONUS: property and,
if the item has DONE keyword, add :ORG-TIME-BONUS-ON-DONE:.
Increment :ORG-TIME-BONUS: for habits, if nesessary."
  (save-excursion
    (save-restriction
      (let*  ((bonus (org-entry-get (point) "ORG-TIME-BONUS"))
	      (bonus (if (seq-empty-p bonus)
			 0
		       (string-to-number bonus)))
              (extra (if (string= (org-get-todo-state) "DONE")
			 (org-get-org-time-bonus-on-done-at-point)
                       0)))
	(+ bonus extra)))))

(defun org-clock-sum-current-entry-only (&optional tstart)
  "Return time, clocked on current item in total. Exclude subitems."
  (save-excursion
    (save-restriction
      (if (or (org-inlinetask-at-task-p)
	      (org-inlinetask-in-task-p))
	  (narrow-to-region (save-excursion (org-inlinetask-goto-beginning) (point))
			    (save-excursion (org-inlinetask-goto-end) (point)))
	(org-narrow-to-subtree)
	(goto-char (point-min))
	(outline-next-heading)
	(narrow-to-region (point-min) (point)))
      (org-clock-sum tstart)
      org-clock-file-total-minutes)))

(defun org-time-balance-update-lossage ()
  "Update `org-time-balance-lossage'."
  (when (< org-time-balance org-time-balance-lower-bound)
    (setq org-time-balance-lossage (+ org-time-balance-lossage (- org-time-balance-lower-bound org-time-balance)))
    (setq org-time-balance org-time-balance-lower-bound))
  (when (and (> org-time-balance-lossage 0)
	     (> org-time-balance org-time-balance-upper-bound))
    (setq org-time-balance-lossage (- org-time-balance-lossage (- org-time-balance org-time-balance-upper-bound)))
    (setq org-time-balance org-time-balance-upper-bound))
  (when (> org-time-balance org-time-balance-upper-bound-rigid)
    (setq org-time-balance-lossage (- org-time-balance-lossage (- org-time-balance org-time-balance-upper-bound-rigid)))
    (setq org-time-balance org-time-balance-upper-bound-rigid)))

(defun org-accumulate-weighted-time (&optional return)
  "Aggregate `org-time-balance' counter at point from the last save or for all the time.
Use :ORG-TIME-BALANCE-MULTIPLIER: property to set the weight.
Just return the value at point if RETURN is not nil."
  (when org-time-balance
    (let* ((value-at-point (* (org-clock-sum-current-entry-only org-time-balance-update-time)
                              (org-get-time-balance-multiplier-at-point))))
      (setq value-at-point (+ value-at-point (org-get-org-time-bonus-at-point)))
      (if return
	  value-at-point
	(setq org-time-balance (+ org-time-balance value-at-point))
        (org-time-balance-update-lossage)))))

(defun org-get-total-weighted-time (&optional force)
  "Calculate total weighted time clocked in all agenda files.
Ignore current value of `org-time-balance' if FORCE is not nil.
If FORCE is non nil recalculate the time in all the agenda files
ignoring the previously saved values."
  (when (or force (not org-time-balance))
    (message "Updating org-time-balance...")
    (setq org-time-balance 0)
    (setq org-time-balance-save-time nil)
    (unless force (org-load-time-balance-session))
    (when (not org-time-balance-save-time) ;; FIXME: temporary fix to avoid accumulating bonus time after loading saved balance
      (cl-loop for file in (org-agenda-files 'unrestricted t) do
	       (with-current-buffer (find-file-noselect file)
		 (goto-char (point-min))
		 (cl-loop until (eobp)
			  do (when (outline-next-heading)
			       (org-accumulate-weighted-time))))))
    (message "Updating org-time-balance... %d hours" (/ org-time-balance 60))
    (setq org-time-balance-update-time (current-time)))
  org-time-balance)

(define-advice org-clock-out (:around (OLDFUN &rest args) yant/org-increment-weighted-time)
  "Add the current clock time to `org-time-balance'."
  (unless org-time-balance
    (setq org-time-balance (org-get-total-weighted-time))
    (org-time-balance-update-lossage))
  (when (org-clocking-buffer)
    (save-excursion ; Do not replace this with `with-current-buffer'.
      (with-no-warnings (set-buffer (org-clocking-buffer)))
      (save-restriction
	(widen)
	(use-package org-clock)
	(goto-char org-clock-marker)
	(let ((old-time-at-point (org-accumulate-weighted-time 'return))
	      (old-org-time-balance org-time-balance))
	  (apply OLDFUN args)
	  ;; (setq org-time-balance-update-time (current-time))
	  (setq org-time-balance (+ old-org-time-balance
				    (- (org-accumulate-weighted-time 'return)
                                       old-time-at-point)))
          (org-time-balance-update-lossage))))))

(define-advice org-todo (:around (OLDFUN &optional arg) yant/org-increment-weighted-time)
  "Probably add the current item time bonus to `org-time-balance'."
  (unless org-time-balance
    (setq org-time-balance (org-get-total-weighted-time))
    (org-time-balance-update-lossage))
  (org-with-point-at-org-buffer
   (let ((old-time-at-point (org-accumulate-weighted-time 'return))
	 (old-org-time-balance org-time-balance))
     (when (and (string= (org-entry-get (point) "STYLE") "habit")
		(string= (format "%s" arg) (org-entry-get (point) "REPEAT_TO_STATE"))
		(string= "DONE" (org-get-todo-state))
		(org-set-property "ORG-TIME-BONUS" (format "%s" (org-get-org-time-bonus-at-point)))))
     (apply OLDFUN (list arg))
     ;; (setq org-time-balance-update-time (current-time))
     (setq org-time-balance (+ old-org-time-balance
			       (- (org-accumulate-weighted-time 'return)
				  old-time-at-point)))
     (org-time-balance-update-lossage))
   (yant/save-clocked)))


(defvar org-clock-multiplier 0
  "Multiplier of the currently clocked entry.")

(defun org-clock-save-clock-multiplier ()
  "Save value of :ORG-TIME-BALANCE-MULTIPLIER: of the item at point to `org-clock-multiplier'."
  (org-with-wide-buffer
   (org-get-total-weighted-time)
   (setq org-clock-multiplier (or (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)
				  1))))

(add-hook 'org-clock-in-hook #'org-clock-save-clock-multiplier)
(add-hook 'org-clock-in-hook #'org-save-time-balance-session)

(add-to-list 'org-default-properties "ORG-TIME-BALANCE-MULTIPLIER")
(add-to-list 'org-default-properties "ORG-TIME-BONUS-ON-DONE")
#+end_src
***** =__epilogue=
:PROPERTIES:
:ID:       e26ec668-12c9-41f1-ad8a-a3dd96007f5c
:END:
#+begin_src emacs-lisp
)
#+end_src
**** Capture
:PROPERTIES:
:ID:       fbb770b4-2232-431d-b2e5-75d001ff49b0
:END:
#+begin_src emacs-lisp
  (when init-flag
  (use-package org-capture
    :config
#+end_src
Capturing is an important part of my workflow. It allows me to quickly note down the task or thought for future consideration and continue the current task.
This should be done quickly, and from any place (not only from inside emacs):
- system wide key combination for capturing allows to capture from anywhere
- open new frame for capturing
- use capture templates for most common types of quick captures
There is also one more use case when I prefer to use capture - creating a new big projects. The reason to use capture here is that common types of projects require some set of needed actions, which I tend to forget. Capture templates here allows to remind necessary project tasks to myself.
***** System wide capture
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:49]
:ID:       0702c999-0ee5-494c-a1d7-1bb4024c43f7
:END:
#+begin_src emacs-lisp
(use-package org-protocol)
#+end_src
*************** TODO Include system scripts here
CLOSED: [2018-09-23 Sun 17:36]
:LOGBOOK:
- State "DONE"       from              [2018-09-23 Sun 17:36]
:END:
*************** END
New frame for capturing. The frame should only have capture buffer in it.
#+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :straight t
  :config
  (setq ocpf-frame-parameters '((name . "org-capture-pop-frame")))
  (defadvice org-capture-place-template (after delete-windows activate) (delete-other-windows))
  (defadvice org-capture-select-template (around delete-capture-frame activate)
    "Advise org-capture-select-template to close the frame on abort.  From https://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection#23517820"
    (unless (ignore-errors ad-do-it t)
      (setq ad-return-value "q"))
    (if (and (equal "q" ad-return-value)
	     (equal "org-capture-pop-frame" (frame-parameter nil 'name)))
	(delete-frame))))
#+end_src

*************** TODO report bug
*************** END

Currently =org-capture-pop-frame= resets the line truncation state, which is rather annoying. Denying it:
#+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :if init-flag
  :defer t
  :init
  (defun ocpf--org-capture (orig-fun &optional goto keys)
    "Create a new frame and run org-capture."
    (interactive)
    (let ((frame-window-system
           (cond ((eq system-type 'darwin) 'ns)
		 ((eq system-type 'gnu/linux) 'x)
		 ((eq system-type 'windows-nt) 'w32)))
          (after-make-frame-functions
           #'(lambda (frame)
               (with-selected-frame frame
		 (funcall orig-fun goto keys)
		 ;; (setq header-line-format
                 ;;       (list "Capture buffer. "
                 ;;             (propertize (substitute-command-keys "Finish \\[org-capture-finalize], ")
		 ;; 			 'mouse-face 'mode-line-highlight
		 ;; 			 'keymap
		 ;; 			 (let ((map (make-sparse-keymap)))
                 ;;                           (define-key map [header-line mouse-1] 'org-capture-finalize)
                 ;;                           map))
                 ;;             (propertize (substitute-command-keys "abort \\[org-capture-kill]. ")
		 ;; 			 'mouse-face 'mode-line-highlight
		 ;; 			 'keymap
		 ;; 			 (let ((map (make-sparse-keymap)))
                 ;;                           (define-key map [header-line mouse-1] 'org-capture-kill)
                 ;;                           map))))
		 ))))
      (make-frame
       `((window-system . ,frame-window-system)
	 ,@ocpf-frame-parameters)))))
#+end_src

***** Capture templates
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:51]
:ID:       e3d02bee-a924-4808-9a2f-fe577065038d
:END:

To simplify defining the capture templates, I use =doct= package

#+begin_src emacs-lisp
(use-package doct
  :straight (doct :type git :host github :repo "progfolio/doct")
  :commands (doct))
#+end_src

All these templates generally record the creation time in =:CREATED:=
- TODO item :: Normal TODO item.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "n"
           (cdar (doct
		  '("NEXT item"
		    :keys "n"
                    :type entry
                    :file "~/Org/inbox.org"
                    :clock-in t
                    :clock-resume t
                    :template
                    ("* TODO %? %a"
                     ":PROPERTIES:"
                     ":CREATED: %U"
                     ":END:"
                     "\n")))))
#+end_src
- singular TODO item :: Normal TODO item with time bonus on done (60 minutes) - used for the items, which are unlikely to be time tracked.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "t"
           (cdar  (doct '("Singular TODO item"
			  :keys "t"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* NEXT %? %a"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":ORG-TIME-BONUS-ON-DONE: 20"
			   ":END:"
			   "\n"))))
           'replace)
#+end_src
- note :: A note, which is not actionable or expected to contain a lot of text
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "N"
           (cdar (doct
		  '("Note"
		    :keys "N"
                    :type entry
                    :file "~/Org/inbox.org"
                    :clock-in t
                    :clock-resume t
                    :template
                    ("* TODO Fleeting note on %u"
                     ":PROPERTIES:"
                     ":CREATED: %U"
                     ":END:"
                     "- [ ] Check what notes are followed by this link"
                     "- [ ] Make title"
                     "- [ ] Refile to relevant topics"
                     "- [ ] Elaborate"
                     "Following up: %a"
                     "\n"
                     "%? %a"
                     "\n"))))
           :replace)
(use-package ya-org-capture
  :straight (ya-org-capture :type git :host github :repo "ag91/ya-org-capture")
  :config
  (ya-org-capture/setup)
  (asoc-put! org-capture-templates
	     "F"
             '("Note" entry (file "/tmp/test.org") "* %(ya-org-capture/make-snippet \"note-capture_\")" :empty-lines 2 :clock-in t :clock-resume t)
             :replace)
  (asoc-put! org-capture-templates
	     "E"
             (cdar (doct
		    '("Note"
		      :keys "E"
                      :type entry
                      :file "~/Org/inbox.org"
                      :clock-in t
                      :clock-resume t
                      :template
                      ("* %(ya-org-capture/make-snippet \"note-capture_\")"))))
             :replace))
#+end_src
- Habit :: Habit. I default it to no logging.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "h"
           (cdar  (doct '("Habit"
			  :keys "h"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* NEXT %?"
                           "SCHEDULED: <%<%Y-%m-%d %a .+1d>>" 
			   ":PROPERTIES:"
			   ":CREATED: %U"
                           ":STYLE: habit"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: DONE(!)"
                           ":ARCHIVE: %%S_archive_%%y.org::*Habits"
			   ":ORG-TIME-BONUS-ON-DONE: 20"
			   ":END:"
			   "\n"))))
           'replace)
#+end_src
- Meeting/Event :: Scheduled event. It is saved to =org-gcal= org file.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "M"
           (cdar  (doct '("Scheduled even/meeting"
			  :keys "M"
			  :type entry
			  :file "~/Org/schedule.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* %? :%^G:"
                           "%^T"
			   "\n"))))
           'replace)
#+end_src
- Project :: A large task that needs to be studied systematically. A typical project includes the following:
  1. Literature review to find out what is known about the topic. I only put my notes and thoughts on the literature here.
  2. [optional] Resources I have to execute the project (i.e. samples)
  3. Research plan to plan what I need to do to fulfil the project
  4. The information I collected while executing the project (experimental data)
  5. Non-trivial methods I used to execute the project
  6. Results of the executing the plan and analysis of those results
  7. Discussion about the meaning of the results in the context of literature
  8. Conclusion and possible future directions
  9. Public reports and/or paperwork associated with the project
     1. Paperwork
     2. Conference talks/posters
     3. Publications in public domain
     4. Funding applications
  10. List of resources I plan to read, related to the project. I keep this separate from literature review to avoid cluttering.
  11. Ideas, which may be useful for the project. It is "Inbox" of the project. The items may later come to other sections.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "P"
           (cdar  (doct '("Research project"
			  :keys "P"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO #project %^{Project title} :%^G:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":ORG-TIME-BALANCE-MULTIPLIER: %^{Time balance multiplier}"
                           ":CATEGORY: %^{Category}"
			   ":END:"
                           "# A short summary about the project."
                           "\n%?"
                           "** TODO Literature review"
                           "# Notes about what is known about the topic\n"
                           "** TODO Research plan :NOARCHIVE:REFILE:"
                           "# Action plan to complete the project.\n"
                           "** Sample condition :REFILE:NOARCHIVE:"
                           "# Limited resources I need to complete the project."
                           "** Methods :REFILE:NOARCHIVE:"
                           "# Nontrivial methods used to execute the action plan."
                           "** Exp data :REFILE:NOARCHIVE:"
                           "# The raw experimental data is stored here on per-experiment basis"
                           "** Results"
                           "# The raw data is analysed here to be put into human-readable form (in non-trivial ways)."
                           "# The data is organised by sample rather than by experiment to avoid dealing with experimental note mess."
                           "# Plots, important observations and thoughs are coming here.\n"
                           "** Discussion :REFILE:"
                           "# Trying to make sense of the results. If possible, comparing with similar literature.\n"
                           "** TODO Conclusion"
                           "# Takeouts of the project and possible things to be done in future."
                           "** Reports :NOARCHIVE:"
                           "*** Paperwork :REFILE:"
                           "*** Presentations :REFILE:"
                           "*** Published papers :REFILE:"
                           "*** Funding applications :REFILE:"
                           "** NEXT Papers to read :REFILE:"
                           "** TODO Ideas :REFILE:"
			   "# Inbox for project ideas, which are not directly actionable."))))
           'replace)

(asoc-put! org-capture-templates
	   "G"
           (cdar  (doct '("General project"
			  :keys "G"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO #project %^{Project title} :%^G:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":ORG-TIME-BALANCE-MULTIPLIER: %^{Time balance multiplier}"
                           ":CATEGORY: %^{Category}"
			   ":END:"
                           "# A short summary about the project."
                           "\n%?"
                           "** TODO Literature review"
                           "# Notes about what is known about the topic\n"
                           "** TODO Action plan :NOARCHIVE:REFILE:"
                           "# Action plan to complete the project.\n"
                           "** Methods :REFILE:NOARCHIVE:"
                           "# Nontrivial methods used to execute the action plan."
                           "** Results"
                           "** TODO Conclusion"
                           "# Takeouts of the project and possible things to be done in future."
                           "** Public results :REFILE:"
                           "** NEXT Papers to read :REFILE:"
                           "** TODO Ideas :REFILE:"
			   "# Inbox for project ideas, which are not directly actionable."))))
           'replace)
#+end_src
- Conference presentation/poster :: I mark this with =conference= tag. Typical workflow here is:
  1. Write an abstract
  2. Revise abstract (habit, since it is multiple times most likely)
  3. Submit abstract
  4. Get accepted
  5. Handle finance
     - Apply for funding
     - Book flight
     - Book hotel
     - Register for conference
  6. Make presentation/poster
  7. Do trial + further revisions (habit)
  8. Print poster if it is poster
  9. Present
  10. Reimburse money
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "p"
           (cdar  (doct '("Conference presentation/poster"
			  :keys "p"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* NEXT #%^{type|presentation|poster} %^{Title of presentation/poster} :conference:NOARCHIVE:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
                           ":ATTACH_DIR_INHERIT: t"
			   ":END:"
                           "** NEXT Abstract"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Submit abstract"
                           "DEADLINE: %^t"
                           "** TODO Get accepted"
                           "** TODO Paperwork"
                           "*** TODO Register for the conference"
                           "*** TODO Apply for conference funding"
                           "*** TODO Book a flight"
                           "*** TODO Book accomodation"
                           "** TODO Presentation draft"
                           "** TODO Trial presentation"
                           "** TODO Print poster/slides"
                           "** TODO Present"
                           "** TODO Submit the claim"
                           "** Get reimbursement"))))
           'replace)
#+end_src
- Research publication :: I mark this with =publication= tag. Typical workflow here is:
  1. Write outline
     1. Introduction
     2. Methodology
     3. Results
     4. Discussion
     5. Conclusions
     6. Abstract
  2. Revise (habit)
  3. Write cover letter
  4. Submit
  5. Revise according to comments (habit)
  6. Get accepted
  7. Publish in ArXiv before journal take over the copyright
  8. Publish in journal
  9. Add to publication list
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "J"
           (cdar  (doct '("Journal publication"
			  :keys "J"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* NEXT #paper %^{Aproximate title of the paper} :publication:NOARCHIVE:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
                           ":ATTACH_DIR_INHERIT: t"
			   ":END:"
                           "\n%?"
                           "** NEXT Outline"
                           "DEADLINE: %^t"
                           "*** TODO Abstract"
                           "*** NEXT Introduction"
                           "*** TODO Methods"
                           "*** TODO Results"
                           "*** TODO Discussion"
                           "*** TODO Conclusions"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Cover letter"
                           "** TODO Submit"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Get accepted"
                           "** TODO Publish on ArXiv"
                           "** TODO Get published"
                           "** TODO Add to publication list"))))
           'replace)
#+end_src
- Co-authored research publication :: I mark this with =publication= tag. Typical workflow here is:
  1. Revise
  2. Revise according to comments
  3. Get accepted and published
  4. Add to publication list
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "A"
           (cdar  (doct '("Co-authored journal publication"
			  :keys "A"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* NEXT #paper #co-author %^{Aproximate title of the paper} :publication:NOARCHIVE:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
                           ":ATTACH_DIR_INHERIT: t"
			   ":END:"
                           "\n%?"
                           "** Paper versions"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Submit"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Check references"
                           "** TODO Get accepted"
                           "** TODO Get published"
                           "** TODO Add to publication list"))))
           'replace)
#+end_src
- Research funding application :: I mark this with =grant= tag. The usual funding application workflow includes:
  1. Budget
  2. Abstract/summary
  3. Introduction and motivation of the research
  4. Research goal, objective, and content
     1. Research goal
     2. Research objective
     3. Details of how to solve the research objective
  5. Research plan and practicability analysis
     1. Research plan / stage #1..#n
     2. Practicability analysis
  6. Unique features and innovation point
  7. Annual research plan and expected results (including the activity of academic exchange, international collaboration, etc.)
  8. Background, prior work, and availability of equipment
     1. Research background or prior work related to the proposal
     2. Availability of equipment
  9. References
  10. University paperwork
  11. Application paperwork
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "F"
           (cdar  (doct '("Funding/grant application"
			  :keys "F"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO #proposal %^{Project title} :%^G:NOARCHIVE:grant:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":END:"
                           "#A short summary about the proposal."
                           "# Reference proposal template: [[id:208e5431-bd03-4250-b36e-863ffbdcba6b][Prepare the project proposal]]"
                           "# I should not forget next time that I will need to fill a form and get the school stamp before submitting the proposal for initial review."
                           "\n%?"
                           "** TODO Proposal outline"
                           "*** TODO Budget"
                           "*** TODO Research profile"
                           "*** TODO Summary"
                           "*** NEXT Introduction and motivation of research"
                           "*** TODO Research goal, objective, and content"
                           "**** Research goal"
                           "**** Research objective"
                           "**** Details of how to solve the research objective"
                           "*** TODO Research plan and practicability analysis"
                           "**** Research plan"
                           "**** Practicability analysis"
                           "*** TODO Unique features and innovation point"
                           "*** TODO Annual research plan and expected results (including the activity of academic exchange, international collaboration, etc.)"
                           "*** TODO Background, prior work, and availability of equipment"
                           "**** Research background or prior work related to the proposal"
                           "**** Availability of equipment"
                           "*** TODO References"
                           "** TODO Revise"
                           ":PROPERTIES:"
                           ":REPEAT_TO_STATE: NEXT"
                           ":LOGGING: nil"
                           ":END:"
                           "** TODO Prepare univesity intellectual property paperwork"
                           "** TODO Submit to university review"
                           "** TODO Submit the grant application"
                           "** Get accepted"))))
           'replace)
#+end_src
- Rss entry :: An rss to be tracked with =elfeed=. The url is parsed to derive a valid rss page
*************** TODO make this work
*************** END
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "r"
           (cdar  (doct '("Rss entry"
			  :keys "r"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO [[%:link][%^{Title|%:description}]] :rss:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":END:"))))
           'replace)
#+end_src
- New contact :: Add a person to contact list. 
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "C"
           (cdar  (doct '("Contact"
			  :keys "C"
			  :type entry
			  :file "~/Org/contacts.org"
			  :template
			  ("* %(org-contacts-template-name) %?"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":EMAIL: %(org-contacts-template-email)"
			   ":END:"))))
           'replace)
#+end_src

- Experimental note :: A new note on an experiment. 
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "E"
           (cdar  (doct '("Experiment note"
			  :keys "E"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO %u %^{Experiment title}"
			   ":PROPERTIES:"
			   ":CREATED: %U"
			   ":END:"
                           "- [ ] copy the data to my laptop"
                           "- [ ] update sample condition in the project notes"
                           "%?"))))
           'replace)
#+end_src

Reverse the order of template to make them appear as I put them in the list above
#+begin_src emacs-lisp
(setq org-capture-templates (nreverse org-capture-templates))
#+end_src

***** Capturing references (websites, journal papers, files, etc)
:PROPERTIES:
:CREATED:  [2020-07-23 Thu 13:36]
:ID:       e65adaed-acf4-4872-93fd-5560cde0723b
:END:

When capturing external resources like URLs, journal articles or just some data, I prefer to have as much information as possible to be parsed and downloaded automatically, so that I do not need to bother adding it by hand. 
However, capturing URLs from youtube, scientific journal websites, imdb, goodreads, etc requires very different types of parsing.
I need a per-site parsers to capture data in unified manner.

All the data captured in this way is stored in bibtex files for future reference and to integrate things with [[Org-ref]].

The most common type of data I capture is indeed links from browser.
I define two link types for capturing:
- Link from browser :: It has =:SOURCE:= with URL of the page and page title in headline. =:SOURCE:= is the only place, where the URL is shown. I tag the entry with tag =BOOKMARK= to make it clear.
- Generic link :: Same as link from browser, but silent (don't raise the capture buffer)






#+begin_src emacs-lisp :tangle no
  (require 'org-ref-url-utils)

  (use-package org-cliplink :straight t)

  (setq bibtex-autokey-year-length 4)

  (setq bibtex-autokey-title-terminators "[.!?;]\\|--")
  (require 'org-ref-url-utils)

  (use-package org-cliplink :straight t)

  (setq bibtex-autokey-year-length 4)

  (setq bibtex-autokey-title-terminators "[.!?;]\\|--")

  (setq org-ref-url-date-re "class=date[^>]*>\\([^<]+\\)</")
  (require 'org-ref)
  (add-to-list 'org-ref-title-case-types "misc")
  (add-hook 'org-ref-clean-bibtex-entry-hook #'org-ref-title-case)

  (defvar yant/org-capture-science-journal-url-re "sciencedirect\\|elsevier\\|cambridge\\|asme\\.org\\|hanser-elibrary\\.com\\|tandfonline\\|scholarsarchive\\.byu\\.edu\\|osti\\.gov\\|royalsocietypublishing\\.org\\|iopscience\\.iop\\.org"
    "Regex matching scientific journal URL.")

  (defvar yant/org-capture-current-bibtex nil
    "Parsed bibtex entry for the currently captured item.")

  (defvar yant/org-capture-html-buffer nil
    "Buffer containing the captured webpage html.")

  (defun yant/org-capture-get-html-buffer ()
    "Get buffer containing the captured webpage html."
    (if yant/org-capture-html-buffer
	yant/org-capture-html-buffer
      (setq yant/org-capture-html-buffer nil)
      (when-let ((link (plist-get org-store-link-plist :link)))
	(setq yant/org-capture-html-buffer
	      (let* ((query (plist-get org-store-link-plist :query))
		     (html (plist-get query :html)))
		(if html
		    (find-file-noselect html)
		  (url-retrieve-synchronously link)))))))

  (setq org-ref-url-bibtex-template
	"@misc{key,
	title        = {${:title}},
	author       = {${:author}},
	howpublished = {${:howpublished}},
	url          = {${:url}},
	year         = {${:year}},
	note         = {Online; accessed ${:urldate}}
	}")

  (defvar yant/org-capture-youtube-bibtex-template
    "@misc{key,
     title          = {${:title}},
     author         = {${:author}},
     authorhomepage = {${:author-homepage}},
     howpublished   = {Youtube},
     url            = {${:url}},
     year           = {${:year}},
     note           = {Online; accessed ${:urldate}}
     }")

  (defvar yant/org-capture-habr-bibtex-template
    "@misc{key,
     title          = {${:title}},
     author         = {${:author}},
     howpublished   = {Habr},
     url            = {${:url}},
     year           = {${:year}},
     note           = {Online; accessed ${:urldate}}
     }")

  (defvar yant/org-capture-elfeed-bibtex-template
    "@misc{key,
     title          = {${:title}},
     author         = {${:author}},
     howpublished   = {${:howpublished}},
     url            = {${:url}},
     year           = {${:year}},
     keywords       = {${:keywords}},
     note           = {Online; accessed ${:urldate}}
     }")

  (defvar yant/org-capture-github-bibtex-template
    "@misc{key,
     title          = {${:title}},
     author         = {${:author}},
     howpublished   = {${:howpublished}},
     url            = {${:url}},
     note           = {Online; accessed ${:urldate}}
     }")

  (defun yant/org-capture-cleanup-bibtex (fields template &optional bibtex-key-prefix)
    "Cleanup bibtex entry defined by FIELDS and return entry string formatted using TEMPLATE. 
  Generate cite key according to BIBTEX-KEY-PREFIX." 
    (with-temp-buffer
      (bibtex-mode)
      (bibtex-set-dialect 'BibTeX)
      (let ((title (alist-get :title fields)))
	(setf (alist-get :title fields) (replace-regexp-in-string "[()（）【】{}[]\\|\\]" "" title)))
      (insert (if (require 'org-cliplink nil 'noerror)
		  ;; Sanitize values by replacing html entities
		  (org-ref-url-html-replace (s-format template 'aget fields))
		(s-format template 'aget fields)))
      (bibtex-beginning-of-entry)
      (let (;; consider ?/ to be a separator as well
	    (split-string-default-separators "[/ \f	\n]+")
	    (bibtex-autokey-prefix-string bibtex-key-prefix))
	(org-ref-clean-bibtex-entry))
      ;; Some automatically cite keys are not sufficiently unique
      ;; Extend them by adding suffix
      (when (alist-get :cite-extra fields)
	(let ((cite-key (bibtex-key-in-head "=key=")))
	  ;; first we delete the existing key
	  (bibtex-beginning-of-entry)
	  (re-search-forward bibtex-entry-maybe-empty-head)
	  (if (match-beginning bibtex-key-in-head)
	      (delete-region (match-beginning bibtex-key-in-head)
			     (match-end bibtex-key-in-head)))
	  (insert (s-concat cite-key (alist-get :cite-extra fields)))))
      ;; set date added for the record
      (let ((ts (funcall doi-utils-timestamp-format-function)))
	(when ts
	  (bibtex-set-field doi-utils-timestamp-field
			    ts)))
      (buffer-string)
      ))

  (defun yant/org-ref-url-scrape-dois ()
    "Scrape all dois from the captured url matching a pattern in `org-ref-doi-regexps'.
  Returns a list of collected DOIs in the order found."
    (let ((dois '()))
      (with-current-buffer (yant/org-capture-get-html-buffer)
	(cl-loop for doi-pattern in org-ref-doi-regexps
		 do
		 (goto-char (point-min))
		 (while (re-search-forward doi-pattern nil t)
		   (cl-pushnew (match-string 1) dois :test #'equal)))
	(reverse dois))))

  (defun yant/org-capture-get-bibtex-doi-url ()
    "Try to scrape DOI from current url and return the bibtex entry."
    (when-let* ((dois (yant/org-ref-url-scrape-dois))
		(doi (car dois)))
      (with-temp-buffer
	(bibtex-mode)
	(bibtex-set-dialect 'BibTeX)
	(insert (doi-utils-doi-to-bibtex-string doi))
	(backward-char)
	;; set date added for the record
	(let ((ts (funcall doi-utils-timestamp-format-function)))
	  (when ts
	    (bibtex-set-field doi-utils-timestamp-field
			      ts)))
	(org-ref-clean-bibtex-entry)
	(buffer-string))))

  (defun yant/org-capture-get-bibtex-github ()
    "Parse github link and generate bibtex entry."
    (when-let ((link (plist-get org-store-link-plist :link)))
      (when (string-match "github\\.com" link)
	(with-current-buffer (yant/org-capture-get-html-buffer)
	  (let ((fields `((:url . ,link)
			  (:urldate . ,(format-time-string "%d %B %Y"))))
		entry)
	    ;; Fix URL
	    (when (string-match "^\\(.+\\)/tree/[a-zA-Z0-9]+$" link)
	      (setf (alist-get :url fields) (match-string 1 link)))
	    ;; find author url
	    (when (string-match "\\(?:https://\\)?github\\.com/[^/]+" link)
	      (push (cons :author-homepage (match-string 0 link)) fields))
	    ;; find author
	    (when (string-match "\\(?:https://\\)?github\\.com/\\([^/]+\\)" link)
	      (push (cons :author (match-string 1 link)) fields))
	    ;; find title
	    (goto-char (point-min))
	    (when (re-search-forward "<title>\\([^>]+\\)</title>" nil t)
	      (let ((title (match-string 1)))
		(when (string-match "^\\(.+\\) at [0-9a-zA-Z]\\{20,\\}$" title)
		  (setq title (match-string 1 title)))
		(push (cons :title title) fields)))
	    (push (cons :howpublished "Github") fields)
	    ;; (org-ref-url-add-nil fields)
	    (yant/org-capture-cleanup-bibtex fields yant/org-capture-github-bibtex-template "github_"))))))

  (defun yant/org-capture-get-bibtex-youtube ()
    "Parse youtube link and generate bibtex entry."
    (when-let ((link (plist-get org-store-link-plist :link)))
      (when (string-match "youtube\\.com/watch" link)
	(with-current-buffer (yant/org-capture-get-html-buffer)
	  (let ((fields `((:url . ,link)
			  (:urldate . ,(format-time-string "%d %B %Y"))))
		entry)
	    ;; find channel url
	    (goto-char (point-min))
	    (when (re-search-forward "/channel/\\([^\"]+\\)\"" nil t)
	      (let ((channel-url (s-concat "https://youtube.com/channel/" (match-string 1))))
		(push (cons :author-homepage channel-url) fields)))
	    ;; find author
	    (goto-char (point-min))
	    (push (cons :author "") fields)
	    (when (re-search-forward "channelName\":\"\\([^\"]+\\)\"" nil t)
	      (let ((channel-name (match-string 1)))
		(push (cons :author channel-name) fields)))
	    ;; find title
	    (goto-char (point-min))
	    (when (re-search-forward "title\":\"\\([^\"]+\\)\"" nil t)
	      (let ((title (match-string 1)))
		(push (cons :title title) fields)))
	    (unless (alist-get :title fields)
	      (push (cons :title (plist-get org-store-link-plist :description)) fields))
	    ;; find year
	    (goto-char (point-min))
	    (push (cons :year "") fields)
	    (when (re-search-forward "publishDate\":\"\\([^\"]+\\)\"" nil t)
	      (let ((year (match-string 1)))
		(string-match "[0-9]\\{4\\}" year)
		(push (cons :year (match-string 0 year)) fields)))
	    ;; (org-ref-url-add-nil fields)
	    (yant/org-capture-cleanup-bibtex fields yant/org-capture-youtube-bibtex-template "youtube_"))))))

  (defvar yant/org-capture-process-elfeed-functions '(yant/org-capture-process-elfeed-scientific-journal
						      yant/org-capture-process-habr-elfeed
						      yant/org-capture-process-rgoswami-elfeed
						      yant/org-capture-process-reddit-elfeed
						      yant/org-capture-process-weibo-elfeed)
    "Funcations used to process captured elfeed entries.
  The first non-nil return value will be used.
  If return value is 'ignore, do not process entry as elfeed entry.
  Each function is called with a single argument - an alist containing the following fields:
  :url - entry URL
  :urldate - date of capture
  :author - comma separated string with entry authors
  :title - entry title
  :keywords - comma separated categories (if provided by feed)
  :year - publication year
  :howpublished - suggested website name")

  (defun yant/org-capture-process-elfeed-scientific-journal (fields)
    "Journal RSS are not standardized. Easier to parse the whole html."
    (when (s-match yant/org-capture-science-journal-url-re (alist-get :url fields))
      'ignore))

  (defun yant/org-capture-process-habr-elfeed (fields)
    "Fix title in habr elfeed entries."
    ;; Habr RSS adds indication if post is translated or from sandbox, but it is not the case in the website
    (when (s-match "habr\\.com" (alist-get :url fields))
      (let ((title (alist-get :title fields)))
	(setf (alist-get :title fields) (s-replace-regexp "^\\[[^]]+\\][ ]*" "" title)))
      fields))

  (defun yant/org-capture-process-rgoswami-elfeed (fields)
    "Populate author for https://rgoswami.me"
    (when (s-match "rgoswami\\.me" (alist-get :url fields))
      (setf (alist-get :author fields) "Rohit Goswami")
      fields))

  (defun yant/org-capture-process-reddit-elfeed (fields)
    "Mention subreddit in :howpublished."
    (when (s-match "reddit\\.com" (alist-get :url fields))
      (setf (alist-get :howpublished fields)
	    (format "%s:%s"
		    (alist-get :howpublished fields)
		    (alist-get :keywords fields)))
      fields))

  (defun yant/org-capture-process-weibo-elfeed (fields)
    "Fix too short cite keys in weibo by adding user-id/article-id cite key (setting :cite-extra)."
    (when (s-match "weibo\\.com" (alist-get :url fields))
      (let* ((link (alist-get :url fields))
	     (id (and (string-match "weibo\\.com/\\([^/]+/[^/]+\\)" link)
		      (match-string 1 link))))
	(when id
	  (setf (alist-get :cite-extra fields) (format "%s" id))
	  fields))))

  (defun yant/org-capture-get-bibtex-from-elfeed ()
    "Parse elfeed capture and generate bibtex entry."
    (when-let ((link (plist-get org-store-link-plist :link)))
      (when-let ((elfeed-entry (plist-get (plist-get org-store-link-plist :query) :elfeed-data)))
	(let ((fields `((:url . ,(elfeed-entry-link elfeed-entry))
			(:howpublished . ,(elfeed-entry-link elfeed-entry))
			(:urldate . ,(format-time-string "%d %B %Y")))))
	  (when-let ((howpublished (alist-get :howpublished fields)))
	    (string-match "\\(?:https?://\\)?\\(?:www\\.\\)?\\([^/]+\\)\\.[^/]+/?" howpublished)
	    (when (match-string 1 howpublished)
	      (setf (alist-get :howpublished fields) (match-string 1 howpublished))))
	  (let ((authors (plist-get (elfeed-entry-meta elfeed-entry) :authors)))
	    (setq authors (mapcar #'cadr authors))
	    (if authors
		(push (cons :author (s-join ", " authors)) fields)
	      ;; fallback to feed title
	      (push (cons :author (elfeed-feed-title (elfeed-entry-feed elfeed-entry))) fields)))
	  (let ((title (elfeed-entry-title elfeed-entry)))
	    (push (cons :title title) fields))
	  (let ((keywords (plist-get (elfeed-entry-meta elfeed-entry) :categories)))
	    (push (cons :keywords (s-join ", " keywords)) fields))
	  (let ((date (elfeed-entry-date elfeed-entry)))
	    (push (cons :year (format-time-string "%Y" date)) fields))
	  (setq fields (or (run-hook-with-args-until-success 'yant/org-capture-process-elfeed-functions fields)
			   fields))
	  (unless (eq fields 'ignore)
	    (yant/org-capture-cleanup-bibtex fields yant/org-capture-elfeed-bibtex-template (s-concat (alist-get :howpublished fields) "_")))))))

  (defun yant/org-capture-get-bibtex-habr ()
    "Parse habrahabr link and generate bibtex entry."
    (when-let ((link (plist-get org-store-link-plist :link)))
      (when (s-match "habr\\.com" link)
	(with-current-buffer (yant/org-capture-get-html-buffer)
	  (let ((fields `((:url . ,link)
			  (:urldate . ,(format-time-string "%d %B %Y"))))
		entry)
	    ;; simplify url
	    (goto-char (point-min))
	    (when (re-search-forward "\"page_url_canonical\": \"\\([^\"]+\\)\"" nil t)
	      (let ((url (s-replace "\n" "" (match-string 1))))
		(setq url (s-replace "?[^/]+$" "" url))
		(setf (alist-get :url fields) (s-replace "\\" "" url))))
	    ;; find authors
	    (goto-char (point-min))
	    (when (re-search-forward "\"article_authors\": \\[\\([^]]+\\)" nil t)
	      (let ((authors (s-split "," (s-collapse-whitespace (s-replace "\n" "" (match-string 1))))))
		(setq authors (mapcar (apply-partially #'s-replace-regexp "^[ ]*\"\\(.+\\)\"[ ]*$" "\\1") authors))
		(setq authors (s-join ", " authors))
		(push (cons :author authors) fields)))
	    ;; find title
	    (goto-char (point-min))
	    (when (re-search-forward "\"page_title\": \"\\([^\"]+\\)\"" nil t)
	      (let ((title (match-string 1)))
		(push (cons :title title) fields)))
	    ;; find year
	    (goto-char (point-min))
	    (when (re-search-forward "datePublished\": \"\\([^\"]+\\)\"" nil t)
	      (let ((year (match-string 1)))
		(string-match "[0-9]\\{4\\}" year)
		(push (cons :year (match-string 0 year)) fields)))
	    ;; (org-ref-url-add-nil fields)
	    (yant/org-capture-cleanup-bibtex fields yant/org-capture-habr-bibtex-template
					     (s-concat "habr_"
						       (let ((url (alist-get :url fields)))
							 (if (string-match "[0-9]+" url)
							     (match-string 0 url)
							   "")))))))))

  (defvar yant/org-capture-get-bibtex-functions '(yant/org-capture-get-bibtex-from-elfeed
						  yant/org-capture-get-bibtex-youtube
						  ;; yant/org-capture-get-bibtex-habr
						  yant/org-capture-get-bibtex-github
						  yant/org-capture-get-bibtex-doi-url)
    "List of functions to generate bibtex entry during capture.
  The functions are called in order with defined `org-store-link-plist'.
  First non-nil return value is used as a headline.
  If all the functions return nil, `org-ref-url-html-to-bibtex' is used to generate the bibtex.")

  (setq org-ref-url-author-re "\\(?:<meta name=\"author\" content=\"\\(?1:.+\\)\" ?/?>\\)\\|\\(?:<[^>]*?class=\"author[^\"]*name\"[^>]*>\\(?1:[^<]+\\)<\\)")

  (defun yant/org-ref-url-html-read ()
    "Read capture link content and return fields.
  Fields include author, title, url, urldate, and year."
    ;; Start with fields we already know
    (when-let ((link (plist-get org-store-link-plist :link)))
      (let ((fields `((:url . ,link)
		      (:howpublished . ,link)
		      (:urldate . ,(format-time-string "%d %B %Y")))))
	(with-current-buffer
	    (yant/org-capture-get-html-buffer)
	  ;; find pubdate
	  (goto-char (point-min))
	  (push (cons :year "") fields)
	  (when (re-search-forward org-ref-url-date-re nil t)
	    (let ((string (match-string 2)))
	      (when (string-match "\\([0-9]\\{4\\}\\)" string)
		(setf (alist-get :year fields) (match-string 1 string)))))
	  ;; find author
	  (goto-char (point-min))
	  (push (cons :author "") fields)
	  (when (re-search-forward org-ref-url-author-re nil t)
	    (setf (alist-get :author fields) (match-string 1)))
	  ;; find title
	  (goto-char (point-min))
	  (push (cons :title "") fields)
	  (when (re-search-forward org-ref-url-title-re nil t)
	    (setf (alist-get :title fields)
		  (s-trim (decode-coding-string (match-string 1) 'utf-8))))
	  fields))))

  (defun yant/org-ref-url-html-to-bibtex (url &optional nowarn)
    "Convert URL to a bibtex entry.
  With optional argument NOWARN, do not show warning."
    (let* ((alist (yant/org-ref-url-html-read))
	   entry)
      (when-let ((howpublished (alist-get :howpublished alist)))
	(string-match "\\(?:https?://\\)?\\(?:www\\.\\)?\\([^/]+\\)\\.[^/]+/?" howpublished)
	(when (match-string 1 howpublished)
	  (setf (alist-get :howpublished alist) (match-string 1 howpublished))))
      (when (string-match "^[:lower:]" (alist-get :title alist))
	;; Capitalise title to make sure that `bibtex-autokey-get-title' can generate a valid cite key
	(setf (alist-get :title alist)
	      (s-replace-regexp "^."
				(s-upcase (match-string 0 (alist-get :title alist)))
				(alist-get :title alist))))
      (unless nowarn
	(when-let ((fifo (plist-get (plist-get org-store-link-plist :query) :fifo)))
	  (start-process-shell-command "Send message to qutebrowser"
				       nil
				       (format "echo 'message-warning \"Bookmarking unknown website using generic parser\"' >> %s" fifo))))
      (yant/org-capture-cleanup-bibtex alist org-ref-url-bibtex-template (replace-regexp-in-string "\\." "_" (s-concat (alist-get :howpublished alist) "_")))))

  (defun yant/org-capture-get-bibtex ()
    "Generate bibtex entry for currently captured item."
    (if yant/org-capture-current-bibtex
	(alist-get "raw-string" yant/org-capture-current-bibtex nil nil #'string=)
      (let ((result (or (run-hook-with-args-until-success 'yant/org-capture-get-bibtex-functions)
			(when (plist-get org-store-link-plist :link)
			  (yant/org-ref-url-html-to-bibtex (plist-get org-store-link-plist :link))))))
	(when result
	  (with-temp-buffer
	    (bibtex-mode)
	    (bibtex-set-dialect 'BibTeX)
	    (insert result)
	    (goto-char 1)
	    (setq yant/org-capture-current-bibtex (bibtex-parse-entry))
	    (unless (org-ref-reftex-get-bib-field "title" yant/org-capture-current-bibtex)
	      (setf (alist-get "title" yant/org-capture-current-bibtex nil nil #'string=) (format "{%s}" (plist-get org-store-link-plist :description))))
	    (setf (alist-get "raw-string" yant/org-capture-current-bibtex) result)))
	result)))

  (defvar yant/org-capture-get-headline-functions '(yant/org-capture-get-title-from-bibtex)
    "List of functions to generate headline (without tags) during capture.
  The functions are called in order with defined `org-store-link-plist'.
  First non-nil return value is used as a headline.
  If that is also not defined, `%:description' property from `org-store-link-plist' is used.")

  (defun yant/org-capture-get-title-from-bibtex ()
    "Try to get title from bibtex entry."
    (when (yant/org-capture-get-bibtex)
      (let ((title (org-ref-reftex-get-bib-field "title" yant/org-capture-current-bibtex))
	    (author (org-ref-reftex-get-bib-field "author" yant/org-capture-current-bibtex))
	    (year (org-ref-reftex-get-bib-field "year" yant/org-capture-current-bibtex))
	    (journal (org-ref-reftex-get-bib-field "journal" yant/org-capture-current-bibtex))
	    (howpublished (org-ref-reftex-get-bib-field "howpublished" yant/org-capture-current-bibtex)))
	(format "%s [%s] %s %s"
		(if (seq-empty-p author) "" author)
		(if (seq-empty-p journal) howpublished journal)
		(if (seq-empty-p year) "" (format "(%s)" year))
		(if (seq-empty-p title) "Untitled" title)))))

  (defun yant/org-capture-get-title ()
    "Calculate headline for currently captured item."
    (with-temp-buffer
      (insert
       (or (run-hook-with-args-until-success 'yant/org-capture-get-headline-functions)
	   (plist-get org-store-link-plist :description)))
      (shr-render-region (point-min) (point-max))
      (s-replace "\n" "" (buffer-string))))

  (defvar yant/org-capture-get-extra-functions '(yant/org-capture-extra-papers)
    "List of functions to generate body during capture.
  The functions are called in order with defined `org-store-link-plist'.
  First non-nil return value is inserted.")

  (defun yant/org-capture-extra-papers ()
    "Insert checklist for reading scientific papers."
    (let ((link (plist-get org-store-link-plist :link)))
      (pcase link
	((pred (lambda (link) (s-matches? yant/org-capture-science-journal-url-re link)))
	 (s-join "\n"
		 '("- [ ] download and attach pdf"
		   "- [ ] check if bibtex entry has missing fields"
		   "- [ ] read paper"
		   "- [ ] check citing articles"
		   "- [ ] check related articles"
		   "- [ ] check references")))
	(_
	 nil))))

  (defun yant/org-capture-get-extra ()
    "Calculate text to be inserted into body of currently captured item."
    (or (run-hook-with-args-until-success 'yant/org-capture-get-extra-functions)
	""))

  (defun yant/org-capture-check-url (url &optional no-error)
    "Check if URL was captured in the past.
  Do not throw error if NO-ERROR is non-nil."
    (let ((url-present-p (s-replace "\n" "" (shell-command-to-string (format "/home/yantar92/bin/org-check-bookmark.sh \"%s\"" url)))))
      (unless (string= "ok" url-present-p)
	(if no-error
	    t
	  (when-let ((fifo (plist-get (plist-get org-store-link-plist :query) :fifo)))
	    (start-process-shell-command "Send message to qutebrowser"
					 nil
					 (format "echo 'message-warning \"%s\"' >> %s" url-present-p fifo)))
	  (unless (doct-get :immediate-finish)
	    (org-search-view nil url)
	    (goto-char (point-min))
	    (let (headlines)
	      (while (< (point) (point-max))
		(when (get-text-property (point) 'org-hd-marker) (push (get-text-property (point) 'org-hd-marker) headlines))
		(goto-char (next-single-char-property-change (point) 'org-hd-marker)))
	      (when (= 1 (length headlines))
		(switch-to-buffer (marker-buffer (car headlines)))
		(goto-char (car headlines))
		(org-reveal))))
	  (error "%s" url-present-p)))))

  (defun yant/org-capture-get-id ()
    "Generate :ID: property."
    (yant/org-capture-get-bibtex)
    (if-let ((id (org-ref-reftex-get-bib-field "=key=" yant/org-capture-current-bibtex)))
	(if (and ;; (not (yant/org-capture-check-url (format "ID: %s\n" id)))
		 ;; (not (org-id-find id))
		 (not (yant/org-capture-check-url (s-concat "Source: " (org-ref-reftex-get-bib-field "url" yant/org-capture-current-bibtex))))
		 (not (yant/org-capture-check-url (s-concat "Source: " (plist-get org-store-link-plist :link)))))
	    id
	  (when-let ((fifo (plist-get (plist-get org-store-link-plist :query) :fifo)))
	    (start-process-shell-command "Send message to qutebrowser"
					 nil
					 (format "echo 'message-warning \"Bookmark with same ID already exist\"' >> %s" fifo)))
	  (unless (doct-get :immediate-finish)
	    (when-let ((marker (org-id-find id 'marker)))
	      (switch-to-buffer (marker-buffer marker))
	      (goto-char marker)
	      (org-show-entry)))
	  (error "Existing entry with id %s" id))
      (org-id-new)))
#+end_src

 #+begin_src emacs-lisp :tangle no
 (let ((templates (doct '( :group "Browser link"
 			 :type entry
 			 :file "~/Org/inbox.org"
 			 :fetch-bibtex (lambda ()
					  (setq yant/org-capture-current-bibtex nil)
                                          (setq yant/org-capture-html-buffer nil)
					  (funcall #'yant/org-capture-get-bibtex)
					  "") ; this must run first
			  :bibtex (lambda () (funcall #'yant/org-capture-get-bibtex))
			  :title (lambda () (funcall #'yant/org-capture-get-title))
			  :extra (lambda () (funcall #'yant/org-capture-get-extra))
			  :id (lambda () (funcall #'yant/org-capture-get-id))
			  :template
			  ("%{fetch-bibtex}* TODO %? %{title} :BOOKMARK:"
			   ":PROPERTIES:"
			   ":ID: %{id}"
			   ":CREATED: %U"
			   ":Source: %:link"
			   ":END:"
                           ":BIBTEX:"
			   "#+begin_src bibtex"
			   "%{bibtex}"
			   "#+end_src"
                           ":END:"
			   "%{extra}")
			  :children (("Interactive link"
				      :keys "b"
				      :clock-in t
				      :clock-resume t
				      )
				     ("Silent link"
				      :keys "B"
				      :immediate-finish t))))))
  (dolist (template templates)
    (asoc-put! org-capture-templates
	       (car template)
               (cdr  template)
               'replace)))
#+end_src

#+begin_src emacs-lisp
(use-package org-capture-ref
  :if init-flag
  :load-path "~/Git/org-capture-ref/"
  :after org-capture
  :demand t
  :config
  (let ((templates (doct '( :group "Browser link"
 			    :type entry
 			    :file "~/Org/inbox.org"
 			    :fetch-bibtex (lambda () (org-capture-ref-process-capture)) ; this must run first
			    :bibtex (lambda () (org-capture-ref-get-bibtex-field :bibtex-string))
                            :url (lambda () (org-capture-ref-get-bibtex-field :url))
			    :title (lambda () (format "%s%s%s%s"
						 (or (when (org-capture-ref-get-bibtex-field :author)
                                                       (let* ((authors (s-split " *and *" (org-capture-ref-get-bibtex-field :author)))
							      (author-surnames (mapcar (lambda (author)
											 (car (last (s-split " +" author))))
										       authors)))
							 (if (= 1 (length author-surnames))
                                                             (format "%s " (car author-surnames))
                                                           (format "%s, %s " (car author-surnames) (car (last author-surnames))))))
                                                     "")
                                                 (or (when (org-capture-ref-get-bibtex-field :journal)
						       (format "[%s] " (org-capture-ref-get-bibtex-field :journal)))
                                                     (when (org-capture-ref-get-bibtex-field :howpublished)
                                                       (format "[%s] " (org-capture-ref-get-bibtex-field :howpublished)))
                                                     "")
                                                 (or (when (org-capture-ref-get-bibtex-field :year)
                                                       (format "(%s) " (org-capture-ref-get-bibtex-field :year)))
                                                     "")
                                                 (or (org-capture-ref-get-bibtex-field :title)
                                                     "")))
			    :id (lambda () (org-capture-ref-get-bibtex-field :key))
			    :template
			    ("%{fetch-bibtex}* TODO %? %{title} :BOOKMARK:"
			     ":PROPERTIES:"
			     ":ID: %{id}"
			     ":CREATED: %U"
			     ":Source: %{url}"
			     ":END:"
                             ":BIBTEX:"
			     "#+begin_src bibtex"
			     "%{bibtex}"
			     "#+end_src"
                             ":END:")
			    :children (("Interactive link"
					:keys "b"
					:clock-in t
					:clock-resume t
					)
				       ("Silent link"
					:keys "B"
					:immediate-finish t))))))
    (dolist (template templates)
      (asoc-put! org-capture-templates
		 (car template)
		 (cdr  template)
		 'replace))))
#+end_src

- Link to email :: It has =:EMAIL-SOURCE:= with link to =notmuch= email (more about working with emails in [[id:e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326][Notmuch interaction]]). I also mark with tag =EMAIL=.
#+begin_src emacs-lisp
(asoc-put! org-capture-templates
	   "e"
           (cdar  (doct '("Email"
			  :keys "e"
			  :type entry
			  :file "~/Org/inbox.org"
			  :clock-in t
			  :clock-resume t
			  :template
			  ("* TODO %? #email -> $:from %:subject :EMAIL:"
			   ":PROPERTIES:"
			   ":CREATED: %U"
                           ":EMAIL-SOURCE: %l"
			   ":END:"))))
           'replace)
#+end_src


#+begin_src emacs-lisp
))
#+end_src


**** Refile
:PROPERTIES:
:ID:       c048269c-57b9-434a-a19b-6da8d70e5e0f
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Once capturing is done and I have some time, the captured notes should be scheduled and moved to the appropriate places (refiled). All the captured tasks are tagged =:INBOX:= (default tag in =inbox.org=) and can be viewed in special agenda view. The agenda has 3 groups of tasks: with deadline, scheduled, not scheduled without deadline.
First, I schedule/set deadline for all the tasks, where needed. Secondly, I set the priorities (=#A= will be always shown focused agenda). Lastly, I refile the tasks into the right projects.

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-cache t)
(setq org-refile-targets (quote ((nil :maxlevel . 9)
				 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)
					; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC

The most time consuming part of refiling is selecting the right subtree. Yes, I use helm, but it is not enough - there are too many things in my org files. Hence, I limit the refile targets to projects, which are not finished.

Occasionally, I need to add subtask to the existing task, which is not a project.

*************** TODO Change global binding in =helm-map=, it does not make sense in place, other than org mode completion
*************** END

#+begin_src emacs-lisp
(defvar refile-to-tasks nil
  "Non nil means, that single tasks will be included into refile candidates.")

(defun yant/toggle-refile-to-tasks ()
  "Toggle refiling into single tasks."
  (interactive)
  (setq refile-to-tasks (not refile-to-tasks))
  (setq org-refile-cache nil); reset refile cache
  (if refile-to-tasks (message "Refiling to tasks") (message "Not refiling to tasks")))

(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-mode-map)
(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-agenda-mode-map)
(use-package helm :config
  (bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks helm-map))

(defun yant/verify-refile-target ()
  "Exclude tasks and todo keywords with a done state from refile targets."
  (and (or refile-to-tasks
	   (or (member "REFILE" (org-get-tags (point) 'local))
	       (not (bh/is-task-p))))
       (not (member (nth 2 (org-heading-components)) org-done-keywords))))

(setq org-refile-target-verify-function 'yant/verify-refile-target)
#+end_src

*************** TODO Integrate with helm refile
*************** END


***** =__epilogue=
:PROPERTIES:
:ID:       2e6f7380-707a-4ff9-992c-4992377ae1ee
:END:
#+begin_src emacs-lisp
)
#+end_src
**** TODO Export
:PROPERTIES:
:ID:       24d7f8cf-7729-4a05-a09d-bac24ab101b5
:END:
- I do regular export in separate script since it takes a lot of time and hangs Emacs.
- Do not run babel blocks during export
  #+begin_src emacs-lisp
(setq org-export-default-inline-image-rule '(("file" . "\\.\\(gif\\|jp\\(?:e?g\\)\\|p\\(?:bm\\|gm\\|ng\\|pm\\)\\|tiff?\\|x\\(?:[bp]m\\)\\)\\'")))
  #+end_src
  #+begin_src emacs-lisp
(setq org-export-use-babel t)
(setf (alist-get :eval org-babel-default-header-args) "never-export")
  #+end_src
***** Ignore some headlines in a sense that it will not be exported as =\section=.
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:17]
:ID:       e345057c-cd79-4e89-8ecc-ed81473804f1
:END:
Sometimes, I want to have a headline, but do not want it to be exported as a section, while its text should still be exported.
It is especially useful when writing papers.
I mark such a headlines with =:ignore:= tag.
The subheadings below such a headlines are promoted up *1 level*.

#+BEGIN_SRC emacs-lisp
(use-package ox-extra
  :config
  (ox-extras-activate '(ignore-headlines)))

;; (defun yant/org-export-suppress-some-sections (data backend channel)
;;   "Do not put \\section for headlines with :NOSECEXPORT: tag."
;;   (let* ((parent (get-text-property (- (string-match "$" data) 2) :parent data))
;; 	 (headline (and parent (cadr parent)))
;;          (tags (and headline (plist-get headline :tags))))
;;     (when (and (member "NOSECEXPORT" tags)
;; 	       (not (member "SPECIALSECEXPORT" tags)))
;;       (replace-regexp-in-string "\\`.*$" "" data))))

;; (add-to-list 'org-export-filter-headline-functions 'yant/org-export-suppress-some-sections)
#+END_SRC
***** LaTeX (pdf)
:PROPERTIES:
:ID:       6fb7a08a-ed44-46e5-aee3-82f76003de4a
:END:
#+begin_src emacs-lisp
(setq org-export-exclude-tags '("NOEXPORT"))
(setq org-latex-pdf-process
      (quote
       ;; ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ("latexmk -xelatex -shell-escape -bibtex -f -output-directory=%o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ))
(setq org-export-with-timestamps nil)
(setq org-export-in-background nil)
#+end_src
****** Default settings
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:16]
:ID:       1bf4b848-2cac-4d11-a23d-a9b7cf4bcacb
:END:
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-header
      "
        \\documentclass{article}
        \\usepackage[usenames]{color}
        [PACKAGES]
        [DEFAULT-PACKAGES]
        \\pagestyle{empty}             % do not remove
        % The settings below are copied from fullpage.sty
        \\setlength{\\textwidth}{\\paperwidth}
        \\addtolength{\\textwidth}{-3cm}
        \\setlength{\\oddsidemargin}{1.5cm}
        \\addtolength{\\oddsidemargin}{-2.54cm}
        \\setlength{\\evensidemargin}{\\oddsidemargin}
        \\setlength{\\textheight}{\\paperheight}
        \\addtolength{\\textheight}{-\\headheight}
        \\addtolength{\\textheight}{-\\headsep}
        \\addtolength{\\textheight}{-\\footskip}
        \\addtolength{\\textheight}{-3cm}
        \\setlength{\\topmargin}{1.5cm}
        \\addtolength{\\topmargin}{-2.54cm}
        ")
(setq org-latex-classes
      (quote
       (("beamer" "\\documentclass[presentation]{beamer}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("article" "\\documentclass[11pt]{article}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	 ("\\paragraph{%s}" . "\\paragraph*{%s}")
	 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
	("report" "\\documentclass[11pt]{report}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("book" "\\documentclass[11pt]{book}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))))
(setq org-latex-default-packages-alist
      (quote
       (("utf8" "inputenc" t)
	("" "longtable" nil)
	("" "float" nil)
	("" "wrapfig" nil)
	("" "rotating" nil)
	("normalem" "ulem" t)
	("" "amsmath" t)
	("" "textcomp" t)
	("" "marvosym" t)
	("" "wasysym" t)
	("" "amssymb" t)
	("" "hyperref" nil)
	("" "graphicx" t)
	("" "underscore" t)
	("russian" "babel" t)
        ;; ("UTF8" "ctex" t)
	;; ("" "epstopdf" t)
	("extendedchars" "grffile" t)
	"
      	 % \\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 `dirname #1`/`basename #1`.tif`-tif-converted-to.png}
      	 % \\AppendGraphicsExtensions{.tif}
      	 \\usepackage[inline]{enumitem}
      	 \\setlistdepth{10}
      	 \\setlist[itemize,1]{label=$\\bullet$}
      	 \\setlist[itemize,2]{label=$\\bullet$}
      	 \\setlist[itemize,3]{label=$\\bullet$}
      	 \\setlist[itemize,4]{label=$\\bullet$}
      	 \\setlist[itemize,5]{label=$\\bullet$}
      	 \\setlist[itemize,6]{label=$\\bullet$}
      	 \\setlist[itemize,7]{label=$\\bullet$}
      	 \\setlist[itemize,8]{label=$\\bullet$}
      	 \\setlist[itemize,9]{label=$\\bullet$}
      	 \\setlist[itemize,10]{label=$\\bullet$}
      	 \\renewlist{itemize}{itemize}{10}
      	 \\setlist[enumerate,1]{label=$\\bullet$}
      	 \\setlist[enumerate,2]{label=$\\bullet$}
      	 \\setlist[enumerate,3]{label=$\\bullet$}
      	 \\setlist[enumerate,4]{label=$\\bullet$}
      	 \\setlist[enumerate,5]{label=$\\bullet$}
      	 \\setlist[enumerate,6]{label=$\\bullet$}
      	 \\setlist[enumerate,7]{label=$\\bullet$}
      	 \\setlist[enumerate,8]{label=$\\bullet$}
      	 \\setlist[enumerate,9]{label=$\\bullet$}
      	 \\setlist[enumerate,10]{label=$\\bullet$}
      	 \\renewlist{enumerate}{enumerate}{10}
      	 "
	"\\tolerance=1000"
	)))

#+END_SRC
***** Beamer
:PROPERTIES:
:CREATED:  [2020-05-11 Mon 16:56]
:ID:       6584931a-f8b6-4d2b-8ce2-332d03266c13
:END:

Use metropolis by default
#+begin_src emacs-lisp
(use-package ox-beamer
  :if init-flag
  :custom
  (org-beamer-theme "[numbering=fraction,block=fill,sectionpage=none]metropolis"))
#+end_src

Use my own version of block environment
#+begin_src emacs-lisp
(use-package ox-beamer
  :if init-flag
  :custom
  (org-beamer-environments-extra
   '(("hblock" "h" "\\begin{block}%a{\\vspace*{-3.1ex}}" "\\end{block}"))))
#+end_src

Rebind =C-c C-b= to something else, since I already use it for editing:
#+begin_src emacs-lisp
(use-package ox-beamer
  :if init-flag
  :bind (:map org-beamer-mode-map
	      ("C-c '" . org-beamer-select-environment)))
#+end_src

***** html
:PROPERTIES:
:ID:       cc464b8f-4be1-4463-99bc-9f1d1c9a138f
:END:
#+begin_src emacs-lisp
(setq org-html-inline-image-rules '(("file"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|tif\\)\\'")
				    ("http"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")
				    ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")))
#+end_src
***** =md=
:PROPERTIES:
:ID:       51a2db82-731b-4daf-bea9-dbcca50bc4e8
:END:
#+begin_src emacs-lisp
(use-package ox-md)
#+end_src
**** Archiving
:PROPERTIES:
:ID:       85dadb9c-2a7e-47cf-ba98-a0e73377653d
:END:

I usually archive =DONE= tasks, which were done earlier +last month or earlier+. They are shown in my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view. These are usually small tasks like =TODO Contact someone=. There is no need to keep them.

In the case if I want to keep the task and notes, I just add =:NOARCHIVE:= tag to it.

In the past I only archived the tasks, which where done before the past month, but it turned out that there are too many tasks (hundreds). When I was looking through all those tasks, I often missed some tasks I actually wanted too keep, which was sub-optimal. Now, I just consider all the done tasks as available to archive (unless marked with =:NOARCHIVE:=) and clean them regularly as a part of my [[id:26a3b0fb-17ba-4d28-8776-61502ce429bf][Work/Habits/Weekly review]].

#+begin_src emacs-lisp
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving."
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (subtree-end (save-excursion (org-end-of-subtree t)))
           (next-item (if (member "ARCHIVEALL" (org-get-tags))
			  subtree-end ; do not archive subtasks
			next-headline)))
      (if (and (member "NOARCHIVE" (org-get-tags))
	       (not (org-inlinetask-at-task-p)))
	  subtree-end
	(if (and (member (org-get-todo-state) org-done-keywords)
		 (not (member (org-get-todo-state) '("FROZEN"))))
            nil ; available to archive
	  ;; (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
	  ;; 	   ;; (a-month-ago (* 60 60 24 (+ daynr 1)))
	  ;; 	   ;; (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
	  ;; 	   (this-month (format-time-string "%Y-%m-" (current-time)))
	  ;; 	   (subtree-is-current (save-excursion
	  ;; 				 (forward-line 1)
	  ;; 				 (and (< (point) subtree-end)
	  ;; 				      (re-search-forward this-month subtree-end t)))))
	  ;;   (if subtree-is-current
	  ;; 	  next-item ; Has a date in this month or last month, skip it
	  ;; 	nil))  ; available to archive
	  next-item)))))
#+end_src

The default archiving only allow all the task from a single org file to be archived into another single file.
However, after several years, the archive files grew over 10Mb and every time I need to open them for archiving, Emacs hangs for a long time. 
Modifying =org-archive--compute-location= to accept =%y= keyword for archive year [ [[https://github.com/weirdNox/dotfiles/blob/master/config/.emacs.d/config.org#archiving][credit]] ]
In addition, =%s= and =%S= in =org-archive-location= now mean file name with extension and file without last extension.
#+begin_src emacs-lisp
(use-package org-archive
  :config
  (setq org-archive-mark-done nil)
  (setq org-archive-location "%S_archive_%y.org::datetree/* Archived Tasks")
  (defun org-archive--compute-location (location)
    (let* ((current-file (buffer-file-name (buffer-base-buffer)))
           (file-non-directory (file-name-nondirectory current-file))
           (file-sans-extension (file-name-sans-extension file-non-directory))
           (case-fold-search nil))
      (setq location (replace-regexp-in-string (regexp-quote "%s") file-non-directory location t)
            location (replace-regexp-in-string (regexp-quote "%S") file-sans-extension location t)
            location (replace-regexp-in-string (regexp-quote "%y") (format-time-string "%Y") location t))

      (unless (string-match "::" location) (error "Invalid archive location: %S" location))

      (let ((file (substring location 0 (match-beginning 0)))
            (heading (substring location (match-end 0))))
        (cons (if (org-string-nw-p file) (expand-file-name file) current-file) heading)))))
#+end_src 

Since the archives are not always contained in a single file, org id and text searches may not know all the archive files. Hence, I set more files in =org-agenda-text-search-extra-files= in addition to default 'agenda-archives. 
*************** TODO make this work
*************** END

Inline tasks cannot be archived for now ([2017-12-29 Fri]), so, I override standard archiving function to make it possible to archive them (into separate location =org-inlinetask-archive-location=)
#+BEGIN_SRC emacs-lisp
(defvar org-inlinetask-archive-location "%S_archive_%y.org::datetree/* Archived Inline Tasks"
  "Where to archive inline tasks.")
(defvar org-inlinetask-max-level 100
  "Maximum level for inline task to be archived.")

(define-advice org-archive-subtree (:around (oldfunc &rest args) org-archive-inline-task)
  "Archive inline tasks according to `org-inlinetask-archive-location'."
  (if (boundp 'org-inlinetask-min-level)
      (let* ((org-inlinetask-min-level-real org-inlinetask-min-level)
	     (at-inline-task (save-match-data (org-inlinetask-in-task-p)))
	     (org-inlinetask-min-level (if at-inline-task
					   org-inlinetask-max-level
					 org-inlinetask-min-level))
	     (org-archive-location (if at-inline-task
				       org-inlinetask-archive-location
				     org-archive-location))
	     (org-archived-inlinetask-point (point)))
	(apply oldfunc args))
    (apply oldfunc args)))

;; It is needed to cut inlinetask properly (remove trailing "***... END")
(add-hook 'org-archive-hook (lambda () (when (boundp 'org-inlinetask-min-level-real)
					 (setq org-inlinetask-min-level org-inlinetask-min-level-real))))

(define-advice org-archive-subtree (:after (&rest args) org-archive-inline-task-keep-point)
  "Keep the point after archiving inline task."
  (when (boundp 'org-archived-inlinetask-point)
    (goto-char org-archived-inlinetask-point)))
#+END_SRC

Sometimes, I have a small projects, where I do not want to decide whether I want to archive every single subtask or not. I tag them =:ARCHIVEALL:=.

Thanks God, I do not need to open my archive file frequently - my =TODO.org_archive= is =>3Mb= and takes forever to open. I am not sure if I need to do something with it.
*************** TODO Speed up opening large org files
:LOGBOOK:
- State "TODO"       from "HOLD"       [2019-05-16 Thu 11:30]
- State "HOLD"       from "TODO"          [2017-12-22 Fri 22:01] \\
  Consider it if it becomes annoying
:END:
*************** END

If a task being archived contains attachments, it is better to delete them.
Otherwise, I'd rather keep the task in place to avoid hanging files.
*************** TODO also show the attachment list when asking
*************** END

#+begin_src emacs-lisp
(setq org-attach-archive-delete 'query)

;; redefining to show the list of attachments in the query
(defun org-attach-archive-delete-maybe ()
  "Maybe delete subtree attachments when archiving.
This function is called by `org-archive-hook'.  The option
`org-attach-archive-delete' controls its behavior."
  (org-with-point-at-org-buffer
   (when (and (org-at-heading-p)
	      (member org-attach-auto-tag (org-get-tags nil t));; do not ask if no attachments
	      )
     (let ((heading (org-get-heading 'notags 'notodo 'norpiority 'nocommend)))
       (when (if (eq org-attach-archive-delete 'query)
		 (let* ((dired-buf (cl-letf (((symbol-function 'dired) (lambda (dir)
									 (interactive)
									 (dired-noselect dir nil) )))
				     (org-attach-reveal-in-emacs))))
                   (save-window-excursion
                     (dired-pop-to-buffer dired-buf)
                     (select-window (old-selected-window))
		     (prog1
			 (yes-or-no-p (format "%s: Delete all attachments? "
					      heading))
                       (kill-buffer dired-buf))))
	       org-attach-archive-delete)
	 (org-attach-delete-all t))))))
#+end_src

Archive logbook
Credit: https://www.reddit.com/r/orgmode/comments/dg43hs/can_i_archive_a_property_drawer/f3frk2n/
*************** TODO automate this
*************** END

#+begin_src emacs-lisp
(defun my/org-archive-delete-logbook ()
  (save-excursion
   (org-end-of-meta-data)
   (let ((elm (org-element-at-point)))
     (when (and
            (equal (org-element-type elm) 'drawer)
            (equal (org-element-property :drawer-name elm) "LOGBOOK"))
       (delete-region (org-element-property :begin elm)
                      (org-element-property :end elm))))))

(defun my/org-archive-without-delete ()
  (cl-letf (((symbol-function 'org-cut-subtree) (lambda () nil)))
    (org-archive-subtree)))

(defun my/org-archive-logbook ()
  (interactive)
  (my/org-archive-without-delete)
  (my/org-archive-delete-logbook))
#+end_src

**** Babel
:PROPERTIES:
:ID:       b11124c4-3bad-445e-b8d1-8f2a61471da5
:END:

Babel is a great way to combine source code and text.
The source code editing is usually done in a new buffer. However, I do not like the default binding =C-c C-'=. I use =C-c C-b= instead.

#+begin_src emacs-lisp
  (when init-flag
    (bind-key "C-c C-b" 'org-edit-special org-mode-map)
    (bind-key "C-c C-b" 'org-edit-src-exit org-src-mode-map)
    (use-package poly-org
      :defer t
      :after polymode
      :config
      (defun poly-org-edit-special ()
	"Run `org-edit-special' from poly-org."
	(interactive)
	(polymode-with-current-base-buffer #'funcall-interactively #'org-edit-special))
      (bind-key "C-c C-b" #'polymode-toggle-chunk-narrowing poly-org-mode-map)))
#+end_src

For convenience, add =header-args= property to completion

#+begin_src emacs-lisp
  (add-to-list 'org-default-properties "header-args")
#+end_src

***** Structure templates
:PROPERTIES:
:CREATED:  [2018-10-18 Thu 21:24]
:ID:       c9773614-0fec-4d7d-8ee3-72155d16d91c
:END:

I can just type =<el<TAB>= to enter elisp code block.
It can be done using =org-tempo=.

#+begin_src emacs-lisp
  (use-package org-tempo
    :if init-flag
    :init
    (push (cons "el" "src emacs-lisp") org-structure-template-alist))
#+end_src

***** Source block editing functions from scimax
:PROPERTIES:
:CREATED:  [2018-10-22 Mon 20:55]
:ID:       6d452ed8-ddb4-4252-b66e-8609866d0fe1
:END:

#+begin_src emacs-lisp
(when init-flag
  (bind-keys :map boon-command-map
	     ("S" . scimax-split-src-block)
             ("Z" . scimax-insert-src-block)))

;; from https://github.com/jkitchin/scimax/blob/master/scimax-ob.el
(defun scimax-insert-src-block (&optional below)
  "Insert a src block above the current point.
With prefix arg BELOW, insert it below the current point.
If point is in a block, copy the header to the new block"
  (interactive "P")
  (if (org-in-src-block-p)
      (let* ((src (org-element-context))
	     (start (org-element-property :begin src))
	     (end (org-element-property :end src))
	     (lang (org-element-property :language src))
	     (switches (or (org-element-property :switches src) ""))
	     (parameters (or (org-element-property :parameters src) ""))
	     location)
	(if below
	    (progn
	      (goto-char start)
	      (setq location (org-babel-where-is-src-block-result nil nil))
	      (if (not  location)
		  (goto-char end)
		(goto-char location)
		(goto-char (org-element-property :end (org-element-context))))
	      (insert (format "\n#+BEGIN_SRC %s %s %s
,#+END_SRC\n\n" lang switches parameters))
	      (forward-line -3))
	  ;; after current block
	  (goto-char (org-element-property :begin (org-element-context)))
	  (insert (format "\n#+BEGIN_SRC %s %s %s
,#+END_SRC\n\n" lang switches parameters))
	  (forward-line -3)))

    ;; Not in a src block, just insert a block
    (beginning-of-line)
    (insert (format "\n#+BEGIN_SRC %s
,#+END_SRC\n" (completing-read "Language: " (mapcar 'car org-babel-load-languages))))
    (forward-line -1)))


(defun scimax-split-src-block (&optional above)
  "Split the current src block with point in between the blocks."
  (interactive "P")
  (let* ((el (org-element-context))
	 (p (point))
	 (language (org-element-property :language el))
	 (switches (org-element-property :switches el))
	 (parameters (org-element-property :parameters el)))

    (beginning-of-line)
    (insert (format "#+END_SRC
,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))
    (forward-line -1)
    (insert "\n")
    (forward-line -1)))
#+end_src
***** TODO COMMENT Change major mode in the source blocks
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 17:28]
:ID:       b9c7a2cd-ef10-4add-aefd-ecc1987ecc69
:END:
:LOGBOOK:
- State "TODO"       from "TODO"       [2018-10-24 Wed 18:18]
- State "TODO"       from              [2018-10-24 Wed 18:17]
:END:
It is always annoying that I need switch to separate window to edit source blocks even when it is a one liner.

=Polymode= allows having multiple major modes depending on cursor position in the buffer.
I use it to activate alternative major modes in source blocks.

#+begin_src emacs-lisp
  (use-package polymode
    :if init-flag
    :straight t
    :init
    (use-package poly-org
      :straight t
      :magic "\\.org"  
      :init
      (setq poly-lock-allow-fontification nil)
      (defun org-source-block-major-mode ()
	"Return the name of major mode for the org source block at point."
	(when (re-search-forward "#\\+begin_src +\\([^ \t\n]+\\)")
	  (if (string-match "\\(bash\\|sh\\|shell\\)" (match-string 1))
	      "sh"
	    (format "%s" (match-string 1)))))
      (setq pm-inner/org
	    (pm-inner-auto-chunkmode :name "org"
				     :mode 'host
				     :head-mode 'host
				     :tail-mode 'host
				     :head-matcher "^[ \t]*#\\+begin_src .*\n"
				     :tail-matcher "^[ \t]*#\\+end_src"
				     :head-adjust-face nil
				     :mode-matcher #'org-source-block-major-mode
				   :indent-offset org-edit-src-content-indentation))))
#+end_src

=mmm-mode= also allows having multiple major modes depending on cursor position in the buffer.
However, it does not fully replace major mode locally.
This mode is only taking care about keymap, menu, local variables, font-lock, and indentation.
It does not really take care about the minor modes and does not run the =submode= hooks either.
It is not acceptable for me and it is not easy to re-implement by myself.
Leaving the code below for reference.

#+begin_src emacs-lisp :tangle no
  (use-package mmm-mode
    :if init-flag
    :straight t
    :disabled
    :init
    (setq mmm-global-mode 'auto
	  mmm-submode-decoration-level 2)
    (custom-set-faces '(mmm-declaration-submode-face ((t :background "#D1D4D9"))))
    :config
    (defun mmm-here-org-block-get-mode (heading)
      "Detect the submode to be used with the current org source block."
      (string-match "%\\#\\+begin_src +\\([^ ]+\\)" heading)
      (let ((lang (match-string-no-properties 1)))
	(if lang
	    (org-src--get-lang-mode lang)
	  (signal 'mmm-no-matching-submode nil))))

    (mmm-add-classes '((org-mode-block
			:face mmm-declaration-submode-face
			:front "^\\#\\+begin_src +\\([a-zA-Z-]+\\).*$"
			:front-offset (end-of-line 1)
			:back "^\\#\\+end_src$"
			:back-offset (beginning-of-line)
			:match-submode mmm-here-org-block-get-mode
			:delimiter-mode nil
			)))
    (mmm-add-mode-ext-class 'org-mode nil 'org-mode-block))
#+end_src

***** Backends
:PROPERTIES:
:ID:       397b6a12-0a2f-4d05-9c76-9735314434fa
:END:
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "~/.emacs.d/site-lisp/ditaa.jar")
(setq org-babel-mathematica-command "~/bin/MathematicaScript -script")

(org-babel-do-load-languages 'org-babel-load-languages
			     '(
			       (shell .t)
			       (emacs-lisp . t)
			       (org . t)
			       (perl . t)
			       (python .t)
			       (C . t)
			       (ditaa . t)
			       (gnuplot . t)
			       (calc . t)
			       (dot . t)
			       (latex . t)
			       ;;(mathematica . t)
			       ))
(use-package wolfram-mode
  :if init-flag
  :defer t
  :init
  (add-to-list 'org-src-lang-modes '("mathematica" . "wolfram")))
#+end_src
***** Default arguments
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:58]
:ID:       27e1a878-35c8-4023-8881-645393db0274
:END:
- =Noweb= is useful, I'd rather enable it everywhere than set it every time to run the code
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args '((:session . "none")
				      (:results . "replace")
                                      (:exports . "code")
                                      (:cache . "no")
                                      (:noweb . "yes")
                                      (:hlines . "no")
                                      (:tangle . "no")
                                      (:comments . "link")
                                      (:eval . "never-export")))
(setq org-babel-default-header-args:shell '((:results . "output")))
#+END_SRC
- Show stderr in the shell output ([[https://github.com/novoid/dot-emacs/blob/master/config.org][Source]])
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:sh
      '((:prologue . "exec 2>&1") (:epilogue . ":"))
      )
#+END_SRC
***** TODO Evaluation
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:03]
:ID:       49900f8e-cde9-4e41-944a-904852ad92b9
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-11 Wed 09:19]
:END:
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
I hate when org is cluttering org file directory with generated files (=:file=). It is better to save everything inside hidden entry's attachment folder instead. I just redefine =default-directory= before
=org-babel-execute-src-block=, so that =:dir= or =:output-dir= can be still set if needed.

*************** TODO we cannot do it using default-directory because expand-file-name is going recursive if org-babel-execute-src-block calls expand-file-name inside
*************** END

#+BEGIN_SRC emacs-lisp
(define-advice org-babel-execute-src-block (:filter-args (&optional args) set-detault-dir-to-org-attach-path)
  "Set working directory to the current entry's attach directory."
  (if (eq major-mode 'org-mode)
      (let* ((directory (file-name-as-directory (org-attach-dir 'create-if-none)))
	     (arg (car args))
             (info (cadr args))
             (params (org-babel-merge-params (nth 2 info) (caddr args)))
             (dir-param (alist-get :dir params)))
        (unless (and dir-param (or (equal (f-full default-directory) (f-full dir-param))
				   (f-absolute-p dir-param)))
          (setf (alist-get :dir params)
		(if dir-param
                    (f-join directory (alist-get :dir params))
                  directory)))
	(list arg info params))
    (list arg info params)))

;; (advice-remove 'org-babel-execute-src-block #'org-babel-execute-src-block@set-detault-dir-to-org-attach-path)
#+END_SRC

Allow passing file: links as variables to src blocks

#+begin_src emacs-lisp
(defun org-expand-link (link-string)
  "Convert file LINK-STRING to file path."
  (setq link-string (org-link-expand-abbrev link-string))
  (unless (string-match-p org-bracket-link-regexp link-string)
    (setq link-string (s-concat "[[" link-string "]]")))
  (let ((link
	 (with-temp-buffer
	   (let ((org-inhibit-startup nil))
	     (insert link-string)
	     (org-mode)
	     (goto-char (point-min))
	     (org-element-link-parser)))))
    (pcase (org-element-type link)
      ('link
       (org-element-property :path link))
      (_ link-string))))
#+end_src

Library of babel function definition:
#+name: org-expand-link
#+begin_src emacs-lisp :var link="file:input.txt" :tangle no
(org-expand-link link)
#+end_src

*************** TODO it should better be supported natively
*************** END

Also, it make sense to show inline images, which I frequently generate via Gnuplot after the evaluation
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC
****** TODO Gnuplot
:PROPERTIES:
:CREATED:  [2018-09-28 Fri 18:40]
:ID:       9c897a8c-e847-456d-9bf9-b905ba90f4fd
:END:

I had to modify =org-babel-expand-body:gnuplot= to make it respect =:dir= property.

#+BEGIN_SRC emacs-lisp
(defun org-babel-expand-body:gnuplot (body params)
  "Expand BODY according to PARAMS, return the expanded body."
  (save-window-excursion
    (let* ((vars (org-babel-gnuplot-process-vars params))
           (out-file (cdr (assq :file params)))
	   (prologue (cdr (assq :prologue params)))
	   (epilogue (cdr (assq :epilogue params)))
	   (term (or (cdr (assq :term params))
                     (when out-file
		       (let ((ext (file-name-extension out-file)))
			 (or (cdr (assoc (intern (downcase ext))
					 ,*org-babel-gnuplot-terms*))
			     ext)))))
           (title (cdr (assq :title params)))
           (lines (cdr (assq :line params)))
           (sets (cdr (assq :set params)))
           (x-labels (cdr (assq :xlabels params)))
           (y-labels (cdr (assq :ylabels params)))
           (timefmt (cdr (assq :timefmt params)))
           (time-ind (or (cdr (assq :timeind params))
                         (when timefmt 1)))
	   (directory (or (alist-get :dir params)
			  default-directory))
	   (add-to-body (lambda (text) (setq body (concat text "\n" body)))))
      ;; append header argument settings to body
      (when title (funcall add-to-body (format "set title '%s'" title)))
      (when lines (mapc (lambda (el) (funcall add-to-body el)) lines))
      (when sets
	(mapc (lambda (el) (funcall add-to-body (format "set %s" el))) sets))
      (when x-labels
	(funcall add-to-body
		 (format "set xtics (%s)"
			 (mapconcat (lambda (pair)
				      (format "\"%s\" %d"
					      (cdr pair) (car pair)))
				    x-labels ", "))))
      (when y-labels
	(funcall add-to-body
		 (format "set ytics (%s)"
			 (mapconcat (lambda (pair)
				      (format "\"%s\" %d"
					      (cdr pair) (car pair)))
				    y-labels ", "))))
      (when time-ind
	(funcall add-to-body "set xdata time")
	(funcall add-to-body (concat "set timefmt \""
				     (or timefmt
					 "%Y-%m-%d-%H:%M:%S") "\"")))
      (when out-file
	;; set the terminal at the top of the block
	(funcall add-to-body (format "set output \"%s\"" out-file))
	;; and close the terminal at the bottom of the block
	(setq body (concat body "\nset output\n")))
      (when term (funcall add-to-body (format "set term %s" term)))
      ;; insert variables into code body: this should happen last
      ;; placing the variables at the *top* of the code in case their
      ;; values are used later
      (funcall add-to-body
	       (mapconcat #'identity
			  (org-babel-variable-assignments:gnuplot params)
			  "\n"))
      ;; replace any variable names preceded by '$' with the actual
      ;; value of the variable
      (mapc (lambda (pair)
	      (setq body (replace-regexp-in-string
			  (format "\\$%s" (car pair)) (cdr pair) body)))
	    vars)
      (when prologue (funcall add-to-body prologue))
      (when epilogue (setq body (concat body "\n" epilogue)))
      ;; Setting the directory needs to be done first so that
      ;; subsequent 'output' directive goes to the right place.
      (when directory (funcall add-to-body (format "cd '%s'" directory))))
    body))
#+END_SRC

****** Async evaluation
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 21:10]
:ID:       11a37f26-ef17-43ec-bb9b-43155f9fc9ec
:END:
#+begin_src emacs-lisp
(use-package ob-async
  :straight t
  )
#+end_src
***** TODO Tangle
:PROPERTIES:
:ID:       6e72e3ca-4679-4caf-9af4-2291096eab58
:END:
I have a lot of small scripts and programs written at some point for some purpose I do not remember anymore. Hence, I prefer to use org files instead of all kinds of script files in the system. There are few things, which I need to make it work comfortably:
- make sure that the script are tangled when I save org file, because it is easy to forget tangling of some files after editing.

*************** TODO rewrite using threads
*************** END


#+begin_src emacs-lisp
(defun yant/org-babel-tangle-async (file &optional target-file lang)
  "Invoke `org-babel-tangle-file' asynchronously."
  (require 'async)
  (message "Tangling %s..." (buffer-file-name))
  (async-start
   (let ((args (list file target-file lang)))
     `(lambda ()
	(require 'org)
	(setq org-tangle-flag t)
        (ignore-errors
	  (load "~/.emacs.d/config.el"))
	(let ((start-time (current-time)))
          (org-with-wide-buffer
	   (apply #'org-babel-tangle-file ',args))
	  (list (float-time (time-since start-time))))))
   (let ((message-string (format "Tangling (%S %S %S) completed in " file target-file lang)))
     `(lambda (tangle-time) (message (concat ,message-string
					(format "%s seconds" tangle-time)))))))

(defvar yant/auto-tangle-list nil
  "List of files, which can be safely tangled on save.
The list is saved between Emacs sessions.")

(when init-flag
  (use-package savehist
    :config
    (add-to-list 'savehist-additional-variables 'yant/auto-tangle-list))
  (savehist-mode +1)
  (defun yant/toggle-buffer-auto-tangle (arg)
    "Toggle auto tangling of a buffer."
    (interactive "P")
    (if (not (eq major-mode 'org-mode))
	(message "Org-mode is not active in buffer \"%s\"" (buffer-name))
      (cond ((not arg)
	     (if (member (buffer-file-name) yant/auto-tangle-list)
		 (progn (setq yant/auto-tangle-list (delete (buffer-file-name) yant/auto-tangle-list))
			(message "Auto tangling disabled for %s" (buffer-file-name)))
	       (add-to-list 'yant/auto-tangle-list (buffer-file-name))
               (message "Auto tangling enabled for %s" (buffer-file-name))))
            ((or (and (not (listp arg)) (> arg 0))
		 (equal arg '(4)))
             (add-to-list 'yant/auto-tangle-list (buffer-file-name))
             (message "Auto tangling enabled for %s" (buffer-file-name)))
            (t
             (setq yant/auto-tangle-list (delete (buffer-file-name) yant/auto-tangle-list))
	     (message "Auto tangling disabled for %s" (buffer-file-name))))))

  (bind-key "C-c C-*" #'yant/toggle-buffer-auto-tangle org-mode-map))

(defun yant/org-babel-tangle-current-buffer-async ()
  "Tangle current buffer asynchronously."
  (when (and (eq major-mode 'org-mode)
	     (member (buffer-file-name) yant/auto-tangle-list))
    (yant/org-babel-tangle-async (buffer-file-name))))

(add-hook 'after-save-hook #'yant/org-babel-tangle-current-buffer-async)
#+end_src

***** Export
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:47]
:END:
Frequently, I run heavy analytical code as a part of my project. I it totally inconvenient to run these hour longing codes during export. Hence, I [[id:27e1a878-35c8-4023-8881-645393db0274][disable]] babel evaluation on export by default.
***** Library of babel
:PROPERTIES:
:CREATED:  [2019-11-18 Mon 21:53]
:ID:       301b1c19-8474-444e-b840-06bb8b3ddb69
:END:


https://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html
In addition to lisp code in =init.el=, it is also possible to define globally available babel functions defined, for example. in this file
*************** TODO this creates some strange error
*************** END
#+begin_src emacs-lisp
(use-package org
  :hook (org-load . yant/org-babel-ingest-my-files)
  :config
  (defun yant/org-babel-ingest-my-files ()
    "Load default babel library files."  
    (org-babel-lob-ingest
     (expand-file-name "~/.emacs.d/config.org"))))
#+end_src

#+name: get-named-text
#+begin_src elisp :var name="docstring" :tangle no
  (let* ((named-element (org-element-map (org-element-parse-buffer) org-element-all-elements
                          (lambda (element)
                            (when (string= (org-element-property :name element) name)
                              element))
                          nil t))
         (result (buffer-substring (org-element-property :contents-begin named-element)
                                   (org-element-property :contents-end named-element))))
    (format "\"%s\"" (replace-regexp-in-string "\\\"" "\\\\\"" result))) ;; escape quote
#+end_src

*************** TODO make auto-completion possible for babel blocks from inside editing org-src
*************** END

**** COMMENT Alerts - system notifications
:PROPERTIES:
:CREATED:  [2020-04-28 Tue 23:25]
:END:

Alert for upcoming scheduled or agenda entries or agenda entries containing deadline.
*************** TODO this does not work because of my agenda prefix customisation
*************** END

#+begin_src emacs-lisp
(use-package org-alert
  :straight t
  :config
  (setq alert-default-style 'libnotify)
  (org-alert-enable))
#+end_src

*** Preview
:PROPERTIES:
:ID:       a85d2993-1d90-40b3-b69a-52cf7d6bd18b
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
Preview images and latex formulas.
#+begin_src emacs-lisp
(setq org-image-actual-width '(300))
(setq org-latex-create-formula-image-program 'imagemagick)
(setq org-format-latex-options
      (quote
       (:foreground default :background default :scale 2.0 :justify center :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers
		    ("begin" "$1" "$" "$$" "\\(" "\\["))));; 2x height of formulas
(setq org-latex-inline-image-rules
      (quote
       (("file" . "\\.\\(jpeg\\|jpg\\|png\\|eps\\|tikz\\|pgf\\|svg\\|bmp\\|tif\\)\\'"))))
#+end_src

Toggle preview of an image at point (by =C-c C-c= or =TAB=).
This is especially useful in large buffers where processing all the images by =org-toggle-inline-images= takes too much time.
Inspired by https://www.reddit.com/r/orgmode/comments/f8qngz/toggle_only_current_inline_image_with_tab/
#+begin_src emacs-lisp
(use-package org
  :config
  (defun org-toggle-inline-images-at-point ()
    (when-let* ((link-region (org-in-regexp org-link-bracket-re 1)))
      (let ((org-inline-image-overlays-old org-inline-image-overlays))
	(save-restriction
	  (narrow-to-region (car link-region) (cdr link-region))
	  (if (-intersection (overlays-at (point)) org-inline-image-overlays)
	      (mapc (lambda (ov)
		      (when (member ov org-inline-image-overlays)
			(delete-overlay ov)
			(setq org-inline-image-overlays (delete ov org-inline-image-overlays))))
		    (overlays-at (point)))
	    (org-display-inline-images 'include-linked 'refresh))
	  )
	(unless (equal org-inline-image-overlays org-inline-image-overlays-old) t)) ;; if overlays did not change, the link is not inline image
      ))
  (add-hook 'org-tab-first-hook #'org-toggle-inline-images-at-point)
  (add-hook 'org-ctrl-c-ctrl-c-hook #'org-toggle-inline-images-at-point))
#+end_src

Use the same binding to preview LaTeX
#+begin_src emacs-lisp
  (use-package org
    :if init-flag
    :config
    (defun yant/org-toggle-latex-fragment-at-point-maybe ()
      "Toggle latex fragment at point or return nil if no fragment is at point."
      (when (and (eq major-mode 'org-mode)
		 (eq (org-element-type (org-element-context)) 'latex-fragment))
	(org-toggle-latex-fragment)))
    (add-hook 'org-tab-first-hook #'org-toggle-inline-images-at-point)
    (add-hook 'org-ctrl-c-ctrl-c-hook #'yant/org-toggle-latex-fragment-at-point-maybe))
#+end_src

Justify and number the formulas
#+begin_src emacs-lisp
;; from https://github.com/jkitchin/scimax/blob/master/scimax-org.el
(use-package ov
  :straight t
  :config
  (defun org-latex-fragment-justify (justification)
    "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
    (interactive
     (list (intern-soft
            (completing-read "Justification (left): " '(left center right)
                             nil t nil nil 'left))))

    (let* ((ov (ov-at))
	   (beg (ov-beg ov))
	   (end (ov-end ov))
	   (shift (- beg (line-beginning-position)))
	   (img (overlay-get ov 'display))
	   (img (and (and img (consp img) (eq (car img) 'image)
			  (image-type-available-p (plist-get (cdr img) :type)))
		     img))
	   space-left offset)
      (when (and img
		 ;; This means the equation is at the start of the line
		 (= beg (line-beginning-position))
		 (or
		  (string= "" (s-trim (buffer-substring end (line-end-position))))
		  (eq 'latex-environment (car (org-element-context)))))
	(setq space-left (- (window-max-chars-per-line) (car (image-size img)))
	      offset (floor (cond
			     ((eq justification 'center)
			      (- (/ space-left 2) shift))
			     ((eq justification 'right)
			      (- space-left shift))
			     (t
			      0))))
	(when (>= offset 0)
	  (overlay-put ov 'before-string (make-string offset ?\ ))))))

  (defun org-latex-fragment-justify-advice (beg end image imagetype)
    "After advice function to justify fragments."
    (org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))

  (advice-add 'org--format-latex-make-overlay :after 'org-latex-fragment-justify-advice)

  ;; ** numbering latex equations

  ;; Numbered equations all have (1) as the number for fragments with vanilla
  ;; org-mode. This code injects the correct numbers into the previews so they
  ;; look good.
  (defun org-renumber-environment (orig-func &rest args)
    "A function to inject numbers in LaTeX fragment previews."
    (let ((results '())
	  (counter -1)
	  (numberp))

      (setq results (loop for (begin .  env) in
			  (org-element-map (org-element-parse-buffer) 'latex-environment
			    (lambda (env)
			      (cons
			       (org-element-property :begin env)
			       (org-element-property :value env))))
			  collect
			  (cond
			   ((and (string-match "\\\\begin{equation}" env)
				 (not (string-match "\\\\tag{" env)))
			    (incf counter)
			    (cons begin counter))
			   ((string-match "\\\\begin{align}" env)
			    (prog2
				(incf counter)
				(cons begin counter)
			      (with-temp-buffer
				(insert env)
				(goto-char (point-min))
				;; \\ is used for a new line. Each one leads to a number
				(incf counter (count-matches "\\\\$"))
				;; unless there are nonumbers.
				(goto-char (point-min))
				(decf counter (count-matches "\\nonumber")))))
			   (t
			    (cons begin nil)))))

      (when (setq numberp (cdr (assoc (point) results)))
	(setf (car args)
	      (concat
	       (format "\\setcounter{equation}{%s}\n" numberp)
	       (car args)))))

    (apply orig-func args))

  (advice-add 'org-create-formula-image :around #'org-renumber-environment)

  (defun org-inject-latex-fragment (orig-func &rest args)
    "Advice function to inject latex code before and/or after the equation in a latex fragment.
You can use this to set \\mathversion{bold} for example to make it bolder."
    (setf (car args)
	  (concat
	   (or (plist-get org-format-latex-options :latex-fragment-pre-body) "")
	   (car args)
	   (or (plist-get org-format-latex-options :latex-fragment-post-body) "")))
    (apply orig-func args))

  (advice-add 'org-create-formula-image :around #'org-inject-latex-fragment )
  )
#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       153a637e-68b2-40fd-b75f-5fea92bcc071
:END:
#+begin_src emacs-lisp
)
#+end_src

*** Appearance
**** Lighter
:PROPERTIES:
:CREATED:  [2020-04-21 Tue 11:28]
:ID:       062a0aaf-3f3b-4eef-b8cf-a19da865e51c
:END:

Org-capture mode lighter

#+begin_src emacs-lisp
(use-package org-capture
  :if init-flag
  :config
  (diminish 'org-capture-mode (s-concat " "
					(propertize (all-the-icons-material "note_add" 
									    :v-adjust 0.04)
						    'face `(( :family "Material Icons"
							      :foreground "red"
                                                              :height 1.4))))))
#+end_src

Org src mode lighter

#+begin_src emacs-lisp
(use-package org-src
  :if init-flag
  :after org
  :config
  (diminish 'org-src-mode (s-concat " "
                                    (propertize (all-the-icons-material "code" :v-adjust 0.04)
						'face `((
							 :family "Material Icons"
							 :height 1.2))
						;; 'display '(raise -0.2)
                                                )
				    "org")))
#+end_src
**** Text
:PROPERTIES:
:CREATED:  [2020-04-27 Mon 13:25]
:ID:       84e7aa2b-c488-4dfd-a794-16b5059f4082
:END:

Add some extra rendering for LaTeX:
#+begin_src emacs-lisp
(add-to-list 'org-entities-user '("angstrom" "\\AA" nil "&Å;" "A" "A" "Å"))
#+end_src

Line truncation:
#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :config
  (add-hook! 'org-mode-hook (let ((inhibit-message t))
			      (toggle-truncate-lines -1)
                              (visual-line-mode +1))))
#+end_src

Extend line background to the end of buffer in source blocks
#+begin_src emacs-lisp
(use-package org-faces
  :config
  (set-face-extend 'org-block t))
#+end_src

**** Links
***** Show broken links to files
:PROPERTIES:
:ID:       df5b9cb0-e3d1-406e-b71f-55a7b90c221e
:END:
#+begin_src emacs-lisp
(org-link-set-parameters
 "file"
 :face (lambda (path) (if (file-exists-p (org-link-unescape path)) 'org-link 'org-warning)))
#+end_src
***** Use posframe to offer link selection
:PROPERTIES:
:CREATED:  [2020-03-28 Sat 18:51]
:ID:       e8ee8fc7-55ec-4396-83e6-97559ab1d5bf
:END:

#+begin_src emacs-lisp
(use-package posframe
  :if init-flag
  :straight t
  :after el-patch
  :config
  (el-patch-feature 'org)
  (el-patch-defun org-offer-links-in-entry (buffer marker &optional nth zero)
    "Offer links in the current entry and return the selected link.
If there is only one link, return it.
If NTH is an integer, return the NTH link found.
If ZERO is a string, check also this string for a link, and if
there is one, return it."
    (with-current-buffer buffer
      (org-with-wide-buffer
       (goto-char marker)
       (let ((cnt ?0)
	     have-zero end links link c)
	 (when (and (stringp zero) (string-match org-link-bracket-re zero))
	   (push ((el-patch-swap match-string match-string-no-properties) 0 zero) links)
	   (setq cnt (1- cnt) have-zero t))
	 (save-excursion
	   (org-back-to-heading t)
	   (setq end (save-excursion (outline-next-heading) (point)))
	   (while (re-search-forward org-link-any-re end t)
	     (push ((el-patch-swap match-string match-string-no-properties) 0) links))
	   (setq links (org-uniquify (reverse links))))
	 (cond
	  ((null links)
	   (message "No links"))
	  ((equal (length links) 1)
	   (setq link (car links)))
	  ((and (integerp nth) (>= (length links) (if have-zero (1+ nth) nth)))
	   (setq link (nth (if have-zero nth (1- nth)) links)))
	  (t				; we have to select a link
	   (save-excursion
	     (save-window-excursion
	       (el-patch-remove (delete-other-windows))
	       ((el-patch-swap with-output-to-temp-buffer with-current-buffer) (el-patch-swap  "*Select Link*" (get-buffer-create "*Select Link*"))
                (el-patch-add (erase-buffer))
                (el-patch-add (insert "Select link to open, RET to open all:\n"))
		(dolist (l links)
		  (cond
		   ((not (string-match org-link-bracket-re l))
		    ((el-patch-swap princ insert) (format "[%c]  %s\n" (cl-incf cnt)
							  (org-unbracket-string "<" ">" l))))
		   ((match-end 2)
		    ((el-patch-swap princ insert)  (format "[%c]  %s (%s)\n" (cl-incf cnt)
							   (match-string 2 l) (match-string 1 l))))
		   (t ((el-patch-swap princ insert)  (format "[%c]  %s\n" (cl-incf cnt)
							     (match-string 1 l)))))))
               (el-patch-wrap 1 0
                 (unwind-protect
                     (el-patch-wrap 1 0
		       (progn
			 (el-patch-swap
			   (org-fit-window-to-buffer (get-buffer-window "*Select Link*"))
			   (posframe-show (get-buffer "*Select Link*")
					  :poshandler 'posframe-poshandler-frame-center
                                          :foreground-color (face-foreground 'mode-line)
                                          :background-color (face-background 'mode-line)
                                          :internal-border-width 20
					  ))
			 (message "Select link to open, RET to open all:")
			 (setq c (read-char-exclusive))))
		   (and (get-buffer "*Select Link*") (kill-buffer "*Select Link*"))))))
	   (when (equal c ?q) (user-error "Abort"))
	   (if (equal c ?\C-m)
	       (setq link links)
	     (setq nth (- c ?0))
	     (when have-zero (setq nth (1+ nth)))
	     (unless (and (integerp nth) (>= (length links) nth))
	       (user-error "Invalid link selection"))
	     (setq link (nth (1- nth) links)))))
	 (cons link end))))))
#+end_src
**** Items
:PROPERTIES:
:ID:       6b238696-fbbe-4206-91fb-eeebff4a032a
:END:
I do not want bigger items font because I tend to use items a lot
  #+begin_src emacs-lisp
(custom-set-faces
 '(org-level-1 ((t (:inherit outline-1 :height 1.0))))
 '(org-level-2 ((t (:inherit outline-2 :height 1.0))))
 '(org-level-3 ((t (:inherit outline-3 :height 1.0))))
 '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
 '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
 )
  #+end_src
Utilise =pretty-symbols= to show bullets, priorities, and keywords. It is much faster than overlay-based =org-bullets=.
  #+begin_src emacs-lisp
(use-package pretty-symbols
  :config
  (require 'org-inlinetask)
  (setq pretty-symbol-patterns
	(append pretty-symbol-patterns
		`(;;(?▤ org-specific ":LOGBOOK:" (org-mode))
      		  ;;(?⚙ org-specific ":PROPERTIES:" (org-mode))
      		  ;;(?⏏ org-specific ":END:" (org-mode))
                  (?— org-specific "\\b---\\b" (org-mode))
      		  (?★ org-specific "\\[#A\\]" (org-mode))
      		  (?- org-specific "\\[#B\\]" (org-mode))
      		  (?☕ org-specific "\\[#C\\]" (org-mode))
                  (?■ org-specific "\\(^\\*\\)[^*]" (org-mode) 1)
                  (?• org-specific "^\\(?:\\*\\{1\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⊢ org-specific "^\\(?:\\*\\{2\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋮ org-specific "^\\(?:\\*\\{3\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋱ org-specific "^\\(?:\\*\\{4\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋮ org-specific "^\\(?:\\*\\{5\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋱ org-specific "^\\(?:\\*\\{6\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋮ org-specific "^\\(?:\\*\\{7\\}\\)\\(\\*\\)[^*]" (org-mode) 1)
                  (?⋱ org-specific ,(format  "^\\(?:\\*\\{8,%d\\}\\)\\(\\*\\)[^*]" (- org-inlinetask-min-level 2)) (org-mode) 1)
                  ((yant/str-to-glyph " ") org-specific ,(format  "^\\(\\*\\{%d,%d\\}\\)\\*[^*]" (1- org-inlinetask-min-level) (1- org-inlinetask-max-level)) (org-mode) 1)
                  ((yant/str-to-glyph "⇒⇒⇒") org-specific ,(format  "^\\(\\*\\{%d,%d\\}\\)\\(\\*\\)[^*]" (1- org-inlinetask-min-level) (1- org-inlinetask-max-level)) (org-mode) 2)
                  (?╭ org-specific "^[ ]*#[+]NAME" (org-mode))
                  (?╭ org-specific "^[ ]*#[+]name" (org-mode))
                  (?├ org-specific "[ ]*#[+]begin_src" (org-mode))
                  (?├ org-specific "[ ]*#[+]BEGIN_SRC" (org-mode))
                  (?╰ org-specific "[ ]*#[+]end_src" (org-mode))
                  (?╰ org-specific "[ ]*#[+]END_SRC" (org-mode))
                  (?╞ org-specific "[ ]*#[+]TBLFM" (org-mode))
                  (?🗣 org-specific "[ ]*#[+]begin_quote" (org-mode))
                  (?🗣 org-specific "[ ]*#[+]end_quote" (org-mode))
                  (?🗣 org-specific "[ ]*#[+]BEGIN_QUOTE" (org-mode))
                  (?🗣 org-specific "[ ]*#[+]END_QUOTE" (org-mode))
                  (?💡 org-specific "[ ]*#[+]begin_example" (org-mode))
                  (?💡 org-specific "[ ]*#[+]end_example" (org-mode))
                  (?💡 org-specific "[ ]*#[+]BEGIN_EXAMPLE" (org-mode))
                  (?💡 org-specific "[ ]*#[+]END_EXAMPLE" (org-mode))
                  (?⏎ org-specific "[ ]*#[+]RESULTS" (org-mode))
                  (?⫘ org-specific "[ ]*#[+]SETUPFILE" (org-mode))
                  (?👨 org-specific "[ ]*#[+]AUTHOR" (org-mode))
                  (?🖂 org-specific "[ ]*#[+]EMAIL" (org-mode))
                  (?⚙ org-specific "[ ]*#[+]PROPERTY" (org-mode))
                  (?⏣ org-specific "[ ]*#[+]OPTIONS" (org-mode))
                  (?🔗 org-specific ":\\(BOOKMARK\\):" (org-mode) 1)
                  (?🖬 org-specific ":\\(ARCHIVED\\):" (org-mode) 1)
                  ((yant/str-to-glyph "📁📁📁") org-specific ":\\(ATTACH\\):" (org-mode) 1)
                  (?🖳 org-specific ":\\(PhD\\):" (org-mode) 1)
                  (?🏠 org-specific ":\\(COMMON\\):" (org-mode) 1)
                  (?🖂 org-specific ":\\(EMAIL\\):" (org-mode) 1)
      		  (?☐ org-specific "\\(?:^*+ +\\)\\(\\<TODO\\>\\)" (org-mode) 1)
                  (?⯑ org-specific "\\(?:^*+ +\\)\\(\\<SOMEDAY\\>\\)" (org-mode) 1)
      		  (?☑ org-specific "\\(?:^*+ +\\)\\(\\<DONE\\>\\)" (org-mode) 1)
      		  (?✘ org-specific "\\(?:^*+ +\\)\\(\\<FAILED\\>\\)" (org-mode) 1)
      		  (?✘ org-specific "\\(?:^*+ +\\)\\(\\<CANCELLED\\>\\)" (org-mode) 1)
      		  (?▶ org-specific "\\(?:^*+ +\\)\\(\\<NEXT\\>\\)" (org-mode) 1)
                  (?⛕ org-specific "\\(?:^*+ +\\)\\(\\<MERGED\\>\\)" (org-mode) 1)
      		  (?⌛ org-specific "\\(?:^*+ +\\)\\(\\<WAITING\\>\\)" (org-mode) 1)
                  (?⏩ org-specific "\\(?:^*+ +\\)\\(\\<DOING\\>\\)" (org-mode) 1)
      		  (?⛔ org-specific "\\(?:^*+ +\\)\\(\\<HOLD\\>\\)" (org-mode) 1)
                  (?❄ org-specific "\\(?:^*+ +\\)\\(\\<FROZEN\\>\\)" (org-mode) 1)
                  (?🖹 org-specific "\\(?:^*+ +\\)\\(\\<REVIEW\\>\\)" (org-mode) 1)
      		  ((yant/str-to-glyph "☠D") org-specific "\\<DEADLINE:" (org-mode))
      		  ((yant/str-to-glyph "◴S") org-specific "\\<SCHEDULED:" (org-mode))))))
  #+end_src
Prefer to replace default =...= by something more distinct if item is folded
  #+BEGIN_SRC emacs-lisp
(setq org-ellipsis "  ")
(set-face-underline 'org-ellipsis nil)
  #+END_SRC
blanks in items
  #+begin_src emacs-lisp
;;turn off blanks in a new entries
(setq org-blank-before-new-entry (quote ((heading . auto)
					 (plain-list-item . auto))))
(setq org-cycle-separator-lines 2)
  #+end_src
hide emphasis markers
  #+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
  #+end_src
keyword faces
  #+begin_src emacs-lisp
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
      	      ("NEXT" :foreground "blue" :weight bold)
              ("DOING" :foreground "blue" :weight bold)
              ("SOMEDAY" :foreground "black" :weight bold)
      	      ("DONE" :foreground "forest green" :weight bold)
      	      ("FAILED" :foreground "red" :weight bold)
      	      ("WAITING" :foreground "orange" :weight bold)
              ("REVIEW" :foreground "orange" :weight bold)
      	      ("HOLD" :foreground "magenta" :weight bold)
      	      ("CANCELLED" :foreground "gray80" :weight bold)
              ("FROZEN" :foreground "SkyBlue" :weight bold)
	      ("MERGED" :foreground "light green" :weight bold))))
#+end_src
truncation by default
#+BEGIN_SRC emacs-lisp
(setq org-startup-truncated t)
#+END_SRC
no leading stars
#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC
no indentation inside entries
#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC
show sticky headers on tall tables
#+begin_src emacs-lisp
(use-package org-table-sticky-header
  :straight t
  :diminish org-table-sticky-header-mode
  :hook (org-mode . org-table-sticky-header-mode))
#+end_src
hyphen as em-dash (from [[https://github.com/grettke/help/blob/master/help.org][here]])
#+begin_src emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^[[:space:]]*\\(-\\) "
    0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "—")))))
#+end_src

Show tags right justified
#+begin_src emacs-lisp
(setq org-tags-column (- (length org-ellipsis)
                             150))
#+end_src

Always show the contents of inline tasks instead of hiding/showing it during cycling.

#+begin_src emacs-lisp
(remove-hook 'org-cycle-hook 'org-inlinetask-hide-tasks)
#+end_src

Use smaller font for inline headings without keyword 

#+begin_src emacs-lisp
(use-package org-inlinetask
  :if init-flag
  :hook (org-font-lock . yant/org-inlinetask-fontify-notodo)
  :config
  (defface org-inlinetask-notodo '((t :inherit shadow  :height 0.8))
    "Face for inlinetask headlines without todo keywords."
    :group 'org-faces)
  (defun yant/org-inlinetask-fontify-notodo (limit)
    "Fontify the inline tasks with no todo keyword down to LIMIT."
    (let* ((nstars (if org-odd-levels-only
		       (1- (* 2 (or org-inlinetask-min-level 200)))
		     (or org-inlinetask-min-level 200)))
	   (re (concat "^\\(\\*\\)\\(\\*\\{"
		       (format "%d" (- nstars 3))
		       ",\\}\\)\\(\\*\\*[ \t]+\\)")))
      (org-back-to-heading-or-point-min 'invisible-ok)
      (while (re-search-forward re limit t)
	(unless (looking-at-p org-todo-regexp)
          (add-text-properties (point) (line-end-position) `(face org-inlinetask-notodo font-lock-fontified t)))))))
#+end_src

Hide END part of inline tasks

#+begin_src emacs-lisp
;; (add-hook! 'org-mode-hook (cursor-intangible-mode +1))
(add-hook! 'org-mode-hook (add-to-list 'font-lock-extra-managed-props 'display))

(use-package org-inlinetask
  :if init-flag
  :hook (org-font-lock . yant/org-inlinetask-hide-END)
  :config
  (defun yant/org-inlinetask-hide-END (limit)
    "Hide END line of inlinetasks."
    (let* ((nstars (if org-odd-levels-only
		       (1- (* 2 (or org-inlinetask-min-level 200)))
		     (or org-inlinetask-min-level 200)))
	   (re (concat "^\\(\\*\\)\\(\\*\\{"
		       (format "%d" (- nstars 3))
		       ",\\}\\)\\(\\*\\* END[ \t]*$\\)")))
      (while (re-search-forward re limit t)
	(with-silent-modifications
          (compose-region (1- (match-beginning 0)) (match-end 0)
			  ?🬉 'decompose-region)
          )))))
#+end_src

Disallow user edits inside property drawers

#+begin_src emacs-lisp
;; (add-hook! 'org-mode-hook (cursor-intangible-mode +1))

;; (use-package org-inlinetask
;;   :if init-flag
;;   :hook (org-font-lock . yant/org-intanglible-property)
;;   :config
;;   (defun yant/org-intanglible-property (limit)
;;     "Make property drawers cursor intanglible."
;;     (while (re-search-forward org-property-drawer-re limit t)
;;       (with-silent-modifications
;; 	(save-excursion
;;           (goto-char (match-beginning 0))
;;           (forward-line)
;;           (add-text-properties (point) (match-end 0)
;; 			       `(cursor-intangible t)))))))
#+end_src


fit inline LaTeX better by increasing the image size [[[https://github.com/tecosaur/emacs-config/blob/master/config.org#latex-fragments][credit]]]
#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{color}

\\usepackage[T1]{fontenc}
\\usepackage{mathtools}
\\usepackage{textcomp,amssymb}
\\usepackage[makeroom]{cancel}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage{arev}
\\usepackage{arevmath}")
#+end_src

*************** TODO rewrite into smaller chunks
*************** END

#+begin_src emacs-lisp
(use-package doom-themes
  :if init-flag
  :straight t
  :config
  (use-package doom-themes-ext-org
    :demand t))
#+end_src
**** Align tags to right, even when the window size changes
:PROPERTIES:
:CREATED:  [2020-07-17 Fri 15:21]
:ID:       d5a3c2c8-c6b1-4f21-a548-f6bb8bf85949
:END:

*************** TODO not reliable, acts on  first space in  empty headline as well
*************** END

*************** TODO it seems that org-align-tags intereferes with helm completion in bizarre way when tag string appears inside the completion
*************** END

#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :custom
  (org-auto-align-tags nil)
  :config
  ;; (add-hook 'org-mode-hook (lambda () (font-lock-add-keywords nil '(yant/org-align-tags) t)) 100)
  (add-hook! 'org-mode-hook (add-to-list 'font-lock-extra-managed-props 'org-tag-aligned))

  (add-hook! 'org-mode-hook (setq-local adaptive-fill-function #'org-adaptive-fill-function))
  (defun org-adaptive-fill-function ()
    "Fill headlines to the beginning of headline in org."
    (save-excursion
      (when (org-at-heading-p)
	(beginning-of-line)
        (looking-at org-complex-heading-regexp)
        (goto-char (match-beginning 4)) ;; at headline
        (make-string (current-column) ?\ ))))

  (defun yant/org-align-tags (limit &optional force)
    "Align all the tags in org buffer."
    (when (eq major-mode 'org-mode)
      (save-excursion
	(while (re-search-forward "^\\*+ \\(.+?\\)\\([ \t]+\\)\\(:\\(?:[^ \n]+:\\)+\\)$" limit t)
	  (when (and (match-string 2)
		     (or force
			 (not (get-text-property (match-beginning 2) 'org-tag-aligned))))
	    (with-silent-modifications
              (put-text-property (match-beginning 2) (match-end 2) 'org-tag-aligned t)
	      (put-text-property (if (>= 2 (- (match-end 2) (match-beginning 2)))
				     (match-beginning 2)
				   ;; multiple whitespaces may mean that we are in process of typing
				   (1+ (match-beginning 2)))
				 (match-end 2)
				 'display
				 `(space . (:align-to (- right
							 (,(+ 10 ;; no idea, but otherwise it is sometimes not enough
							      (string-display-pixel-width org-ellipsis)
							      (string-display-pixel-width (or (match-string 3)
											      ""))))))))))))))

  )
#+end_src

**** Agenda
:PROPERTIES:
:ID:       1c3c3255-10b3-401c-99cf-3edd91427475
:END:

[2020-04-10 Fri] Strange bug causing infinite loop in org-agenda-dim-blocked-tasks when I clock in a dimmed task.
*************** SOMEDAY investigate this
*************** END
#+begin_src emacs-lisp
(use-package org-agenda
  :custom (org-agenda-dim-blocked-tasks nil))
#+end_src

#+begin_src emacs-lisp
(defadvice org-agenda (around split-vertically activate)
  (let ((split-width-threshold 1000))  ; or whatever width makes sense for you
    ad-do-it))
#+end_src
Do not highlight line below mouse
  #+begin_src emacs-lisp
(defun yant/remove-mouse-highlight ()
  "Remove all mouse highlights in buffer."
  (let ((inhibit-read-only t))
    (remove-text-properties
     (point-min) (point-max) '(mouse-face t))))
(add-hook 'org-agenda-finalize-hook
	  #'yant/remove-mouse-highlight)
  #+end_src
Highlight current line in agenda
  #+begin_src emacs-lisp
(use-package hl-line
  :if init-flag

  :diminish global-hl-line-mode
  :config
  (progn
    (add-hook 'org-agenda-mode-hook
	      '(lambda () (hl-line-mode 1))
	      'append)
    )
  )
  #+end_src

Modify prefix for the entries to show if the entry is repeatable and the time [[id:38d9103d-a969-4c69-ae0e-a9a50912fba0][time balance multiplier]].
  #+begin_src emacs-lisp
(setq org-agenda-scheduled-leaders '("* today" "* %2d d. ago"))
(defun yant/format-summary-for-agenda ()
  "Format the contents of :SUMMARY: property to show in agenda view."
  (let ((summary (org-entry-get (point) "SUMMARY")))
    (if (not (seq-empty-p summary))
	(format "[%s] " summary)
      "")))

(defun yant/format-hashtags-for-agenda ()
  "Format the list of hashtags to show in agenda view."
  (let* ((entry-text (org-with-point-at-org-buffer
		      (org-back-to-heading)
		      ;; Skip heading
		      (end-of-line 1)
		      ;; Get entry text
		      (buffer-substring
		       (point)
		       (or (save-excursion (outline-next-heading) (point))
			   (point-max)))))
         (entry-text (and entry-text (replace-regexp-in-string org-babel-src-block-regexp "" entry-text)))
         (entry-hashtags (and entry-text (mapcar #'car (s-match-strings-all " #[^+ ][^# ]+" entry-text)))))
    (if (seq-empty-p entry-hashtags)
	""
      (concat "\t\t" (mapconcat #'s-trim entry-hashtags " ") "\n"))))

(defun yant/format-time-balance-multiplier ()
  "Format :ORG-TIME-BALANCE-MULTIPLIER: into agenda."
  (condition-case nil
      (save-match-data
	(let* ((mult (org-get-time-balance-multiplier-at-point))
	       (bonus (org-get-org-time-bonus-on-done-at-point))
               (schedule-string (or (org-entry-get (point) "SCHEDULED") ""))
               (scheduled? (string-match org-repeat-re schedule-string))
               (repeat-string (and scheduled? (match-string 1 schedule-string)))
               (repeat-string (and scheduled? (replace-regexp-in-string "[+.]+" "" repeat-string))))
	  (format "%-11s" (format "%s%s%s" (if scheduled? (format "%s↰" repeat-string) " ") (if mult (format "%sx" mult) "")
				  (if (and bonus (> bonus 0)) (format "+%s" bonus) "")))))
    (error "")))
(setq org-agenda-prefix-format "%-12s %-12:c [%e] %?-12t%(yant/format-time-balance-multiplier) %(yant/format-summary-for-agenda)")
  #+end_src

Hide some uninteresting tags
#+begin_src emacs-lisp
(setq org-agenda-hide-tags-regexp (rx-to-string '(or "DEFAULT"
						     "SKIP"
                                                     "NOARCHIVE"
                                                     "INBOX"
                                                     "HOLD"
                                                     "WAITING"
                                                     "NODEADLINE"
                                                     "CANCELLED"
                                                     "NOCLOCK"
                                                     "COMMON"
                                                     "PhD")))
#+end_src

Shorten too long headlines in agenda. 
In order to make the remainder consistent, the multi-byte characters are considered to be [[39a84dde-88d1-46e8-86d0-28fb8f72f30c][double width]] and all headlines containing multi-byte characters are shortened to less chars accordingly.
*************** TODO the current implementation wrongly cuts links
*************** END

*************** TODO the idea about multi-byte is not good for Russian text having same width as English...
*************** END

In addition use =:align-to= ='display= spec to align tags to right border of the window.

*************** TODO maybe patch org-string-width 
*************** END

#+begin_src emacs-lisp
(defun string-display-width (string &optional mode)
  "Calculate diplayed column width of STRING.
Optional MODE specifies major mode used for display."
  (with-temp-buffer
    (with-silent-modifications
      (setf (buffer-string) string))
    (when (fboundp mode)
      (funcall mode)
      (font-lock-fontify-buffer))
    (current-column)))

(defun string-display-truncate (string num &optional mode hide-p ellipsis)
  "Trim displayed STRING to NUM columns.
Optional MODE specifies major mode used for display.
Non-nil HIDE-P means that the string should be trimmed by hiding the trailing part with text properties.
Optional ELLIPSIS string is shown in place of the hidden/deleted part of the string."
  (with-temp-buffer
    (with-silent-modifications
      (setf (buffer-string) string))
    (when (fboundp mode)
      (funcall mode)
      (font-lock-fontify-buffer))
    (when (> (current-column) num)
      (move-to-column num)
      (with-silent-modifications
	(if hide-p
	    (progn
	      (if (stringp ellipsis)
		  (put-text-property (point) (point-max) 'display ellipsis)
		(put-text-property (point) (point-max) 'invisible t))
              (put-text-property (point) (point-max) 'truncated t))
	  (kill-line)
          (when (stringp ellipsis) (insert ellipsis)))))
    (buffer-string)))

(defun string-display-pixel-width (string &optional mode)
  "Calculate pixel width of STRING.
Optional MODE specifies major mode used for display."
  (with-temp-buffer
    (with-silent-modifications
      (setf (buffer-string) string))
    (when (fboundp mode)
      (funcall mode)
      (font-lock-fontify-buffer))
    (if (get-buffer-window (current-buffer))
	(car (window-text-pixel-size nil (line-beginning-position) (point)))
      (set-window-buffer nil (current-buffer))
      (car (window-text-pixel-size nil (line-beginning-position) (point))))))

(defun org-agenda-fix-tag-alignment ()
  "Use 'display :align-to instead of spaces in agenda."
  (save-match-data
    (goto-char (point-min))
    (setq-local word-wrap nil) ; tags would be moved to next line if `word-wrap'` is non-nil and `truncate-lines' is nil
    (while (re-search-forward org-tag-group-re nil 'noerror)
      (put-text-property (match-beginning 0)
			 (match-beginning 1)
                         'display
                         `(space . (:align-to (- right
						 (,(string-display-pixel-width (match-string 1)))
                                                 1)))))))

(defun org-agenda-adaptive-fill-function ()
  "Fill to the beginning of headline in agenda."
  (save-excursion
    (when-let ((txt (get-text-property (line-beginning-position) 'txt)))
      (search-forward (substring txt 0 10))
      (goto-char (match-beginning 0))
      (when-let ((re (get-text-property (line-beginning-position) 'org-todo-regexp)))
	(re-search-forward re (line-end-position) 't)
        (re-search-forward org-priority-regexp (line-end-position) 't))
      (make-string (1+ (current-column)) ?\ ))))

(defun org-agenda-truncate-headings (&rest _)
  "Truncate agenda headings to fit the WINDOW width."
  (with-silent-modifications
    (when (and (eq major-mode 'org-agenda-mode)
	       (not org-agenda-columns-active))
      (save-excursion
	;; indent wrapped lines to the position below the begining of the heading string
	(setq-local adaptive-fill-function #'org-agenda-adaptive-fill-function)

	;; (setq-local truncate-lines nil)
	;; (adaptive-wrap-prefix-mode +1)

	;; cleanup earlier truncation
	(let ((pos (point-min))
	      next)
	  (while (and (setq pos (next-single-char-property-change pos 'truncated nil (point-max)))
		      (setq next (next-single-char-property-change pos 'truncated nil (point-max)))
		      (get-text-property pos 'truncated))
	    (remove-text-properties pos next '(truncated nil invisible nil display nil))))

	(let ((pos (point-min))
	      next)
	  (while (and (setq pos (next-single-char-property-change pos 'org-agenda-afterline nil (point-max)))
		      (setq next (next-single-char-property-change pos 'org-agenda-afterline nil (point-max)))
		      (get-text-property pos 'org-agenda-afterline))
	    (setf (buffer-substring pos next) "")))

	(goto-char (point-min))
	(let ((window-width (window-width))
	      (ellipsis "…")
	      (gap "  "))
	  (while (and (setf (point) (next-single-char-property-change (point) 'org-hd-marker nil (point-max)))
		      (< (point) (point-max)))
	    (let* ((tag-width (when (re-search-forward org-tag-group-re (point-at-eol) 'noerror)
				(string-display-width (match-string 1))))
		   (beg (point-at-bol))
		   (end (if tag-width (match-beginning 0) (point-at-eol)))
		   (tag-width (or tag-width 0)))
	      (setf (buffer-substring beg end)
		    (string-display-truncate (buffer-substring beg end)
					     (- window-width
						tag-width
						(string-display-width (s-concat ellipsis gap)))
					     nil 'hide ellipsis))
	      (goto-char (next-single-char-property-change (point-at-bol) 'truncated nil (point-at-eol)))
	      (let ((truncated-string (buffer-substring (point) (next-single-char-property-change (point) 'truncated nil (point-at-eol)))))
		(unless (seq-empty-p truncated-string)
		  (remove-text-properties 0 (length truncated-string) '(truncated nil invisible nil display nil) truncated-string)
		  (add-text-properties 0 (length truncated-string) '(org-agenda-afterline t) truncated-string)
		  (end-of-line)
		  (insert (apply #'propertize ellipsis
				 (text-properties-at 0 truncated-string)))
		  (insert truncated-string)))
              (end-of-line))))))))

(add-hook! 'org-agenda-finalize-hook #'org-agenda-fix-tag-alignment)
(add-hook! :append 'org-agenda-finalize-hook #'org-agenda-truncate-headings)
;; (add-hook! 'org-agenda-finalize-hook (add-hook! :local 'window-configuration-change-hook #'org-agenda-truncate-headings))
#+END_SRC

Fontify agenda items properly
#+BEGIN_SRC emacs-lisp  
;; (define-advice org-agenda-format-item (:filter-args (&rest args)  fontify-org)
;;   "Force fontify ageda item. (hack)"
;;   (cl-multiple-value-bind (extra txt level category tags dotime remove-re habitp) (car args)
;;     (with-temp-buffer
;;       (cl-letf (((symbol-function 'yant/process-att-abbrev) #'identity)
;; 		((symbol-function 'yant/process-att-id-abbrev) #'identity)) ;; expanding sometimes causes errors when attempting to access ancestors
;; 	(org-mode)
;;         (setq txt (replace-regexp-in-string "[ \t]*:[[:alnum:]_@#%:]+:[ 	]*$" "" txt))
;; 	(insert "* "
;; 		txt
;; 		"\t"
;; 		(or (and tags (s-join ":" `(nil ,@(cl-remove-duplicates tags) nil)))
;; 		    "")
;; 		"\n")
;; 	(font-lock-fontify-buffer)
;; 	(goto-char (point-min))
;; 	(looking-at "^\\* \\(\\([^\t]+\\)[ 	]+\\(:\\([[:alnum:]_@#%:]+\\):\\)*\\)[ 	]*$")
;; 	(setq txt (match-string 2))
;; 	(setq tags (and tags (s-split ":" (match-string 3) 't)))
;;         )
;;       (list extra txt level category tags dotime remove-re habitp)))
;;   )
(define-advice org-agenda-format-item (:filter-return (item) remove-double-colons)
  "Remove ::."
  (s-replace-regexp "::+" ":" item))

;; (advice-remove 'org-agenda-format-item #'org-agenda-format-item@fontify-org)
;; (advice-remove 'org-agenda-format-item #'org-agenda-format-item@remove-double-colons)

;; Credit: https://www.reddit.com/r/orgmode/comments/i3upt6/prettifysymbolsmode_not_working_with_orgagenda/g0r5rx8/
(define-advice org-agenda-fix-displayed-tags (:filter-return (&rest args)  my-fix-displayed-org-tags)
  (let ((txt (car args)))
    (with-temp-buffer
      (org-mode)
      (insert "* " txt)
      (font-lock-fontify-buffer)
      (goto-char (point-min))
      (looking-at "^\\* \\(.*\\)$")
      (match-string 1))))

(use-package org-agenda
  :if init-flag
  :config
  (el-patch-feature org-agenda)
  ;; calling `org-agenda-highlight-todo' breaks 'composition text property of todo keywords, which breaks pretty-symbols fontifications
  ;; fixing the function to keep 'composition
  (el-patch-defun org-agenda-highlight-todo (x)
    (let ((org-done-keywords org-done-keywords-for-agenda)
	  (case-fold-search nil)
	  re
          (el-patch-add composition-property))
      (if (eq x 'line)
	  (save-excursion
	    (beginning-of-line 1)
	    (setq re (org-get-at-bol 'org-todo-regexp))
	    (goto-char (or (text-property-any (point-at-bol) (point-at-eol) 'org-heading t) (point)))
	    (when (looking-at (concat "[ \t]*\\.*\\(" re "\\) +"))
	      (add-text-properties (match-beginning 0) (match-end 1)
				   (list 'face (org-get-todo-face 1)))
              (el-patch-add (setq composition-property (plist-get (text-properties-at (match-beginning 1)) 'composition)))
	      (let ((s (buffer-substring (match-beginning 1) (match-end 1))))
		(delete-region (match-beginning 1) (1- (match-end 0)))
		(goto-char (match-beginning 1))
		(insert (format org-agenda-todo-keyword-format s))
                (el-patch-add (add-text-properties (match-beginning 1) (match-end 1) (list 'composition composition-property))))))
	(let ((pl (text-property-any 0 (length x) 'org-heading t x)))
	  (setq re (get-text-property 0 'org-todo-regexp x))
	  (when (and re
		     ;; Test `pl' because if there's no heading content,
		     ;; there's no point matching to highlight.  Note
		     ;; that if we didn't test `pl' first, and there
		     ;; happened to be no keyword from `org-todo-regexp'
		     ;; on this heading line, then the `equal' comparison
		     ;; afterwards would spuriously succeed in the case
		     ;; where `pl' is nil -- causing an args-out-of-range
		     ;; error when we try to add text properties to text
		     ;; that isn't there.
		     pl
		     (equal (string-match (concat "\\(\\.*\\)" re "\\( +\\)")
					  x pl)
			    pl))
	    (add-text-properties
	     (or (match-end 1) (match-end 0)) (match-end 0)
	     (list 'face (org-get-todo-face (match-string 2 x)))
	     x)
	    (when (match-end 1)
	      (setq x
		    (concat
		     (substring x 0 (match-end 1))
		     (format org-agenda-todo-keyword-format
			     (match-string 2 x))
		     ;; Remove `display' property as the icon could leak
		     ;; on the white space.
		     (org-add-props " " (org-plist-delete (text-properties-at 0 x)
							  'display))
		     (substring x (match-end 3)))))))
	x)))
  )


#+end_src

#+begin_src emacs-lisp
(use-package org-agenda
  :if init-flag
  :custom-face
  (org-scheduled-today ((t  (:foreground "DarkSlateGray"))))
  (org-agenda-done ((t . (:foreground "Springgreen4" :slant normal)))))
#+end_src

***** Update highlight from currently clocked task in agenda even if the task was clocked in/out from outside
:PROPERTIES:
:CREATED:  [2020-04-06 Mon 17:41]
:ID:       ecd56b01-c56d-4c4a-bbbb-08d8bb4e152e
:END:

Agenda has a nice feature to highlight the currently clocked task, if it is present in agenda.
It is working by default when the clocking in/out is done from inside agenda (using =org-agenda-clock-in/out= commands).
However, the highlight is not updated if I clock in/out a task from outside the agenda buffer using more generic =org-clock-in/out= commands.
The code below does the trick.

#+begin_src emacs-lisp
(when init-flag
  (defun yant/org-agenda-unmark-clocking-task ()
    "Hide all org-quick-peek overlays in `org-agenda-buffer'."
    (dolist (agenda-buffer (mapcar #'get-buffer
				   (seq-filter (apply-partially  #'s-contains-p "*Org Agenda") 
					       (mapcar #'buffer-name (buffer-list)))))
      (when (buffer-live-p agenda-buffer)
	(with-current-buffer agenda-buffer (org-agenda-unmark-clocking-task)))))
  (defun yant/org-agenda-mark-clocking-task ()
    "Hide all org-quick-peek overlays in `org-agenda-buffer'."
    (dolist (agenda-buffer (mapcar #'get-buffer
				   (seq-filter (apply-partially  #'s-contains-p "*Org Agenda") 
					       (mapcar #'buffer-name (buffer-list)))))
      (when (buffer-live-p agenda-buffer)
	(with-current-buffer agenda-buffer (org-agenda-mark-clocking-task)))))

  (add-hook 'org-clock-out-hook #'yant/org-agenda-unmark-clocking-task)
  (add-hook 'org-clock-in-hook #'yant/org-agenda-mark-clocking-task))
#+end_src

***** Show todo state changes in overlay in agenda similarly to how rescheduling is shown
:PROPERTIES:
:CREATED:  [2020-04-11 Sat 19:28]
:ID:       c466add1-ea89-4473-a597-542be6e483fd
:END:

In the case if todo state is changed, indicate the change in agenda. 
Special treatment here is done for =DOING= todo keyword. 
Since DOING->DOING transition is actually [[id:d38441a2-1431-44db-b831-8cdec011b1dc][meaningful]], also indicate DOING->DOING transition.
#+begin_src emacs-lisp
(use-package org-agenda
  :config
  (el-patch-feature org-agenda)
  (el-patch-defun org-agenda-todo (&optional arg)
    "Cycle TODO state of line at point, also in Org file.
This changes the line at point, all other lines in the agenda referring to
the same tree node, and the headline of the tree node in the Org file."
    (interactive "P")
    (org-agenda-check-no-diary)
    (org-agenda-maybe-loop
     #'org-agenda-todo arg nil nil
     (let* ((col (current-column))
	    (marker (or (org-get-at-bol 'org-marker)
			(org-agenda-error)))
	    (buffer (marker-buffer marker))
	    (pos (marker-position marker))
	    (hdmarker (org-get-at-bol 'org-hd-marker))
	    (todayp (org-agenda-today-p (org-get-at-bol 'day)))
	    (inhibit-read-only t)
	    org-loop-over-headlines-in-active-region
	    org-agenda-headline-snapshot-before-repeat newhead just-one
            (el-patch-add todo-from todo-to))
       (el-patch-add
	 (save-excursion
	   (beginning-of-line 1)
	   (setq re (org-get-at-bol 'org-todo-regexp))
	   (goto-char (or (text-property-any (point-at-bol) (point-at-eol) 'org-heading t) (point)))
	   (when (looking-at (concat "[ \t]*\\.*\\(" re "\\) +"))
             (setq todo-from (match-string-no-properties 1)))))
       (org-with-remote-undo buffer
	 (with-current-buffer buffer
	   (widen)
	   (goto-char pos)
	   (org-fold-show-context 'agenda)
	   (let ((current-prefix-arg arg))
	     (call-interactively 'org-todo))
	   (and (bolp) (forward-char 1))
	   (setq newhead (org-get-heading))
	   (when (and (bound-and-true-p
		       org-agenda-headline-snapshot-before-repeat)
		      (not (equal org-agenda-headline-snapshot-before-repeat
				newhead))
		      todayp)
	     (setq newhead org-agenda-headline-snapshot-before-repeat
		   just-one t))
	   (save-excursion
	     (org-back-to-heading)
	     (move-marker org-last-heading-marker (point))))
	 (beginning-of-line 1)
	 (save-window-excursion
	   (org-agenda-change-all-lines newhead hdmarker 'fixface just-one))
         (el-patch-add
	   (save-excursion
	     (beginning-of-line 1)
	     (setq re (org-get-at-bol 'org-todo-regexp))
	     (goto-char (or (text-property-any (point-at-bol) (point-at-eol) 'org-heading t) (point)))
	     (when (looking-at (concat "[ \t]*\\.*\\(" re "\\) +"))
               (setq todo-to (match-string-no-properties 1)))))
         (el-patch-add
           (unless (and (not (string= "DOING" todo-from)) (string= todo-from todo-to))
	     (org-agenda-show-new-time (org-get-at-bol 'org-marker) todo-to (format " %s " todo-from))))
	 (when (bound-and-true-p org-clock-out-when-done)
      	   (string-match (concat "^" (regexp-opt org-done-keywords-for-agenda))
			 newhead)
	   (org-agenda-unmark-clocking-task))
	 (org-move-to-column col)
	 (org-agenda-mark-clocking-task))))))
#+end_src

***** Do not show tooltips in agenda
:PROPERTIES:
:CREATED:  [2020-04-16 Thu 21:14]
:ID:       00fad7c6-98c6-45f6-a8ac-719c80cf4ba1
:END:

Tooltips are useless since I don't use mouse in Emacs.
I already [[id:1edf3f36-6a30-4374-a47d-2d1b9c7a889a][force the mouse out]], but the tooltips can still show up annoyingly if the mouse is accidentally left within the Emacs frame.

#+begin_src emacs-lisp
(use-package org-agenda
  :init
  (defun yant/remove-help-echo-in-buffer ()
    "Remove helm-echo text property in the buffer text."
    (remove-text-properties (point-min) (point-max) '(help-echo t)))
  :config
  (add-hook 'org-agenda-finalize-hook #'yant/remove-help-echo-in-buffer))
#+end_src

Another source of tooltips in agenda is overlay marking currently clocked-in task. 
Patching the relevant function to not put that tooltip into the overlay.

#+begin_src emacs-lisp
(use-package org-agenda
  :config
  (el-patch-feature 'org-agenda)
  (el-patch-defun org-agenda-mark-clocking-task ()
    "Mark the current clock entry in the agenda if it is present."
    ;; We need to widen when `org-agenda-finalize' is called from
    ;; `org-agenda-change-all-lines' (e.g. in `org-agenda-clock-in').
    (when (bound-and-true-p org-clock-current-task)
      (save-restriction
	(widen)
	(org-agenda-unmark-clocking-task)
	(when (marker-buffer org-clock-hd-marker)
	  (save-excursion
	    (goto-char (point-min))
	    (let (s ov)
	      (while (setq s (next-single-property-change (point) 'org-hd-marker))
		(goto-char s)
		(when (equal (org-get-at-bol 'org-hd-marker)
			     org-clock-hd-marker)
		  (setq ov (make-overlay (point-at-bol) (1+ (point-at-eol))))
		  (overlay-put ov 'type 'org-agenda-clocking)
		  (overlay-put ov 'face 'org-agenda-clocking)
                  (el-patch-remove
		    (overlay-put ov 'help-echo
				 "The clock is running in this item")))))))))))
#+end_src

***** TODO this in not truncated properly in agenda [[id:b51c5a05-4a20-469a-b61d-fd71b1fcc32f][paper What governs ductility of ultrafine-grained metals? A microstructure based approach to necking instability]]
:PROPERTIES:
:CREATED: [2020-07-13 Mon 08:27]
:END:
:LOGBOOK:
- Refiled on [2020-07-13 Mon 08:35]
:END:

***** Main face

Use normal colour for the default agenda face
#+begin_src emacs-lisp
(set-face-attribute 'org-agenda-structure nil
		    :foreground (face-foreground 'default))
#+end_src
**** Blocks (source blocks, quotes, etc)
:PROPERTIES:
:ID:       6fed68f0-c4ca-43f3-b487-4b58d9dc1315
:END:
#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively nil ;; see https://lists.gnu.org/archive/html/emacs-orgmode/2019-12/msg00318.html
      org-src-preserve-indentation t
      org-hide-block-startup nil)
#+end_src

Hide all blocks on startup [[[https://github.com/weirdNox/dotfiles/blob/master/config/.emacs.d/config.org#appearance][credit]]]

#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'org-fold-hide-block-all)
#+end_src

**** Property drawers
:PROPERTIES:
:CREATED:  [2020-05-13 Wed 23:51]
:ID:       8f502b25-1797-4c2d-b12e-32b1f6c6a236
:END:

Smaller font for property drawers
#+begin_src emacs-lisp
(use-package org
  :custom-face
  (org-drawer ((t (:foreground "Blue1" :height 0.8)))))
#+end_src

Hide property drawers if they are empty or contain only invisible =org-custom-properties=.
Also hide the logbooks containing only state changes and clocking.

*************** TODO Find a faster way to hide empty drawers - maybe use font lock
*************** END

#+begin_src emacs-lisp :tangle no
(use-package org
  :if init-flag
  :config
  (setq org-custom-properties '("ID" "STYLE" "REPEAT_TO_STATE" "CREATED"))
  (defvar-local org--hide-custom-properties nil
    "When non-nil, hide properties listed in `org-custom-properties'.
If a property drawer conatins only these properties, hide the drawer as well.")
  (defvar org--custom-properties-re (concat "^[ \t]*:" (regexp-opt org-custom-properties) ":.*")
    "Regexp to match property lines from `org-custom-properties'.")

  ;; (defvar org-custom-logs '(state reschedule delschedule redeadline deldeadline refile)
  ;; "List of note types to be hidden normally. The types shouls be from `org-log-note-headings'.")
  ;; (defvar org-custom-drawers (list #'org-log-into-drawer "PROPERTIES")
  ;;   "List of drawer names allowed to be hidden if all the information inside is invisible.")
  ;; (defvar org-custom-clocking-info t
  ;;   "Non nil means that clocking info is hidden by `org-toggle-custom-properties-visibility'.")

  (defun org-toggle-custom-properties-visibility (&optional arg)
    "Toggle visibility of properties listen in `org-custom-properties'.
If a property drawer conatins only these properties, hide the drawer as well."
    (interactive "p")
    (if (or org--hide-custom-properties
	    (< arg 0))
        (progn
          (setq org--hide-custom-properties nil)
	  (remove-hook 'org-font-lock-hook #'org--hide-custom-properties)
          (advice-remove 'org-cycle #'org--hide-custom-properties))
      (setq org--hide-custom-properties t)
      (setq org--custom-properties-re (concat "^[ \t]*:" (regexp-opt org-custom-properties) ":.*"))
      (advice-add 'org-cycle :after #'org--hide-custom-properties)
      (add-hook 'org-font-lock-hook #'org--hide-custom-properties))
    (font-lock-fontify-buffer))

  (defun org--hide-custom-properties (&optional limit)
    "Hide the properties according to `org--hide-custom-properties'."
    (unless (numberp limit) (setq limit (point-max)))
    (when org--hide-custom-properties
      (with-silent-modifications
	(let ((re-drawer (concat "^[ \t]*:PROPERTIES:[ \t]*\n"
				 "\\(" org--custom-properties-re "\n\\)+"
				 "[ \t]*:END:[ \t]*\n"))
              (re-single (concat org--custom-properties-re "\n")))
	  (save-excursion
	    (while (re-search-forward re-drawer limit t)
              (put-text-property (match-beginning 0) (match-end 0) 'invisible t)))
          (save-excursion
	    (while (re-search-forward re-single limit t)
              (put-text-property (match-beginning 0) (match-end 0) 'invisible t)))))))

  )
#+end_src

**** Symbols
:PROPERTIES:
:ID:       aae027ae-a2b7-42b6-a833-cf038edcad3a
:END:

Use UTF symbols for entities

#+begin_src emacs-lisp
(setq org-pretty-entities t)
(setq org-pretty-entities-include-sub-superscripts t)
#+end_src

*Only* use curly brackets to identify sub/superscripts (from [[https://github.com/grettke/help/blob/master/help.org][here]])

#+begin_src emacs-lisp
(setq org-use-sub-superscripts '{})
#+end_src

**** =Eldoc= integration
:PROPERTIES:
:CREATED:  [2018-10-24 Wed 20:31]
:ID:       d858e349-99e4-4117-83c6-78b75acf6160
:END:

#+begin_src emacs-lisp
(use-package org-eldoc
  :after org
  :demand t)
#+end_src

**** TODO Optimize fontification of priorities
:PROPERTIES:
:CREATED:  [2020-07-28 Tue 07:30]
:END:

To my horror, a single =org-font-lock-add-priority-faces= takes 98% of the whole font-locking makeing the opening take of huge (2M, thousands of headlines) org file several minutes.
[2020-07-28 Tue] Apparently the reason is because default regex can match too many things in my files. For now, just removed those long lines causing regexp search to be extremely slow.

*** Misc
:PROPERTIES:
:ID:       b195d9ea-e3e0-476e-b898-43b69fbd365d
:END:
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'show-and-error)
(setq org-M-RET-may-split-line '((default . nil)))
(setq org-startup-folded nil)
(setq org-fold-show-context-detail
      '((agenda . lineage) ;; instead of "local"
	(bookmark-jump . lineage)
	(isearch . lineage)
	))
#+end_src
**** Org element cache
:PROPERTIES:
:CREATED:  [2018-11-18 Sun 13:04]
:ID:       7c1c828b-3a77-4e79-b07a-4ad173a5f87a
:END:

I was irritated by org-mode behaviour when =flycheck= is turned on. org-mode introduces additional =flycheck= hook, which is ran after movement/editing commands. This hook calls =org-element-at-point=, which is terrible on large files.
Turning on org element cache in attempt to make it faster.

[2019-08-27 Tue] Disabling cache for now due to strange errors
[2020-05-25 Mon] Trying again
[2020-07-15 Wed] Again getting strange errors. Probably related to native-comp
[2020-08-02 Sun] Retrying again
[2020-08-27 Thu] Disabling because of strange hangs

#+begin_src emacs-lisp
(custom-set-variables '(org-element-use-cache nil))
#+end_src

*************** TODO check if it is good enough
*************** END

**** =M-RET= should not split lines inside folded entry
:PROPERTIES:
:CREATED:  [2019-08-11 Sun 16:50]
:ID:       e87616b0-d0f7-47e0-a64a-c1b6c7798539
:END:

From https://www.reddit.com/r/orgmode/comments/8vor99/how_can_i_insert_a_new_bullet_after_a_folded_item/e1pbs57/

#+begin_src emacs-lisp
(setq org-M-RET-may-split-line '((default . nil)))
#+end_src

**** Org mode editing
:PROPERTIES:
:CREATED:  [2018-10-23 Tue 18:45]
:ID:       184b97b2-df73-4961-9f8f-ad8a6b4e1db8
:END:
:LOGBOOK:
- Refiled on [2020-04-14 Tue 15:51]
:END:

#+begin_src emacs-lisp
(use-package org
  :config
  (use-package meta-functions
    :config
    (meta-defun meta-cut-element :mode org-mode :cond org-at-heading-p org-cut-subtree)))
#+end_src

*** Notmuch interaction
:PROPERTIES:
:ID:       e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326
:END:
:LOGBOOK:
CLOCK: [2018-09-06 Thu 21:10]--[2018-09-06 Thu 22:51] =>  1:41
:END:

#+begin_src emacs-lisp
(use-package ol-notmuch)
(use-package helm-notmuch
  :straight t
  :config
  (let ((helm-source-notmuch-action (alist-get 'action helm-source-notmuch)))
    (setf (alist-get 'action helm-source-notmuch)
	  (append helm-source-notmuch-action (list '("Copy message link" . org-store-notmuch-link))))))

(defun org-store-notmuch-link (CANDIDATE)
  "Store CANDIDATE org link to notmuch message."
  (let ((link (format "notmuch:%s" CANDIDATE)))
    (interactive)
    (org-open-link-from-string link)
    (set-buffer (first (buffer-list)))
    (let ((desc (replace-regexp-in-string "\\[\\|\\]" "" (notmuch-show-get-subject))))
      (notmuch-bury-or-kill-this-buffer)
      (push (list (format "notmuch:%s" CANDIDATE) desc) org-stored-links))))


(defun yant/add-email-to-task (&optional ARG)
  "Add an email into :EMAIL-SOURCE: property of the task.
       C-u argument means that we add the last link from link ring."
  (interactive)
  (if (eq ARG '4)
      (let ((last-link (car (car org-stored-links)))
	    (last-description (cadr (car org-stored-links))))
	(if (string-match "^notmuch.*$" last-link)
            (progn
	      (org-set-property "EMAIL-SOURCE" (concat "[[" last-link "][" last-description "]]"))
              (org-back-to-heading)
              (org-set-tags-to (append (org-get-tags nil t) '("EMAIL"))))
	  (message "Link \"%s\" is not a message link." last-link))
        (yant/mark-linked-email-after-todo-state-change))
    (let ((helm-source-tmp (copy-alist helm-source-notmuch)))
      (setf (alist-get 'action helm-source-tmp) (list '("Copy message link" . org-store-notmuch-link)))
      (setf (alist-get 'header-line helm-source-tmp) "C-j: Associate the task with an email")
      (helm :sources helm-source-tmp
	    :buffer "*helm notmuch*"
	    :truncate-lines t))
    (yant/add-email-to-task '4)))

(defun yant/mark-linked-email-after-todo-state-change ()
  "Remove inbox tag from a linked email :EMAIL-SOURCE: after the task is marked as finished."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components))))
	(email-link (org-entry-get nil "EMAIL-SOURCE"))
	(done-keywords org-done-keywords))
    (when (not (or (not email-link)
		 (eq email-link "")))
      (save-current-buffer
	(interactive)
	(org-open-link-from-string email-link)
	(with-current-buffer (first (buffer-list))
	  (if (member mystate done-keywords)
	      (notmuch-show-tag-message "-inbox" "-todo" "-listinbox")
	    (if mystate
		(notmuch-show-tag-message "-listinbox" "+inbox" "-todo")
	      (if (member "inbox" (notmuch-show-get-tags))
		  (notmuch-show-tag-message "-listinbox" "+inbox" "+todo"))))
	  (notmuch-bury-or-kill-this-buffer))))))

(add-hook 'org-after-todo-state-change-hook 'yant/mark-linked-email-after-todo-state-change 'append)
(add-hook 'org-capture-before-finalize-hook 'yant/mark-linked-email-after-todo-state-change 'append)
#+end_src
*** Imenu integration
:PROPERTIES:
:CREATED:  [2018-10-25 Thu 22:50]
:ID:       72afd20b-f9c7-4c5b-84cf-a4073c62af76
:END:
=Imenu= appears to be slower in =org-mode= in comparison with =org-goto=
#+begin_src emacs-lisp
(setq org-imenu-depth 8)
(use-package meta-functions
  :if init-flag
  :config
  (setq org-goto-max-level 8)
  (setq org-goto-interface 'outline-path-completion)
  (meta-defun meta-goto :mode org-mode org-goto))
#+end_src

*** Spell checking
:PROPERTIES:
:CREATED:  [2019-09-17 Tue 00:16]
:ID:       0ff33f97-adf2-4195-adba-0b92040950e5
:END:

Spell check rules for org syntax.


Partially stolen from https://github.com/grettke/help/blob/master/help.org:

#+begin_src emacs-lisp
(defun help/block-regex (special)
  "Make an ispell skip-region alist for a SPECIAL block."
  (interactive)
  `(,(concat "^[ ]*#[+][bB][eE][gG][iI][nN]_" special)
    .
    ,(concat "^[ ]*#[+][eE][nN][dD]_" special)))

;; from https://github.com/wdenton/.emacs.d/blob/master/setup/setup-orgmode.el
;; Use LaTeX spell-check
(add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))

;; Ispell should ignore some things in Org files
;; http://endlessparentheses.com/ispell-and-org-mode.html
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '(org-any-link-re))
  (add-to-list 'ispell-skip-region-alist '("<<[A-Za-z-0-9]+>>"))
  (add-to-list 'ispell-skip-region-alist '("=[^=]+="))
  (add-to-list 'ispell-skip-region-alist '("^# +-\\*-*+$"))
  (add-to-list 'ispell-skip-region-alist (help/block-regex "[Ss][rR][cC]"))
  (let ()
    (--each
	'(("ATTR_LATEX" nil)
          ("AUTHOR" nil)
          ("SETUPFILE" t)
          ("BLOG" nil)
          ("CREATOR" nil)
          ("DATE" nil)
          ("DESCRIPTION" nil)
          ("EMAIL" nil)
          ("EXCLUDE_TAGS" nil)
          ("HTML_CONTAINER" nil)
          ("HTML_DOCTYPE" nil)
          ("HTML_HEAD" nil)
          ("HTML_HEAD_EXTRA" nil)
          ("HTML_LINK_HOME" nil)
          ("HTML_LINK_UP" nil)
          ("HTML_MATHJAX" nil)
          ("INFOJS_OPT" nil)
          ("KEYWORDS" nil)
          ("LANGUAGE" nil)
          ("LATEX_CLASS" nil)
          ("LATEX_CLASS_OPTIONS" nil)
          ("LATEX_HEADER" nil)
          ("LATEX_HEADER_EXTRA" nil)
          ("NAME" t)
          ("name" t)
          ("OPTIONS" t)
          ("PROPERTY" t)
          ("POSTID" nil)
          ("RESULTS" t)
          ("SELECT_TAGS" nil)
          ("STARTUP" nil)
          ("TITLE" nil))
      (add-to-list
       'ispell-skip-region-alist
       (let ((special (concat "#[+]" (car it) ":")))
	 (if (cadr it)
             (cons special "$")
           (list special)))))))

(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC

*** TODO Key combinations
:PROPERTIES:
:ID:       fe1a02aa-90fb-4ddb-9d04-925b08697e58
:EMAIL-SOURCE: [[notmuch:id:0100015f833663f9-95881448-4653-4709-a5bb-bfa94f3f0bff-000000@email.amazonses.com][Email from Amazon com: Leave Packaging Feedback for y]]
:END:
#+begin_src emacs-lisp
(when init-flag
  (use-package meta-functions
    :config
    (meta-defun meta-org-clock-goto "Goto clocked in entry" org-clock-goto)
    (meta-defun meta-org-clock-goto :mode org-agenda-mode org-agenda-clock-goto)
    (bind-key "C-c c" #'meta-org-clock-goto))
  (bind-keys
   ("C-c C-S-l" . org-store-link)
   ("C-c m" . org-capture)
   :map boon-goto-map
   ("a" . org-agenda)
   ("C-t" . gtd-open)
   ("C-n" . notes-open)
   )
  (bind-keys :map org-mode-map
	     ("C-c C-l" . org-insert-link)
	     ("C-c C-+" . add-current-buffer-to-agenda-files)
	     ("C-c C--" . remove-current-buffer-from-agenda-files)
	     ("C-c e" . yant/add-email-to-task)
	     ("C-c i" . org-clock-in)
	     ("C-c o" . org-clock-out)
             :map org-agenda-mode-map
             ("C-c C-," . org-agenda-priority)
             ("s" . org-agenda-bulk-mark)
             ("S" . org-agenda-bulk-mark-all)
	     ("a" . org-agenda-bulk-unmark)
	     ("A" . org-agenda-bulk-unmark-all)
             ("i" . org-agenda-clock-in)
             ("-" . meta-undo)
             :map narrow-map
             ("s" . org-narrow-to-subtree)
             )

  (use-package meta-functions
    :config
    (meta-defun meta-move-line-up :mode org-mode org-metaup)
    (meta-defun meta-move-line-down :mode org-mode org-metadown)
    (meta-defun meta-move-element-up :mode org-mode org-shiftmetaup)
    (meta-defun meta-move-element-down :mode org-mode org-shiftmetadown)
    (meta-defun meta-move-element-left :mode org-mode org-shiftmetaleft)
    (meta-defun meta-move-element-right :mode org-mode org-shiftmetaright)
    (meta-defun meta-move-line-left :mode org-mode org-metaleft)
    (meta-defun meta-move-line-right :mode org-mode org-metaright)
    (meta-defun meta-insert-enclosure-new-line :mode org-mode org-insert-heading-respect-content)
    (meta-defun meta-insert-active-enclosure-new-line :mode org-mode org-insert-todo-heading-respect-content)
    (meta-defun meta-new-line :mode org-mode (org-return))
    (defun yant/org-smart-meta-down-element ()
      "Move down org item if at heading, move down paragraph otherwise."
      (interactive)
      (if (org-at-heading-p)
	  (call-interactively #'org-next-visible-heading)
	(forward-paragraph)))
    (defun yant/org-smart-meta-up-element ()
      "Move up org item if at heading, move up paragraph otherwise."
      (interactive)
      (if (org-at-heading-p)
	  (call-interactively #'org-previous-visible-heading)
	(backward-paragraph)))

    (meta-defun meta-down-element
      :mode org-mode
      :cond org-at-heading-p
      :cond (not (buffer-narrowed-p))
      (outline-get-next-sibling))

    (meta-defun meta-down-element
      :mode org-mode
      :cond org-at-heading-p
      :cond buffer-narrowed-p
      (let ((curpos (point)))
	(unless (outline-get-next-sibling)
          (goto-char curpos)
	  (widen)
	  (outline-get-next-sibling)
	  (org-narrow-to-subtree)
          (org-show-entry))))
    
    (meta-defun meta-down-element
      :mode org-mode
      :cond (let ((element (org-element-at-point))) (and (eq (org-element-type element) 'src-block) (eq (1+ (point)) (org-element-property :end element))))
      (progn
	(goto-char (org-element-property :begin (org-element-at-point)))
	(next-line)
	;; (org-hide-block-toggle 'hide)
	(org-babel-next-src-block 1)
        (org-fold-hide-block-toggle 'off))
      :mode org-mode
      :cond (eq (org-element-type (org-element-at-point)) 'src-block)
      (goto-char (1- (org-element-property :end (org-element-at-point)))))
    
    (meta-defun meta-up-element
      :mode org-mode
      :cond org-at-heading-p
      :cond (not (buffer-narrowed-p))
      (outline-get-last-sibling))
    (meta-defun meta-up-element
      :mode org-mode
      :cond org-at-heading-p
      :cond buffer-narrowed-p
      (let ((curpos (point)))
	(unless (outline-get-last-sibling)
          (goto-char curpos)
	  (widen)
	  (outline-get-last-sibling)
	  (org-narrow-to-subtree)
	  (org-show-entry))))

    (meta-defun meta-up-element
      :mode org-mode
      :cond (let ((element (org-element-at-point))) (and (eq (org-element-type element) 'src-block) (eq (point) (org-element-property :begin element))))
      (progn
	;; (org-hide-block-toggle 'hide)
	(org-babel-previous-src-block 1)
	(org-fold-hide-block-toggle 'off))
      :mode org-mode
      :cond (eq (org-element-type (org-element-at-point)) 'src-block)
      (goto-char (org-element-property :begin (org-element-at-point))))

    (meta-defun meta-move-line-up :mode org-struct-mode org-metaup)
    (meta-defun meta-move-line-down :mode org-struct-mode org-metadown)
    (meta-defun meta-move-line-up :mode org-agenda-mode org-agenda-drag-line-backward)
    (meta-defun meta-move-line-down :mode org-agenda-mode org-agenda-drag-line-forward)
    (meta-defun meta-move-element-up :mode org-struct-mode org-shiftmetaup)
    (meta-defun meta-move-element-down :mode org-struct-mode org-shiftmetadown)
    (meta-defun meta-move-element-left :mode org-struct-mode org-shiftmetaleft)
    (meta-defun meta-move-element-right :mode org-struct-mode org-shiftmetaright)
    (meta-defun meta-move-line-left :mode org-struct-mode org-metaleft)
    (meta-defun meta-move-line-right :mode org-struct-mode org-metaright)
    (meta-defun meta-insert-enclosure-new-line :mode org-struct-mode org-insert-heading-respect-content)
    (meta-defun meta-insert-active-enclosure-new-line :mode org-struct-mode org-insert-todo-heading-respect-content)
    (meta-defun meta-new-line :mode org-struct-mode org-return)
    (meta-defun meta-undo :mode org-agenda-mode org-agenda-undo)
    ;; (meta-defun meta-up :mode org-agenda-mode org-agenda-previous-item)
    ;; (meta-defun meta-down :mode org-agenda-mode org-agenda-next-item)
    (meta-defun meta-up :mode org-agenda-mode org-agenda-previous-line)
    (meta-defun meta-down :mode org-agenda-mode org-agenda-next-line)
    ))
#+end_src

**** Boon integration
:PROPERTIES:
:ID:       3bc88ae9-2346-4d9a-b50f-5e9970aa173a
:END:
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'boon-insert 'append)
#+end_src
** Sensitive info                                                                                :NOEXPORT:
:PROPERTIES:
:ID:       83801f6a-daf5-4738-a15e-2d20c2b4551c
:END:
#+begin_src emacs-lisp
(org-babel-load-file "~/PersonalDocuments/emacs-personal.org")
#+end_src
** Magic - I have no clue why it works
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:50]
:END:
*** Strange error with =w3m-idle-timer=
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:51]
:ID:       7ce2e20a-7f38-4cb2-9241-6bd1b7e10d39
:END:
#+BEGIN_SRC emacs-lisp
(setq w3m-image-no-idle-timer t)
#+END_SRC
*** Make =dired-hide-dotfiles= work
:PROPERTIES:
:CREATED:  [2019-08-02 Fri 16:09]
:ID:       7165a65e-b501-48c7-a227-138e035f0418
:END:

#+begin_src emacs-lisp
;; (use-package dired-hide-dotfiles
;; :config
;; (defun dired-hide-dotfiles--hide ()
;;   "Hide all dot-files in the current `dired' buffer."
;;   (when dired-hide-dotfiles-mode
;;     (dired-mark-files-regexp "^\\." nil 'localname)
;;     (dired-do-kill-lines))))
#+end_src
*** SOMEDAY COMMENT Fix =eldoc= raising error on org src blocks                                                                                           :SOMEDAY:
:PROPERTIES:
:ID:       d2bebb9f-8613-4e37-968b-4e0908b77a0b
:END:

#+begin_src emacs-lisp
(defun org-eldoc-documentation-function () "")
#+end_src
** Summary of key bindings
*** COMMENT Command frequency measurement in emacs
:PROPERTIES:
:ID:       cd5dd0a5-e810-4846-91a3-ba5b6c649cdc
:END:
#+begin_src emacs-lisp
(use-package keyfreq
  :straight t
  :config
  (define-globalized-minor-mode global-keyfreq-mode keyfreq-mode
    (lambda nil (progn (keyfreq-mode 1) (keyfreq-autosave-mode 1))))
  (global-keyfreq-mode))
#+end_src

* COMMENT Software
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 14:44]
:END:
** mpv
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 02:51]
:ID:       2c9568b7-4081-470c-b066-2beb126dbbed
:header-args+: :tangle no
:END:

*** Main config
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:08]
:header-args+: :tangle ~/.config/mpv/mpv.conf
:END:

**** General
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:10]
:ID:       830c8bf2-3bd8-4002-a367-f4a075bc1826
:END:

#+begin_src conf
keepaspect-window=no
save-position-on-quit
loop-playlist=yes
geometry=800x600+250+90
msg-module                              # prepend module name to log messages
msg-color                               # color log messages on terminal
term-osd-bar                            # display a progress bar on the terminal
use-filedir-conf                        # look for additional config files in the directory of the opened file
pause                                   # no autoplay
keep-open                               # keep the player open when a file's end is reached
cursor-autohide-fs-only                 # don't autohide the cursor in window mode, only fullscreen
cursor-autohide=1000                    # autohide the curser after 1s

screenshot-format=png
screenshot-png-compression=8
screenshot-template='~/Desktop/%F (%P) %n'

hls-bitrate=max                         # use max quality for HLS streams
#+end_src

**** Cache
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:10]
:ID:       87f0b98a-389f-466a-a4d6-7e9fe7719bc1
:END:

#+begin_src conf
cache=yes
cache-default=3000000                   # size in KB
cache-backbuffer=25000                  # size in KB
cache-initial=0                         # start playback when your cache is filled up with x kB
cache-secs=10                           # how many seconds of audio/video to prefetch if the cache is active
cache-file=TMP
cache-file-size=2000000
#+end_src

**** OSD / OSC
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:10]
:ID:       206c6f9a-e7f8-4ffa-aa26-757ef196df2f
:END:

Use custom osc ([[id:806164fd-46b1-405c-a1a8-140603466651][mpv/Userscripts/OSC menu/Preview screenshot on mouse hover]])

#+begin_src conf
osc=no

osd-level=1                             # enable osd and display --osd-status-msg on interaction
osd-duration=2500                       # hide the osd after x ms
osd-status-msg='${time-pos} / ${duration}${?percent-pos:　(${percent-pos}%)}${?vo-drop-frame-count:${!vo-drop-frame-count==0:　Dropped: ${vo-drop-frame-count}}}\n${?hapter:Chapter: ${chapter}}'

osd-font-size=32
osd-color='#CCFFFFFF'                   # ARGB format
osd-border-color='#DD322640'            # ARGB format
osd-shadow-offset=1                    # pixel width for osd text and progress bar
osd-bar-align-y=0                       # progress bar y alignment (-1 top, 0 centered, 1 bottom)
osd-border-size=2                       # size for osd text and progress bar
osd-bar-h=2                             # height of osd bar as a fractional percentage of your screen height
osd-bar-w=60                            # width of " " "
#+end_src

**** Subtitles
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:11]
:ID:       c082d9b8-5f57-493c-8976-45ad93e86dc7
:END:

#+begin_src conf
sub-use-margins
#demuxer-mkv-subtitle-preroll            # try to correctly show embedded subs when seeking
sub-auto=fuzzy                          # external subs don't have to match the file name exactly to autoload
sub-file-paths=ass:srt:sub:subs:subtitles    # search for external subs in the listed subdirectories
embeddedfonts=yes                       # use embedded fonts for SSA/ASS subs
sub-fix-timing=no                       # do not try to fix gaps (which might make it worse in some cases)

# the following options only apply to subtitles without own styling (i.e. not ASS but e.g. SRT)
sub-font="Helvetica"
sub-font-size=36
sub-color="#FFFFFFFF"
sub-border-color="#FF262626"
sub-border-size=3.2
sub-shadow-offset=1
sub-shadow-color="#33000000"
sub-spacing=0.5
#+end_src

**** Languages
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:11]
:ID:       bf046814-3fbe-4331-a186-58881064fff2
:END:

#+begin_src conf
slang=enm,en,eng,de,deu,ger             # automatically select these subtitles (decreasing priority)
alang=ja,jp,jpn,en,eng,de,deu,ger       # automatically select these audio tracks (decreasing priority)
#+end_src

**** Audio
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:11]
:ID:       7fc2f67a-16cf-411a-8804-bd11f354309c
:END:

#+begin_src conf
af=scaletempo=speed=tempo:stride=30
audio-file-auto=fuzzy                   # external audio doesn't has to match the file name exactly to autoload
#+end_src

**** Video
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:11]
:ID:       bbd87fcb-26ea-4b35-b85e-f00a0ad0574e
:END:

#+begin_src conf
# Active VOs (and some other options) are set conditionally
# See here for more information: https://github.com/wm4/mpv-scripts/blob/master/auto-profiles.lua
# The script was slightly modified, functions from scripts/auto-profiles-functions.lua are imported

# Defaults for all profiles
vo=opengl
#+end_src

**** Protocols
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:11]
:ID:       5752739c-70b7-4bf3-9cc6-49610cd47d05
:END:

#+begin_src conf
[protocol.https]
#cache=yes
#cache-default=500000                    # size in KB
#cache-backbuffer=250000                 # size in KB
cache-secs=100                          # how many seconds of audio/video to prefetch
user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

[protocol.http]
#cache=yes
#cache-default=500000                    # size in KB
#cache-backbuffer=250000                 # size in KB
cache-secs=100                          # how many seconds of audio/video to prefetch
user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

[extension.gif]
cache=no
no-pause
loop-file=yes

[extension.webm]
#cache=no
#no-pause
#loop-file=yes

ytdl-raw-options=format="[protocol!=http_dash_segments][protocol!=rtmp]",all-subs=,mark-watched=,no-check-certificate=
ytdl-format=bestvideo[height<=?1080]+bestaudio/best
#+end_src

*** User-scripts
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 02:51]
:ID:       898b5aa0-6f6e-4280-bd44-cc424436a81d
:END:
**** YouTube
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 02:51]
:ID:       81208c2c-19ef-432e-88d4-4ab7bcc3d762
:END:
***** Change quality                                                                                 :ATTACH:
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 02:52]
:ID:       f8737f19-a0ac-4785-a62c-2504313910ec
:END:

=C-f= to call menu.

#+name: quality-url
https://github.com/jgreco/mpv-youtube-quality

#+begin_src bash :var url=quality-url
git clone $url
cp ./mpv-youtube-quality/youtube-quality.lua ~/.config/mpv/scripts/
cp ./mpv-youtube-quality/youtube-quality.conf ~/.config/mpv/lua-settings/
#+end_src

#+RESULTS[33e778796fc04ae9b0a18b218e68bf5c5d3a404d]:
**** OSC menu
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 02:59]
:ID:       533e007d-615a-4f31-aa62-8eb0f732853d
:END:
***** Preview screenshot on mouse hover                                                              :ATTACH:
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:00]
:ID:       806164fd-46b1-405c-a1a8-140603466651
:END:

=T= to start generation

#+name: osc-url
https://github.com/TheAMM/mpv_thumbnail_script
#+begin_src bash :var url=osc-url
git clone $url
cd mpv_thumbnail_script
make
cp mpv_thumbnail_script_server.lua ~/.config/mpv/scripts/
cp mpv_thumbnail_script_client_osc.lua ~/.config/mpv/scripts/
#+end_src
**** Save position
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:27]
:ID:       c88c2dbf-ba9e-4cfa-90fc-e7609173b416
:END:
***** Save position periodically (not just on exit)
:PROPERTIES:
:CREATED:  [2019-12-15 Sun 03:27]
:ID:       dcd30527-329d-43bc-91fb-fda33b617e80
:END:

#+NAME: url-save
https://gist.github.com/Hakkin/5489e511bd6c8068a0fc09304c9c5a82

#+begin_src bash :var url=url-save
git clone $url
cd 5489e511bd6c8068a0fc09304c9c5a82
cp autosave.lua ~/.config/mpv/scripts/
#+end_src

#+RESULTS[29c899f8bda8bf343ecb2be121a022246bfecb15]:


