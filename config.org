#+SETUPFILE: ~/Org/common.setup
#+AUTHOR: Ihor Radchenko
#+EMAIL: yantar92@gmail.com
#+PROPERTY: header-args+ :tangle yes :comments link

* NEXT Emacs configuration                                     :EMACS:COMMON:
:PROPERTIES:
:ID:       a27092a6-25a6-417f-818f-7f83325b58b3
:ORG-TIME-BALANCE-MULTIPLIER: -0.5
:END:
:LOGBOOK:
CLOCK: [2018-07-23 Mon 00:16]--[2018-07-23 Mon 00:23] =>  0:07
- State "NEXT"       from "NEXT"       [2018-07-11 Wed 18:17]
- State "NEXT"       from "NEXT"       [2018-07-09 Mon 21:47]
- State "NEXT"       from "NEXT"       [2018-01-01 Mon 13:17]
CLOCK: [2017-12-30 Sat 22:19]--[2017-12-30 Sat 22:24] =>  0:05
CLOCK: [2017-12-30 Sat 17:03]--[2017-12-30 Sat 17:14] =>  0:11
- State "NEXT"       from "NEXT"          [2017-12-29 Fri 23:14]
CLOCK: [2017-12-28 Thu 18:41]--[2017-12-28 Thu 18:42] =>  0:01
CLOCK: [2017-12-28 Thu 17:59]--[2017-12-28 Thu 18:40] =>  0:41
:END:
#+begin_src emacs-lisp
(setf user-full-name "Ihor Radchenko")
#+end_src
This Emacs configuration allows to load Emacs in both interactive and batch modes. It is controlled by special variables, identifying startup mode:
- =init-flag= :: normal startup, load all the visual packages and options
- =org-export-flag= :: load necessary options for org-export
     One important note about this configuration is that I do not use desktop save mode and similar things. I do it because everything I intend to do is kept in my org files, which are automatically loaded by org agenda command. 
     #+begin_src emacs-lisp
(defvar init-flag nil
  "Do normal init if not nil.")
(defvar org-export-flag nil
  "Set up org export in if not nil.")
     #+end_src
** =Init.el=
:PROPERTIES:
:ID:       0948a927-42a3-4284-aaed-1ca9dd27a538
:CREATED:  [2017-12-23 Sat 15:16]
:END:
Init file, which is loads this file.
#+begin_src emacs-lisp :tangle "init.el"
;;(package-initialize)
(setq init-flag t)
(load "~/.emacs.d/config.el" nil nil nil t)
#+end_src
** Emacs server settings
:PROPERTIES:
:ID:       5d8e1dca-a849-4980-bfde-cbf02801e92b
:END:
- ensure one server instance 
  #+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
  #+end_src
- run server silently
  - ignore file clashes ([[https://www.reddit.com/r/emacs/comments/733698/if_a_file_has_changed_on_disk_save_anyway_without/][reddit]])
    #+begin_src emacs-lisp
(defun ask-user-about-supersession-threat (args)
  "Ignore file clashes.")
    #+end_src
  - do not show large file warnings
    #+begin_src emacs-lisp
(setq large-file-warning-threshold nil)
    #+end_src
- exit server silently
  #+begin_src emacs-lisp
(add-hook 'kill-emacs-hook '(lambda() (save-some-buffers 'save-all-buffers)) 'append)
  #+end_src
- disable =kill-emacs= 
  I start emacs as a daemon on system startup. Hence, I need to stop
  or start it as daemon, not using =kill-emacs=
  #+BEGIN_SRC emacs-lisp
(put 'kill-emacs 'disabled t)
  #+END_SRC
** Package management & configuration
:PROPERTIES:
:ID:       4c0a06f9-9e69-4ead-b570-e3143fa0d61d
:END:
#+NAME: package-archives-table
| Name  | URL                           |
|-------+-------------------------------|
| MELPA | https://melpa.org/packages/    |
| ELPA  | http://tromey.com/elpa/       |
| gnu   | http://elpa.gnu.org/packages/ |
| org   | http://orgmode.org/elpa/      |

#+NAME: parse-package-archives-table 
#+BEGIN_SRC emacs-lisp :tangle no :var packages=package-archives-table
(mapcar (lambda(el) (cons (car el) (cadr el))) packages)
#+END_SRC

#+begin_src emacs-lisp :noweb yes
(eval-and-compile
  (require 'package)
  (setq package-archives '<<parse-package-archives-table()>>
	load-prefer-newer t
	package-user-dir "~/.emacs.d/elpa/"
	package--init-file-ensured t
	package-enable-at-startup nil)
  (unless (file-directory-p package-user-dir)
    (make-directory package-user-dir t))
  (setq load-path (append '("~/.emacs.d/site-lisp/") load-path))
  (setq load-path (append (directory-files "~/.emacs.d/site-lisp/" t "^[^.]" t) load-path))
  (setq load-path (append (directory-files package-user-dir t "^[^.]" t) load-path))
  (package-initialize))
#+end_src

- enforce =use-package=
  #+begin_src emacs-lisp
(eval-and-compile
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package)))
(eval-when-compile
  (require 'use-package))
(use-package diminish :ensure t)
(require 'bind-key)
  #+end_src
- automatically update packages on startup
  #+begin_src emacs-lisp
(use-package auto-package-update
  :ensure t
  :config
  (setq auto-package-update-delete-old-versions t)
  (auto-package-update-maybe))
  #+end_src
- prefer setting in this file over customized interface
  #+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(add-hook 'after-init-hook (lambda nil (load custom-file)))
  #+end_src
** Appearance
*** Theme
**** =Flatui=
:PROPERTIES:
:ID:       404c54f5-26eb-4ada-8a0f-c27efc714238
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-10-08 Sun 11:58]
:END:
#+begin_src emacs-lisp
(use-package flatui-theme
  :if init-flag
  :ensure t
  :config
  (load-theme 'flatui t))
#+end_src
- I want Source Code Pro default everywhere
  #+begin_src emacs-lisp
(when init-flag
  (custom-set-faces '(default ((t (:inherit nil
					    :stipple nil
					    :inverse-video nil
					    :box nil
					    :strike-through nil
					    :overline nil
					    :underline nil
					    :slant normal
					    :weight normal
					    :height 100
					    :width normal
					    :foundry "adobe"
					    :family "source code pro"))))))
  #+end_src
*** No startup message
:PROPERTIES:
:ID:       5450bef9-a57a-4afb-85f3-893dbcb5f4ba
:END:
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src
*** Frame
**** No tool bar
:PROPERTIES:
:ID:       1d4d5272-e727-46cf-ac51-8c9aeeebdf53
:END:
#+begin_src emacs-lisp
(tool-bar-mode -1)
#+end_src
**** No scroll bar
:PROPERTIES:
:ID:       e0716fb4-11ac-4375-a3eb-45a73b7ace64
:END:
#+begin_src emacs-lisp
(scroll-bar-mode -1)
#+end_src
**** No menu bar
:PROPERTIES:
:CREATED:  [2018-06-30 Sat 13:00]
:ID:       b872aea3-5707-47c3-bcdf-ace4959a253a
:END:
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC
*** Buffer
**** Centered window mode
:PROPERTIES:
:ID:       af9c7d6c-fd15-4d68-b379-3d439ea94370
:END:
My screen is too wide to read text comfortably. I am not very comfortable with =auto-fill-mode=, so I prefer to limit the buffer width.
#+begin_src emacs-lisp
(use-package centered-window
  :if init-flag
  :diminish centered-window-mode
  :init
  ;; (require 'centered-window)
  :config
  (use-package boon 
    :config
    (bind-keys :map boon-x-map ("w" . centered-window-mode)))
  (centered-window-mode t))
#+end_src
**** TODO Long lines handling
:PROPERTIES:
:ID:       827dc236-fee4-43b8-bfbe-05026d7e3e6d
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:24]
:END:
#+begin_src emacs-lisp
(setq-default truncate-lines t)
(add-hook 'org-mode-hook (lambda()
			   (toggle-word-wrap +1)))
#+end_src
*** Text in buffers
**** Coding system
:PROPERTIES:
:ID:       07c3544a-bcbd-4790-815a-25615ca2ca03
:END:
- prefer UTF
  #+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
  #+end_src
**** Visual text transformation
Show some text in buffer differently
***** Page break shown as lines
:PROPERTIES:
:ID:       6c1e16d6-7f4e-41e5-99a8-13fac4eab2a3
:END:
#+begin_src emacs-lisp
(use-package page-break-lines
  :if init-flag
  :ensure t
  :diminish page-break-lines-mode
  :config (global-page-break-lines-mode))
#+end_src
***** TODO Pretty symbols
:PROPERTIES:
:ID:       315191d1-6edf-4c10-a1fe-0fb70885fbe1
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:26]
- State "HOLD"       from              [2018-03-04 Sun 17:57]
:END:
#+begin_src emacs-lisp
(use-package pretty-symbols
  :disabled t
  :if init-flag
  :diminish pretty-symbols-mode
  :ensure t
  :after org
  :hook ((pretty-symbols-mode . font-lock-fontify-buffer)
	 ((prog-mode org-mode) . pretty-symbols-mode))
  :init
  (setq pretty-symbol-categories '(relational logical lambda org-specific nil cpp general))

  (defun yant/str-to-glyph (str)
    "Transform string into glyph, displayed correctly."
    (let ((composition nil))
      (dolist (char (string-to-list str)
		    (nreverse (cdr composition)))
	(push char composition)
	(push '(Br . Bl) composition)
	)))

  (setq pretty-symbol-patterns  (let ((lisps '(emacs-lisp-mode
					       inferior-lisp-mode
					       inferior-emacs-lisp-mode
					       lisp-mode scheme-mode))
				      (c-like '(c-mode
						c++-mode go-mode java-mode js-mode
						perl-mode cperl-mode ruby-mode
						python-mode inferior-python-mode)))
				  `(
				    ;; Basic symbols, enabled by default
				    (?λ lambda "\\<lambda\\>" (,@lisps python-mode inferior-python-mode))
				    (?ƒ lambda "\\<function\\>" (js-mode))
				    ;; general symbols, which can be applied in most of the modes
				    ;; Relational operators --
				    ;; enable by adding 'relational to `pretty-symbol-categories'
				    (?≠ relational "\\(!=\\)" (,@c-like org-mode) 1)
				    (?≠ relational "\\(/=\\)" (,@lisps) 1)
				    (?≥ relational "\\(>=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≤ relational "\\(<=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≔ relational "[^=]\\(=\\)" (,@c-like ,@lisps org-mode) 1)
				    (?≡ relational "\\(==\\)" (,@c-like ,@lisps org-mode) 1)
				    (?↠ cpp ">>" (c++-mode))
				    (?↞ cpp "<<" (c++-mode))
				    (?⇢ cpp "->" (c++-mode))
				    (?⋮ cpp "::" (c++-mode))
				    (?⏎ cpp "\\<endl\\>" (c++-mode))
				    (?∞ cpp "\\<INF\\>" (c++-mode))
				    (?⇰ cpp "\\<return\\>" (c++-mode))
				    (?↹ cpp "\\(\\\\t\\) " (,@c-like ,@lisps org-mode))
				    ;; Logical operators
				    (?∧ logical "&&" (,@c-like org-mode))
				    (?∨ logical "||" (,@c-like org-mode))
				    ;;(?¬ logical "\\<!\\>" (,@c-like)) ; TODO: Fix regex so that ! matches
					; but != doesn't. (\< and \> don't work
					; because ! isn't considered part of
					; a word). This will require support
					; for subgroups and not replacing the
					; whole match.
				    (?¬ logical "(\\<\\(not\\)\\>" (,@lisps) 1)
				    (?∅ nil "\\<nil\\>" (,@lisps))
				    ))))

#+end_src
***** Latex pretty symbols
:PROPERTIES:
:ID:       bdf24c4b-681c-4286-86cd-e81f63b94ec0
:END:
#+begin_src emacs-lisp 
(use-package latex-pretty-symbols
  :if init-flag
  :ensure t
  :config
  (global-prettify-symbols-mode t))
#+end_src
*** Mode line
:PROPERTIES:
:ID:       ca75c464-f35c-43ed-a90e-d78d4cfaa99a
:END:
- =Powerline= + =smart-mode-line=
  - triangular arrow shape
  - set the foreground manually because =boon-powerline= default background is not good with [[id:404c54f5-26eb-4ada-8a0f-c27efc714238][Flatui]]
    #+begin_src emacs-lisp
(use-package powerline
  :if init-flag
  :ensure t
  :config
  (powerline-vim-theme)
  (custom-set-faces
   '(mode-line ((t (:foreground "#F2F2F2" :box nil)))))
  (use-package smart-mode-line
    :ensure t
    :config
    (setq powerline-arrow-shape 'arrow14)
    (sml/setup)))
    #+end_src
- Show column numbers
  #+begin_src emacs-lisp
(setf column-number-mode t)
  #+end_src
- Show total lines
  #+begin_src emacs-lisp
(setf size-indication-mode t)
  #+end_src
- Show boon state
  #+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package boon-powerline
    :config
    (boon-powerline-theme)))
  #+end_src

*** Cursor
**** COMMENT Highlight cursor when it moves far
:PROPERTIES:
:ID:       c86d4d84-aa19-43e8-990a-6305db525433
:END:
=beacon-mode= seems to slow down the org movement like =c u=.
#+begin_src emacs-lisp :tangle no
(use-package beacon
  :if init-flag
  :ensure t
  :diminish beacon-mode
  :config
  (beacon-mode 1))
#+end_src
**** Highlight current line 
:PROPERTIES:
:ID:       f90676cb-1c8a-47c1-b539-debcf961d912
:END:
#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src
** Command loop
*** Dialogues
:PROPERTIES:
:ID:       b1e1c83a-18be-4c5c-bd77-970a0a163b72
:END:
- enforce =y-or-n-p= everywhere
- do not use graphical dialogues
  #+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
  #+end_src
*** Key bindings
At some point, a got very annoyed about distance between =C-n=, =C-p=,
=C-f=, and =C-b= and did not want to move my hand all the way to arrow
keys. So, I use modal editing  now, which allows me to move around
using the keys, which are close to each other. 
**** Modal setup
:PROPERTIES:
:ID:       0fe0bca3-fb51-4e0c-8b35-79a5e92975d6
:END:
Do not use =self-insert-command= by default, but bind character keys to navigation, selection, etc.
I use [[https://github.com/jyp/boon][boon]] package for this purpose.
- it is bad idea to enable boon insert mode in special buffers, so it has =special mode= with limited redefined key binding by default. This mode replaces normal =insert mode= 
- I add extra functionality for the case when =special mode= or =command mode= should not be enabled by default --- the buffer requires a lot of writing (I mean shell buffers, for example). This is defined by =boon-insert-state-major-mode-list= where the default mode is =insert mode=.
- =boon-special-mode= is frequently useful in all kinds of major modes, like debug, org-agenda, notmuch, etc. However, many major modes use the conventional movement key bindings or their derivatives (like "n" and "p" in =org-agenda=). I do not like it. I prefer to have some minimal [[id:46fb459b-7794-4b9a-9fce-85389aba1d95][set]] of movement keys working in all the buffers. It means, that I need to redefine the movement commands to be able to act according to the major mode (like "n" from org-mode is binded to =org-next-line= and, hence, "j" from =org-special-map= should be also bound to =org-next-line=.
  This can be done using meta-function approach when I use the function, which acts differently depending on the mode, while keeping the same general idea of the behavior.

#+BEGIN_SRC emacs-lisp
(use-package boon
:defer t
:config
(set-keymap-parent boon-special-map boon-moves-map))
#+END_SRC

#+begin_src emacs-lisp :tangle ~/Git/meta-functions/meta-functions.el
  ;;; meta-functions.el --- Define meta-functions to act differently depending on major mode -*- lexical-binding: t; -*-

;; Version: 1.0
;; Author: Ihor Radchenko <yantar92@gmail.com>
;; Created: 10 March 2018

  ;;; Commentary:

;; Quick implementation of meta-functions, which allows to run multiple
;; functions, which do similar logical operations by one single "meta"
;; function in different major modes. For example, one may want to define
;; meta-next-line to call `next-line' normally, but
;; `org-agenda-next-line' in org-agenda mode. Both can be binded to, say
;; "M-j", without a need to change the key-bindings on both fundamental
;; and org-agenda modes.
;; Example usage:
;; (use-package meta-functions
;;   :init
;;   (setq meta-funcions-list '((meta-function-1 default-function-1 "Description") (meta-function-2 default-function-2  "description")))
;;   (setq meta-functions-meta-function-1-alist '((major-mode-1 . function-1)))
;;   )
;; This will define meta-function-1 and meta-function-2 to automatically
;; choose the right real functions depending on the major mode.

  ;;; Code:

(defvar meta-functions-list '()
  "A list of meta function names, corresponding functions to be called by default, and their description.
    Each function may have meta-functions-metafunctionname-alist variable containing pairs of major mode names
    and corresponding function to be called by meta-function in that major mode.
    The default functions will be called if the major mode is not in the alist")

(defun meta-functions-add-meta-function (&rest args)
  "Add meta function or a list of metafunctions as in `meta-functions-list' and update the definitions."
  (setq meta-functions-list (append meta-functions-list args))
  (meta-functions-update-function-definitions))

(defun meta-functions-update-function-definitions ()
  "Update definitions of all the meta-functions according the present value of `meta-functions-list'."
  (mapc (lambda (elem)
	  (let* ((meta-func (car elem))
		 (default-func (cadr elem))
		 (meta-func-description (or (car (nthcdr 2 elem))
					    ""))
		 (func-alist (read (concat "meta-functions-" (format "%s" `,meta-func) "-alist"))))
	    (eval `(defvar ,func-alist '()
		     ,(concat "List of functions to be called by `"
			      (format "%s" meta-func)
			      "'.\nIt is an alist containing cons of major mode name and function name to be called.")))
	    (eval `(defun ,meta-func (&optional args)
		     ,(concat "Meta function."
			      (if (not (seq-empty-p meta-func-description))
				  (concat " The description is: \""
					  meta-func-description
					  "\"."))
			      "\nMeta function is calling `"
			      (format "%s" default-func)
			      "' by default."
			      (and (not (seq-empty-p (eval func-alist)))
				   (concat "\nCalling other functions in various major modes (major-mode . functions):\n"
					   (mapconcat (lambda(elem) (message "%s . `%s'" (car elem) (cdr elem))) (eval func-alist) "\n")
					   )))
		     (interactive)
		     (let ((real-func
			    (or (alist-get major-mode ,func-alist ',default-func)
				',default-func)))
		       (when (fboundp real-func)
			 (call-interactively real-func nil args)))))))
	meta-functions-list))

(meta-functions-update-function-definitions)

(provide 'meta-functions)

  ;;; meta-functions.el ends here
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :demand t)
#+END_SRC

  It should be noted, that the same can be done via setting the proper bindings for "j", "k", etc. in the mode itself. The problem is that it may mess up the cases when want to set special meanings for the single keys in =command-mode=, but leave the normal editing on in the =insert-mode=.
  
  #+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :ensure t
  :diminish boon-local-mode
  :config
  (use-package boon-qwerty)
  (boon-mode)
  (setq boon-special-mode-list
	'(debugger-mode ediff-mode org-agenda-mode cfw:calendar-mode
			notmuch-search-mode notmuch-show-mode elfeed-search-mode
                        elfeed-show-mode pomidor-mode mingus-mode
                        notmuch-hello-mode ledger-report-mode help-mode
                        dired-mode pdf-view-mode helpful-mode magit-file-mode magit-status-mode magit-revision-mode))
  (defvar boon-insert-state-major-mode-list '()
    "List of major modes started with insert state active.")
  (setq boon-insert-state-major-mode-list
	'(notmuch-message-mode eshell-mode shell-mode calc-mode term-mode
			       magit-popup-mode))
  (add-hook 'boon-local-mode-hook
	    (lambda() (when (and boon-local-mode
			    (member major-mode boon-insert-state-major-mode-list))
		   (boon-insert)))
	    'append))
  #+end_src

  Also, I do not like default implementation of =boon-special-mode-p=, which force setting special mode for terminal-modes. I prefer to rewrite it
#+BEGIN_SRC emacs-lisp
(use-package boon
:defer t
:config
(define-advice boon-special-mode-p (:around (oldfun) force-special-mode-list-only)
  "Force setting boon-special-mode when mode is in `boon-special-mode-list' and only in it. No exceptions."
  (memq major-mode boon-special-mode-list)))
#+END_SRC
**** TODO Use key chords
:PROPERTIES:
:ID:       de456dca-9bf0-48b9-90cf-0191e6e65d4e
:END:
#+begin_src emacs-lisp
(use-package key-chord
  :if init-flag
  :ensure t
  :config
  (key-chord-mode 1))
#+end_src
**** Hydra
:PROPERTIES:
:CREATED:  [2017-12-31 Sun 08:36]
:ID:       8ad95362-807a-457d-8b59-32e83a350c18
:END:
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  )
#+END_SRC
**** Ignore some system keybindings, which are used in my WM (annoying unknown keybinding error)
:PROPERTIES:
:ID:       af77c219-c181-4534-bdfc-325616965ddc
:END:
#+begin_src emacs-lisp
(global-set-key (kbd "<XF86MonBrightnessUp>") #'ignore)
(global-set-key (kbd "<XF86MonBrightnessDown>") #'ignore)
#+end_src
**** Make key bindings work in Ukrainian/Russian =keymap=
:PROPERTIES:
:ID:       943917fe-aecf-45a7-bc0d-591492d17898
:END:
#+begin_src emacs-lisp
;; (use-package reverse-im :ensure t
;;   :if init-flag
;;   :config
;;   (reverse-im-activate "russian-computer"))
(when init-flag
  (cl-loop
   for from across "йцукенгшщзхїфівапролджєячсмитьбюЙЦУКЕНГШЩЗХЇФІВАПРОЛДЖЄЯЧСМИТЬБЮ№"
   for to   across "qwertyuiop[]asdfghjkl;'zxcvbnm,.QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>#"
   do
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "C-"
			  (string from)))
	    (kbd ,(concat "C-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "M-"
			  (string from)))
	    (kbd ,(concat "M-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(concat "C-M-"
			  (string from)))
	    (kbd ,(concat "C-M-"
			  (string to)))))
   (eval `(define-key local-function-key-map
	    (kbd ,(string from))
	    (kbd ,(string to))))))
#+end_src
***** TODO Make it work everywhere
- +This does not work with things like =C-c 'symbol= for now.+
- +This does not work with boon =command mode= and =special mode=.+
- this does not work with key chords (again read-event)
- this does not work with region specifiers on boon (it uses read-event!)
** Completion 
*** Helm 
:PROPERTIES:
:ID:       d388e4f5-214e-4697-a53a-be6fb6c24411
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :ensure t
  :diminish helm-mode
  :bind (
	 ("M-x" . helm-M-x)
	 ("M-y" . helm-show-kill-ring)
	 ("<f1> a" . helm-apropos)
         ("C-x c" . nil)
	 :map helm-map
	 ("C-M-y" . helm-yank-selection)
	 ("M-j" . helm-next-line)
	 ("M-k" . helm-previous-line)
	 ("M-o" . helm-next-source)
	 ("M-i" . helm-previous-source)
	 ("M-l" . helm-execute-persistent-action)
	 ("C-M-h" . backward-kill-word)
	 ("M-h" . backward-kill-word)
	 ("C-h" . backward-delete-char-untabify)
	 :map helm-find-files-map
	 ("M-l" . nil)
	 )
  :defines helm-global-mode
  :config
  (use-package helm-config)
  (use-package helm-files)
  (use-package helm-command)
  (setq helm-input-idle-delay 0.01
	helm-exit-idle-delay 0
	helm-M-x-requires-pattern nil
	helm-split-window-inside-p           t ; open helm buffer inside current window, not occupy whole other window
	helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	helm-ff-file-name-history-use-recentf t)
  (define-global-minor-mode helm-global-mode helm-mode
    (lambda()
      (helm-mode 1)))
  (helm-global-mode))
#+end_src
*** Company
:PROPERTIES:
:ID:       8ca3a911-ad9d-43a6-83a6-a7b12b383984
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-09-22 Fri 07:58]
:END:
#+begin_src emacs-lisp
(use-package company
  :if init-flag
  :ensure t
  :diminish company-mode
  :hook (after-init . global-company-mode)
  :bind (
	 ("M-/" . company-complete)
	 ("C-/" . hippie-expand)
	 :map company-active-map
	 ("M-j" . company-select-next)
	 ("M-k" . company-select-previous)
	 ("C-h" . backward-delete-char-untabify)
         ("C-M-h" . backward-kill-word)
         ("M-l" . company-show-location)
         ("M-h" . company-show-doc-buffer))
  :init
  (setq company-idle-delay 0
	company-minimum-prefix-length 2))
#+end_src
*** Yasnippets
:PROPERTIES:
:ID:       f6f5c535-67bb-44bd-ad1f-dacae7a7f52e
:END:
#+begin_src emacs-lisp
(use-package yasnippet
  :if init-flag
  :ensure t
  :diminish yas-minor-mode
  :config
  (use-package yasnippet-snippets
    :ensure t)) 
#+end_src

**** Helm completion
:PROPERTIES:
:ID:       95fd1634-5d93-4206-8c08-4b3901fa9bfe
:END:
#+begin_src emacs-lisp
  (use-package helm
    :if init-flag
    :config
    (use-package yasnippet
      :defer t
      :config
      (use-package helm-c-yasnippet
	:ensure t
	:config
	(bind-keys ("M-<tab>" . helm-yas-complete)))))
#+end_src
**** Org mode
***** TODO =#+BEGIN_SRC= snippets
****** TODO =Elisp_=
:PROPERTIES:
:ID:       7dea66b3-caca-412d-adac-e1ae6de44bec
:END:
#+begin_src org :tangle "snippets/org-mode/elisp"
# -*- mode: snippet -*-
# name: elisp
# key: elisp_
# --
,#+begin_src emacs-lisp
$0`(progn (org-edit-special) (boon-insert))`
,#+end_src
#+end_src
** History & version control
*** Save buffer key binding
:PROPERTIES:
:ID:       21a8d99d-3f19-48d8-8f50-bfa9e139dbbc
:END:
Boon =command mode= allows to translate =c 'symbol= key bindings into =C-c
'symbol= key bindings. It is useful, but =save-buffer= is more meaningful
to rebind to =C-c s= is such a case and =save-some-buffers= to =C-c C-s=. 
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (bind-key "C-x s" 'save-buffer)
  (bind-key "C-x C-s" 'save-some-buffers))
#+end_src
*** Backup
:PROPERTIES:
:ID:       e9322c07-68fa-485f-abac-af5b5a2b97f5
:END:
#+begin_src emacs-lisp
(setq
 backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
 backup-by-copying t
 delete-old-versions t
 kept-new-versions 100000
 kept-old-versions 100000
 version-control t
 create-lockfiles nil
 )
#+end_src
*** Auto save
:PROPERTIES:
:ID:       2e32ad16-4c7a-46b9-8c47-06f7f5566032
:END:
#+begin_src emacs-lisp
(setq  auto-save-file-name-transforms `((".*"  "~/.emacs.d/auto-save/" t))
       auto-save-interval 20)
#+end_src
- Save virtual buffers (kill ring, etc.)
  #+begin_src emacs-lisp
(savehist-mode 1)
  #+end_src
*** TODO Never save some buffers
:PROPERTIES:
:ID:       7d188a71-560a-4d37-8037-2f2e44726a06
:END:
I got an issue with =org-src= block editing buffers. They are saved
under some weird name beside the actual org file when some command,
saving all the buffers, is executed. 
#+begin_src emacs-lisp 
(defvar yant/never-save-buffer-list nil
  "The buffers, matching any of the regexps in this list will never be saved.")
#+end_src
*** Undo tree
:PROPERTIES:
:ID:       85e15d5a-65f0-4283-93e4-7997fe9fa1a3
:END:
#+begin_src emacs-lisp
(use-package undo-tree
  :if init-flag
  :ensure t
  ;;:diminish undo-tree-mode
  :hook ((org-mode text-mode prog-mode) .  undo-tree-mode)
  :config
  (setq
   undo-tree-auto-save-history t
   undo-tree-visualizer-diff t
   undo-tree-visualizer-timestamps t
   undo-tree-history-directory-alist '((".*" . "~/.emacs.d/undo"))
   undo-tree-enable-undo-in-region nil ; workaround to fix random error thrown by undo "Unrecognized entry in undo list undo-tree-canary" (unresolved undo-tree bug)
   ))
#+end_src
*** Persistent scratch
:PROPERTIES:
:ID:       4185d833-9d1f-4763-97a0-d44bcc322da7
:END:
#+begin_src emacs-lisp
(use-package  persistent-scratch
  :if init-flag
  :ensure t
  :config
  (persistent-scratch-autosave-mode 1)
  )
#+end_src
*** Recent files
:PROPERTIES:
:ID:       b72d24a2-7692-4e37-b547-10c30b058c22
:END:
#+begin_src emacs-lisp
  (use-package helm
    :if init-flag
    :defer t
    :bind ("C-x r" . helm-recentf)
    :config
      (recentf-mode t)
      (setq
       recentf-max-menu-items 30
       recentf-max-saved-items 100
       helm-ff-file-name-history-use-recentf t))
#+end_src
*** Global auto-revert
:PROPERTIES:
:ID:       b4f4fbea-9315-412c-bb48-6984906c67d8
:END:
#+begin_src emacs-lisp 
(global-auto-revert-mode)
(setq revert-without-query '(".*"))
#+end_src
*** Magit
:PROPERTIES:
:CREATED:  [2018-08-11 Sat 20:47]
:END:
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (use-package boon :config
    (bind-key "g" magit-file-mode-map boon-x-map)
    (bind-keys :map magit-file-mode-map
	       ("g" . magit-status)
	       ("G" . magit-dispatch-popup)
	       ("M-g" . magit-file-popup))
    (use-package meta-functions
      :config
      (add-to-list 'meta-functions-meta-down-element-alist '(magit-status-mode . magit-section-forward))
      (add-to-list 'meta-functions-meta-up-element-alist '(magit-status-mode . magit-section-backward))
      (add-to-list 'meta-functions-meta-down-element-alist '(magit-revision-mode . magit-section-forward))
      (add-to-list 'meta-functions-meta-up-element-alist '(magit-revision-mode . magit-section-backward))
      (meta-functions-update-function-definitions))))
#+END_SRC
** Text highlight & coloring
*** Highlight text in buffer
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 14:29]
:ID:       9c3fe725-f67e-4abb-878f-da7b45bea121
:END:
  #+begin_src emacs-lisp
(use-package hi-lock
  :if init-flag
  :diminish hi-lock-mode)
  #+end_src
*** TODO Spell checking
:PROPERTIES:
:ID:       117c5718-7a46-4a7a-ab0d-b5b347444080
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-18 Wed 11:26]
:END:
*************** TODO fly ispell only with idle timer?
*************** END

#+begin_src emacs-lisp
(use-package flyspell
  :if init-flag
  :ensure t
  :after org
  :hook ((text-mode org-mode latex-mode notmuch-message-mode) . flyspell-mode)
  :bind (("<f8>" . ispell-word)
	 ("M-<f8>" . ispell-buffer)
         :map boon-forward-search-map
         ("s" . flyspell-goto-next-error))
  :init
  (use-package boon)
  :config
  (setq ispell-program-name "/usr/bin/ispell-aspell")
  (setq ispell-dictionary "american")
  (setq ispell-personal-dictionary "~/.emacs.d/dict")
  (defun flyspell-emacs-popup-textual (event poss word)
    "A textual flyspell popup menu.
From https://www.emacswiki.org/emacs/FlySpell"
    (require 'popup)
    (let* ((corrects (if flyspell-sort-corrections
			 (sort (car (cdr (cdr poss))) 'string<)
		       (car (cdr (cdr poss)))))
	   (cor-menu (if (consp corrects)
			 (mapcar (lambda (correct)
				   (list correct correct))
				 corrects)
		       '()))
	   (affix (car (cdr (cdr (cdr poss)))))
	   show-affix-info
	   (base-menu  (let ((save (if (and (consp affix) show-affix-info)
				       (list
					(list (concat "Save affix: " (car affix))
					      'save)
					'("Accept (session)" session)
					'("Accept (buffer)" buffer))
				     '(("Save word" save)
				       ("Accept (session)" session)
				       ("Accept (buffer)" buffer)))))
			 (if (consp cor-menu)
			     (append cor-menu (cons "" save))
			   save)))
	   (menu (mapcar
		  (lambda (arg) (if (consp arg) (car arg) arg))
		  base-menu)))
      (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
  (fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)
  (defadvice flyspell-goto-next-error (after check-word-spelling activate) (ispell-word))
  (add-to-list 'ispell-skip-region-alist '("^[ ]*#\+begin_src" . "^[ ]*#\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("^[ ]*#\+.*$"))
  (add-to-list 'ispell-skip-region-alist '("=[^=]+="))
  (add-to-list 'ispell-skip-region-alist '("\$.*?\$")))
#+end_src
*** Code checking
:PROPERTIES:
:ID:       3a550aad-f2a2-4636-a92c-539cdf230aeb
:END:
#+begin_src emacs-lisp
(use-package flycheck
  :if init-flag
  :ensure t
  :diminish flycheck-mode
  :hook ((prog-mode) . flycheck-mode)
  :config
  (use-package flycheck-tip
    :ensure t
    :config
    (setq flycheck-display-errors-function 'ignore)
    (use-package boon
      :config
      (bind-keys :map boon-forward-search-map
		 ("c" . flycheck-tip-cycle)
                 :map boon-backward-search-map
                 ("c" . flycheck-tip-cycle-reverse)))))
#+end_src
*** Highlight parentheses everywhere
:PROPERTIES:
:ID:       767805ca-1482-4299-8a1c-3e3b1a73f94a
:END:
#+begin_src emacs-lisp
(use-package highlight-parentheses
  :if init-flag
  :ensure t
  :diminish highlight-parentheses-mode
  :config
  (define-globalized-minor-mode global-highlight-parentheses-mode
    highlight-parentheses-mode
    (lambda ()
      (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t))

(use-package rainbow-delimiters
  :if init-flag
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
*** Highlight numbers
:PROPERTIES:
:ID:       024a16ec-c9db-4906-9896-8ebf8af76dae
:END:
#+begin_src emacs-lisp
(use-package highlight-numbers
  :if init-flag
  :ensure t
  :hook (prog-mode . highlight-numbers-mode))
#+end_src
*** Regexp escape smart highlight
:PROPERTIES:
:ID:       5d7810ea-35d4-4ee9-afaa-61b9c6c624c6
:END:
#+begin_src emacs-lisp
(use-package easy-escape
  :if init-flag
  :ensure t
  :diminish easy-escape-minor-mode
  :hook (prog-mode . easy-escape-minor-mode))
#+end_src
*** Search highlight
:PROPERTIES:
:ID:       afa67877-bede-41c1-9c44-bb168070d292
:END:
#+begin_src emacs-lisp
(setf search-highlight t)
(setf query-replace-highlight t)
#+end_src
*** Volatile highlights - highlight actions
:PROPERTIES:
:ID:       02c8a98c-a38a-4054-a0a2-400f6757693b
:END:
- I changed the background color here due to clash with my =org-mode= colors
  #+begin_src emacs-lisp
(use-package volatile-highlights
  :if init-flag
  :ensure t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t)
  (custom-set-faces
   '(vhl/default-face ((t :background "LightGray" :inherit secondary-selection)))))
  #+end_src
*** Expand region
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 20:46]
:ID:       13ec58f5-636b-479f-ad19-ad229ce47603
:END:
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :if init-flag
  :ensure t
  :bind (:map boon-command-map
	      ("r" . er/expand-region)))

#+END_SRC
** Fold & narrow
*** =Hideshow= mode
:PROPERTIES:
:ID:       6ea2a9f7-7b73-4289-976f-b53adcae8f38
:END:
#+begin_src emacs-lisp
(use-package hideshow
  :if init-flag
  :ensure t
  :bind (:map hs-minor-mode-map
	      :filter boon-command-state
	      ("<tab>" . hs-toggle-hiding)
	      ("<backtab>" . hs-hide-all)
	      ("M-S-<iso-lefttab>" . hs-show-all))
  :hook ((c-mode-common emacs-lisp-mode sh-mode org-src-mode) . hs-minor-mode))
#+end_src
*** Turn on narrow
:PROPERTIES:
:ID:       9b629716-48c5-41c7-b34e-5e458922368b
:END:
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src
** Search & navigation
:PROPERTIES:
:ID:       46fb459b-7794-4b9a-9fce-85389aba1d95
:END:
*** Text
**** Boon navigation & search
:PROPERTIES:
:ID:       e90d8071-a7ed-4aba-a694-a78aa5fded78
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package meta-functions
    :if init-flag
    :config
    (meta-functions-add-meta-function '(meta-down next-logical-line "Move down."))
    (meta-functions-add-meta-function '(meta-up previous-logical-line "Move up."))
    (meta-functions-add-meta-function '(meta-down-element forward-paragraph "Move down one element."))
    (meta-functions-add-meta-function '(meta-up-element backward-paragraph "Move up one element."))
    (meta-functions-add-meta-function '(meta-forward forward-char "Move forward."))
    (meta-functions-add-meta-function '(meta-backward backward-char "Move backward."))
    (meta-functions-add-meta-function '(meta-forward-element forward-word "Move forward one element."))
    (meta-functions-add-meta-function '(meta-backward-element backward-word "Move backward one element."))
    (meta-functions-add-meta-function '(meta-scroll-up scroll-up "Scroll up."))
    (meta-functions-add-meta-function '(meta-scroll-down scroll-down "Scroll down."))
    (meta-functions-add-meta-function '(meta-undo undo-tree-undo "Undo.")))
  (bind-keys ("C-M-S-j" . scroll-other-window)
	     ("C-M-S-k" . scroll-other-window-down)
	     :map boon-x-map
	     ("e" . eval-last-sexp)
	     ("c" . delete-frame)
	     :map boon-moves-map
	     ("j" . meta-down)
	     ("J" . meta-down-element)
	     ("k" . meta-up)
	     ("K" . meta-up-element)
	     ("o" . meta-forward)
	     ("O" . meta-forward-element)
	     ("i" . meta-backward)
	     ("I" . meta-backward-element)
	     ("l" . meta-scroll-up)
	     ("L" . meta-scroll-down)
	     (";" . recenter-top-bottom)
	     ("G" . end-of-buffer)
	     ("g" . boon-goto-map)
	     ("U" . move-beginning-of-line)
	     ("P" . move-end-of-line)
	     ("u" . boon-beginning-of-line)
	     ("p" . boon-end-of-line)
	     :map boon-goto-map
	     ("g" . beginning-of-buffer)
	     ("G" . end-of-buffer)
	     :map boon-command-map
	     ("-" . meta-undo)
             ("_" . undo-tree-redo)
	     ("~" . boon-repeat-command)
	     ("Q" . kmacro-end-or-call-macro)
	     ("q" . nil)
	     ("P" . nil)
	     ("z" . boon-quote-character)
	     ("y" . transpose-chars)
	     ("Y" . transpose-words)
	     :map boon-forward-search-map
	     ("C-SPC" . isearch-forward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("w" . helm-occur)
	     :map boon-backward-search-map
	     ("C-SPC" . isearch-backward-regexp)
	     ("C-g" . boon-unhighlight)
	     ("e" . helm-occur)
	     :map boon-special-map
	     ("c" . boon-c-god)
	     ("z" . boon-quote-character)
	     ("e" . boon-forward-search-map)
	     ("w" . boon-backward-search-map)
	     ("q" . nil)
	     ("g" . boon-goto-map)
	     ("G" . end-of-buffer)
	     ("D" . boon-treasure-region)
	     ("<SPC>" . boon-drop-mark)))
#+end_src

**** =Avy= mode - =qutebrowser= like hints to words
:PROPERTIES:
:ID:       f645973b-fcd8-466a-9fec-7e8ebcbb0be1
:END:
#+begin_src emacs-lisp 
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package avy
    :ensure t
    :bind (:map boon-moves-map
		("h" . avy-goto-char-2)
		("H" . avy-goto-char-in-line)
		("M-h" . avy-goto-line)
		:map boon-forward-search-map
		("h" . avy-isearch)
		:map boon-backward-search-map
		("h" . avy-isearch))))
#+end_src
**** End of sentence
:PROPERTIES:
:CREATED:  [2018-01-18 Thu 14:43]
:ID:       40e35090-b8ec-4770-864b-9e286459533c
:END:
Double space convention is outdated.
#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC
*** Links
**** Browse URL
:PROPERTIES:
:ID:       17ccb0ae-e369-45bb-bfab-1d3cac9ca147
:END:
#+begin_src emacs-lisp
(use-package browse-url
  :bind (("C-c C-o" . browse-url)
	 ("C-c C-M-o" . browse-url-of-buffer))
  :init  
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "/home/yantar92/bin/qutebrowser-call.sh"))
#+end_src
*** TODO Bookmarks
:PROPERTIES:
:ID:       a3d45efd-52f8-44f7-a699-940033cba429
:END:
- quick bookmark
  #+begin_src emacs-lisp
(global-set-key (kbd "<f5>") '(lambda () (interactive) (message "Bookmark saved")
				(bookmark-set "SAVED")))
(global-set-key (kbd "<f6>") '(lambda () (interactive) (bookmark-set "RETURN")
				(bookmark-jump "SAVED")))
(global-set-key (kbd "S-<f6>") '(lambda () (interactive) (bookmark-jump "RETURN")))
  #+end_src
- actually, there should be proper bookmark packages - need to look and configure them properly
*** Buffers
**** Buffer list
:PROPERTIES:
:ID:       b69737e2-daa5-4b12-bb10-9ce37831edd4
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t 
  :bind (:map boon-forward-search-map
	      ("b" . helm-mini)
	      :map boon-backward-search-map
	      ("b" . helm-mini))
  :init
  (use-package boon))
#+end_src
**** Go to scratch key binding
:PROPERTIES:
:ID:       53b113ca-e2be-4f79-a575-aedbd0f0f7ad
:END:
#+begin_src emacs-lisp
(when init-flag
  (defun yant/show-scratch ()
    (interactive)
    (pop-to-buffer "*scratch*")
    )
  (use-package boon
    :config 
    (bind-key "8" 'yant/show-scratch boon-goto-map)))
#+end_src
**** Kill buffer & buffer manipulation/movement
:PROPERTIES:
:ID:       cb74c835-f010-4880-ad84-00736172753f
:END:
#+begin_src emacs-lisp
(when init-flag
  (bind-key "C-x q" (lambda () (interactive) (kill-buffer (current-buffer))))
  (use-package boon
    :defer t
    :config
    (use-package meta-functions
      :config
      (meta-functions-add-meta-function '(meta-next-buffer next-buffer "Go forward in buffer."))
      (meta-functions-add-meta-function '(meta-previous-buffer previous-buffer "Go backward in buffer.")))
    (bind-keys
     :map boon-goto-map
     ("o" . meta-next-buffer)
     ("i" . meta-previous-buffer))))
#+end_src
*** Windows
**** Window layout management
:PROPERTIES:
:ID:       413ad4db-e20c-432f-8d15-b849d35b6cff
:END:
If we use boon, it is possible to bind =M-digit= to manage windows.
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :bind (("M-1" . delete-other-windows)
	 ("M-2" . split-window-below)
	 ("M-0" . delete-window)
	 ("M-3" . split-window-right)
	 ("M-4" . (lambda () (interactive)
		    (split-window-right)
                    (call-interactively #'clone-indirect-buffer-other-window)))))
#+end_src
**** Wind move
:PROPERTIES:
:ID:       8cd8df5e-ff33-46ac-9864-38e990f745de
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
	     ("j" . windmove-down)
             ("k" . windmove-up)
             ("i". windmove-left)
             ("o" . windmove-right)
             ("l" . other-window)
             :map boon-backward-search-map
	     ("j" . windmove-down)
             ("k" . windmove-up)
             ("i". windmove-left)
             ("o" . windmove-right)
	     ("l" . other-window)))
#+end_src
*** Frame
:PROPERTIES:
:ID:       bb7ce294-1833-43bd-a837-ab4cd73fca6b
:END:
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-c") 'delete-frame)
(global-set-key (kbd "C-x c") 'delete-frame)
#+end_src
*** Files
**** Find files
:PROPERTIES:
:ID:       ecf20706-a6b2-4a46-b3c6-db3236a46d0f
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :config
  (bind-keys :map boon-forward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)
             ("d" . dired)
             :map boon-backward-search-map
	     ("f" . helm-find-files)
             ("F" . helm-locate)
	     ("d" . dired)))
#+end_src
***** Do not abbreviate file names (to avoid strange folders defined in [[id:9361bc68-010b-45f1-bddd-4638d6344758][org attachments]])
:PROPERTIES:
:CREATED:  [2018-07-25 Wed 17:28]
:ID:       7e252121-b5ba-4f9e-ba55-6eabb75d9a47
:END:
#+BEGIN_SRC emacs-lisp
(advice-add 'find-file-noselect :around #'dired-find-file@disable-abbreviate-file-name)
#+END_SRC
**** Search directories
***** TODO Dired
:PROPERTIES:
:ID:       66f5dab7-add6-48c2-9824-fed4ef202b7a
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 14:57]
- State "CANCELLED"  from              [2017-05-28 Sun 17:46]
:END:
#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :if init-flag
  :ensure t
  :hook ((dired-mode . auto-revert-mode)
	 ((dired-mode) . dired-hide-dotfiles-mode))
  :init
  (use-package autorevert)
  (setq global-auto-revert-non-file-buffers t
	auto-revert-verbose nil
	dired-dwim-target t
	dired-du-size-format t ;; show human readable size
	dired-listing-switches "--time-style=locale -DhgGBF --group-directories-first")
  :config
  (use-package dired-du :ensure t)
  (bind-key "." 'dired-hide-dotfiles-mode dired-mode-map)
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-alist '(dired-mode . dired-hacks-next-file))
    (add-to-list 'meta-functions-meta-up-alist '(dired-mode . dired-hacks-previous-file))
    (add-to-list 'meta-functions-meta-up-element-alist '(dired-mode . dired-up-directory))
    (add-to-list 'meta-functions-meta-down-element-alist '(dired-mode . dired-find-file))
    (meta-functions-update-function-definitions))
  (bind-keys :map dired-mode-map
	     ("q" . (lambda () (interactive) (quit-window 'kill)))	     
	     ("<return>" . xah-open-in-external-app)
	     ("W" . dired-copy-filename-as-kill)
             ("s" . dired-mark)
             ("a" . dired-unmark)
	     ("<tab>" . other-window)))

#+end_src
****** open file in external app 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:55]
:ID:       61a29cb9-8c13-4e10-979d-144866c4d122
:END:
  #+begin_src emacs-lisp
(defun xah-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2016-10-15"
  (interactive)
  (let* ((-file-list
	  (if (or (string-equal major-mode "dired-mode")
		  (string-equal major-mode "sr-mode")
		  )
	      (or (dired-get-marked-files)
		  (dired-get-filename)
		  )
	    (list (buffer-file-name))))
	 (-do-it-p (if (<= (length -file-list) 5)
		       t
		     (y-or-n-p "Open more than 5 files? "))))
    (when -do-it-p
      (cond
       ((string-equal system-type "windows-nt")
	(mapc (lambda (-fpath) (w32-shell-execute "open"
					     (replace-regexp-in-string "/" "\\" -fpath t t)))
	      -file-list))
       ((string-equal system-type "darwin")
	(mapc (lambda (-fpath) (shell-command (concat "open "
						 (shell-quote-argument -fpath))))
	      -file-list))
       ((string-equal system-type "gnu/linux")
	(mapc (lambda (-fpath) (let ((process-connection-type nil))
			    (start-process "" nil "xdg-open" -fpath)))
	      -file-list))))))
  #+end_src
****** Async operations
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       06e9d624-67fe-42cb-acca-44c1e5e1fde1
:END:
#+BEGIN_SRC emacs-lisp
  (use-package async
    :if init-flag
    :ensure t
    :config
    (use-package dired
      :defer t
      :config
      (use-package dired-async
	:config
	(dired-async-mode 1))))
#+END_SRC
****** Group files 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 21:56]
:ID:       18e2dd1e-dc25-4188-bad4-cdcdb76f506a
:END:
#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :if init-flag
  :ensure t
  :config
  (setq dired-filter-group-saved-groups '(("default"
					   ("Dirs"
					    (directory . nil))
					   ("Archives"
					    (extension "zip" "rar" "gz" "bz2" "tar"))
					   ("Documents"
					    (extension "org" "cfm" "pdf" "tex" "bib" "mobi" "fb2" "doc" "docx"))
					   ("Scripts"
					    (extension "gnuplot" "sh"))
					   ("Data"
					    (extension "txt" "hys" "xls" "xlsx"))
					   ("Images"
					    (extension "png" "jpg" "jpeg" "tiff" "tif"))
					   ("Videos"
					    (extension "avi" "mpeg" "mp4" "mkv"))
					   )))
  (add-hook 'dired-mode-hook 'dired-filter-group-mode))
#+END_SRC
****** Highlight files 
:PROPERTIES:
:CREATED:  [2018-04-09 Mon 22:09]
:ID:       45393002-d153-42bf-ae39-70b6e49b25b0
:END:
#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :if init-flag
  :ensure t
  :config
  (diredfl-global-mode 1))
#+END_SRC
****** TODO Follow symlink structure
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 15:42]
:ID:       3f656102-43d7-4a91-b245-92af4ffca9a6
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-23 Mon 15:45]
:END:
=dired-find-file= calls =find-file=, which calls =find-file-noselect=, which forces =abbreviate-file-name= to be applied. 
It makes entering symlink in =~/Dropbox/Org/->~/Org= go into "~/Org".
As a result, =dired-up-directory= goes to =~/= instead of =~/Dropbox=.

Hence, I avoid =abbreviate-file-name= in =dired-find-file=.
Same for =dired-noselect= (called by =dired=, which is called by =dired-up-directory=).

#+BEGIN_SRC emacs-lisp
(define-advice dired-find-file (:around (OLDFUN &rest args) disable-abbreviate-file-name)
"Disable `abbreviate-file-name' in dired."
(flet ((abbreviate-file-name (filename) "" filename))
  (apply OLDFUN args)))
(advice-add 'dired-noselect :around #'dired-find-file@disable-abbreviate-file-name)
#+END_SRC
****** Dired icons
:PROPERTIES:
:CREATED:  [2018-08-06 Mon 22:59]
:END:
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :ensure t
  :config
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)))
#+END_SRC
** Editing
*** Boon - set =command state= from =insert state=
:PROPERTIES:
:ID:       94ed4714-1f9d-43f7-8ddc-74f855154b2c
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package key-chord
    :defer t
    :config
    (key-chord-define boon-insert-map "jk" 'boon-set-command-state)))
    
#+end_src
*** Multiple cursors =insert state=
:PROPERTIES:
:ID:       8cbda343-0d1f-4abd-92d1-75a22b0b8d3c
:END:
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package multiple-cursors
    :defer t
    :bind (:map boon-command-map
		("C-V" . mc/edit-beginnings-of-lines))))
#+end_src
*** Open current line =insert state=
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 16:03]
:ID:       0d1d2022-e094-49b0-abc0-0957536690ee
:END:
#+BEGIN_SRC emacs-lisp
(use-package boon
:defer t
:config
(bind-key "M-v" 'boon-open-line-and-insert boon-command-map))
#+END_SRC
*** Query replace
:PROPERTIES:
:ID:       1825c53a-1f53-4da8-a2b0-04ddea8cc43e
:END:
#+begin_src emacs-lisp
(use-package boon
  :if init-flag
  :defer t
  :config
  (use-package visual-regexp
    :init
    (use-package visual-regexp-steroids :ensure t)
    :bind (:map boon-command-map
		("?" . vr/query-replace)
		("M-?" . helm-regexp))))
#+end_src
*** Comment/uncomment
:PROPERTIES:
:ID:       957cd651-ad7a-467d-b6d5-ac8bf92d839d
:END:
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :if init-flag
  :ensure t
  :bind (:map prog-mode-map
	      ("M-;" . comment-dwim-2))) 
#+end_src
*** Indent region
:PROPERTIES:
:ID:       703f08dd-3ad9-4eba-a60e-2ad4de642375
:END:
#+begin_src emacs-lisp
(bind-key* "C-<tab>" 'indent-region)
#+end_src
*** Aggressive indent
:PROPERTIES:
:ID:       f3eaeebf-fe50-4ec6-81ed-f42e8b7b71c6
:END:
#+begin_src emacs-lisp
(use-package aggressive-indent
  :if init-flag
  :ensure t
  :diminish aggressive-indent-mode
  :config
  (global-aggressive-indent-mode t))
#+end_src
*** Delete backward key bindings
:PROPERTIES:
:ID:       c36d8b82-50ab-4097-a93a-56cbcf376cee
:END:
#+begin_src emacs-lisp
(bind-keys ("C-M-h" . backward-kill-word)
	   ("C-h" . backward-delete-char-untabify)
           :map isearch-mode-map
	   ("C-h" . isearch-delete-char)
           ("C-M-h" . isearch-delete-char))
(use-package boon
  :if init-flag
  :defer t
  :bind (:map boon-command-map
	      ("C-h" . backward-delete-char-untabify)))
#+end_src
*** Return key
:PROPERTIES:
:ID:       ce7df944-6c64-4a7d-8e11-136237250e3c
:END:
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-j") (kbd "<RET>"))

(use-package meta-functions
  :if init-flag
  :config
  (meta-functions-add-meta-function  '(meta-insert-enclosure-new-line ignore "Insert beg/end passive structure in the line below.")
				     '(meta-insert-active-enclosure-new-line ignore "Isert beg/end active structure in the line below.")
                                     '(meta-new-line boon-newline-dwim "Insert new line."))
  (use-package boon
    :bind (:map boon-command-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line)
                :map boon-insert-map
		("<RET>" . meta-new-line)
                ("C-M-j" . meta-insert-enclosure-new-line)
                ("C-J" . meta-insert-active-enclosure-new-line))))


#+end_src
*** Do no yank with mouse, but use Shift-Ins to yank the primary selection
:PROPERTIES:
:ID:       88a3703a-21fe-47a1-9b8c-bce7fdb5d10a
:END:
#+begin_src emacs-lisp
;; (setq mouse-yank-at-point t)
(bind-key "<S-insert>" (lambda () (interactive)
			 (insert (gui-get-primary-selection))))
(bind-key "<mouse-2>" #'ignore)
#+end_src
*** Open files as root
:PROPERTIES:
:CREATED:  [2018-01-10 Wed 02:38]
:ID:       4229fb72-78fe-4848-b925-fb1f87f75fdf
:END:
:LOGBOOK:
- State "TODO"       from              [2018-01-10 Wed 02:41]
:END:
#+BEGIN_SRC emacs-lisp
(when init-flag
  ;; http://emacs.readthedocs.io/en/latest/file_management.html
  (defun yt/sudo-find-file (file-name)
    "Like find file, but opens the file as root."
    (interactive "FSudo Find File: ")
    (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
      (find-file tramp-file-name)))
  (use-package boon
    :defer t
    :bind (:map boon-forward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name))))
                :map boon-backward-search-map
		("M-f" . yt/sudo-find-file)
                ("M-S-f" . (lambda () (interactive) (yt/sudo-find-file (buffer-file-name)))))))
#+END_SRC
*** Move lines, elements around
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 15:00]
:ID:       61ed40af-8165-4ffa-9412-96d802bb8e18
:END:
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :config
  (meta-functions-add-meta-function '(meta-move-line-right ignore "Move the line under cursor right.")
				    '(meta-move-line-left ignore "Move the line under cursor left.")
				    '(meta-move-line-up move-text-line-up "Move the line under cursor up.")
				    '(meta-move-line-down move-text-line-down "Move the line under cursor down.")
				    '(meta-move-element-right ignore "Move the element under cursor right.")
				    '(meta-move-element-left ignore "Move the element under cursor left.")
				    '(meta-move-element-down move-text-down "Move the element under cursor down.")
				    '(meta-move-element-up move-text-up "Move the element under cursor up."))
  (use-package move-text
    :if init-flag
    :ensure t
    :bind (:map boon-command-map
		("M-j" . meta-move-line-down)
		("M-k" . meta-move-line-up)
		("M-J" . meta-move-element-down)
		("M-K" . meta-move-element-up)
		("M-O" . meta-move-element-right)
		("M-I" . meta-move-element-left)
		("M-o" . meta-move-line-right)
		("M-i" . meta-move-line-left)))
  :init (use-package boon))
#+END_SRC
** Debugging
*** No visible bell
:PROPERTIES:
:ID:       83e9e494-8646-4118-a574-b35026acd582
:END:
#+begin_src emacs-lisp 
(setq visible-bell nil)
#+end_src
*** Debug on error
:PROPERTIES:
:ID:       1b3bb071-a145-43ef-826a-25dacb4c5cc2
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2017-12-19 Tue 08:53]
:END:
#+begin_src emacs-lisp 
(setq debug-on-error t)
(setq debug-on-quit nil)
(setq debug-ignored-errors '(beginning-of-line
			     beginning-of-buffer
			     end-of-line
			     end-of-buffer
			     end-of-file
			     buffer-read-only
			     file-supersession
			     mark-inactive
			     user-error
                             search-failed
			     "Attempt to delete the sole visible or iconified frame"
                             "No such page"
                             "use-package: :[a-z]+ wants"
                             "The mark is not set now, so there is no region"
                             "Search string not set"
			     "use-package: Unrecognized keyword"
			     "No more buttons"
                             "No command bound to"
			     )
      )
#+end_src
*** Debugger key bindings
:PROPERTIES:
:ID:       cbca9cd1-9225-45b5-aa88-43ff09f128e5
:END:
#+begin_src emacs-lisp
(use-package debug
  :if init-flag
  :config
  (bind-key "s" #'debugger-continue debugger-mode-map))
#+end_src
** Programming & emacsing
*** Help
**** Show the continuation of unfinished keybindings
:PROPERTIES:
:ID:       af18cad7-734f-491f-85a8-1fc817cf2dbd
:END:
#+begin_src emacs-lisp
(use-package which-key
  :if init-flag
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+end_src
**** Help buffer navigation
:PROPERTIES:
:ID:       2bc3b25c-9754-4bce-a885-8d8b1300b6cc
:END:
#+begin_src emacs-lisp 
(use-package boon
  :defer t
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-next-buffer-alist '(help-mode . help-go-forward))
    (add-to-list 'meta-functions-meta-previous-buffer-alist '(help-mode . help-go-back))))
#+end_src
**** Info buffer navigation
:PROPERTIES:
:CREATED:  [2018-07-11 Wed 14:55]
:ID:       924cdc83-3ddc-4ef1-ae8d-8ca57682d389
:END:

#+begin_src emacs-lisp 
(use-package boon
  :defer t
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(Info-mode . Info-forward-node))
    (add-to-list 'meta-functions-meta-up-element-alist '(Info-mode . Info-backward-node))
    (add-to-list 'meta-functions-meta-new-line-alist '(Info-mode . Info-follow-nearest-node))
    (add-to-list 'meta-functions-meta-previous-buffer-alist '(Info-mode . Info-history-back))
    (add-to-list 'meta-functions-meta-next-buffer-alist '(Info-mode . Info-history-forward))
    ))
#+end_src

**** Symbol&info lookup
:PROPERTIES:
:ID:       e48bff0a-518d-4499-a62d-7003d203077a
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :bind (("<f1> l" . helm-locate-library))
  :init
  (use-package boon
    :defer t
    :config
    (bind-keys :map boon-goto-map
	       ("f" . helpful-function)
	       ("v" . helpful-at-point)
	       ("d" . helpful-variable)
	       ("s" . helpful-symbol)
	       ("h m" . woman)
               ("h i" . helm-info-elisp)
               ("h o" . helm-info-org)
               ("h e" . helm-info-emacs)
               ("h t" . helm-info-auctex)
               ("h t" . helm-info-texinfo))))


#+end_src
**** Man
:PROPERTIES:
:ID:       45d67bee-9fa3-4c00-8f48-2b41ed03ea46
:END:
#+begin_src emacs-lisp
(use-package woman
  :if init-flag
  :commands woman
  :config
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(woman-mode . Man-next-section))
    (add-to-list 'meta-functions-meta-up-element-alist '(woman-mode . Man-previous-section))))
#+end_src
**** Helpful - better help buffers
:PROPERTIES:
:CREATED:  [2018-03-29 Thu 23:16]
:ID:       00d36901-9a96-46c3-be8b-6fe5edd9c3c7
:END:
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :if init-flag
  :ensure t)
#+END_SRC
*** Execute current buffer (c++,python,bash,...)
:PROPERTIES:
:ID:       a57244bb-a617-44b4-a806-7cff82a86ac7
:END:
#+begin_src emacs-lisp 
(use-package quickrun
  :if init-flag
  :ensure t
  :bind (
	 ("<f10>" . quickrun)
	 ("<C-XF86Search>" . quickrun-with-arg)
	 ("<C-M-XF86Search>" . quickrun-shell)
	 ("<C-XF86Explorer>" . quickrun-region)
	 ("<C-M-XF86Explorer>" . quickrun-replace-region)
	 ("<f12>" . helm-quickrun)))
#+end_src
*** Improved interactive evaluation of elisp code
:PROPERTIES:
:CREATED:  [2018-07-14 Sat 00:42]
:ID:       08ca8dd5-a692-470f-97fd-5e46f8255a90
:END:
1. Evaluating Quoted Expressions
2. Evaluating Function Symbols
3. Redefining Variables
4. Default Expressions to Evaluate
5. Editing Default Expressions

[[https://github.com/rswgnu/rsw-elisp]]

#+BEGIN_SRC emacs-lisp
(use-package rsw-elisp
  :config
  (rsw-elisp-enable))
#+END_SRC

*** Gnuplot
:PROPERTIES:
:ID:       192254a2-dc90-4a29-a713-f43f794211f6
:END:
#+begin_src emacs-lisp
(use-package gnuplot
  :if (or init-flag org-export-flag)
  :ensure t
  :mode ("\\.\\(gp\\|gnuplot\\|plot\\)$" . gnuplot-mode))
#+end_src
** TODO LaTeX
*** Use =pdf-tools= to view resulting pdf
:PROPERTIES:
:ID:       a0515bfd-07df-418a-90a2-5515b1a4deb3
:END:
#+begin_src emacs-lisp
(setq TeX-view-program-list '(("pdf tools refresh" (lambda() (pdf-tools-install)
						     (TeX-pdf-tools-sync-view)))))
(setq TeX-view-program-selection '((output-pdf "pdf tools refresh")))
(setq TeX-source-correlate-start-server t)

(add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
	  'TeX-revert-document-buffer)

(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)

(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(diminish 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'variable-pitch-mode)
(diminish 'buffer-face-mode)
#+end_src
** Ledger
:PROPERTIES:
:ID:       a0cacc17-641c-4b29-86b2-7dcf609cd803
:END:
#+begin_src emacs-lisp
(use-package ledger-mode
  :if init-flag
  :ensure t
  :bind (:map boon-goto-map
	      ("z" . open-finance)
	      :map ledger-mode-map
	      ("M-n" . nil)
	      ("M-p" . nil)
	      ("C-c C-a" . ledger-add-transaction-and-boonedit))
  :config
  (defun open-finance()
    "Open ledger file."
    (interactive)
    (find-file "~/Finance/Singapore-PhD/Ledger.dat"))
  (defun ledger-add-transaction-and-boonedit ()
    "Switch to boon insert state when adding transaction."
    (interactive) 
    (call-interactively 'ledger-add-transaction) 
    (boon-set-insert-like-state))
  (setq ledger-reports
	'(("bal" "ledger --pedantic -f %(ledger-file) bal not Equity")
	  ("balsg" "ledger --pedantic -f %(ledger-file) bal not Equity -X S$")
	  ("balall" "ledger --pedantic -f %(ledger-file) bal not Equity:Opening")
	  ("reg" "ledger --pedantic --pending -f %(ledger-file) reg not Equity")
	  ("payee" "ledger --pedantic -f %(ledger-file) reg @%(payee)")
	  ("account" "ledger --pedantic -f %(ledger-file) reg %(account)")
	  ("budget" "ledger --pedantic -f %(ledger-file) bal --budget")
	  ("budgetsg" "ledger --pedantic -f %(ledger-file) bal --budget -X S$"))
	ledger-report-auto-refresh t)
  (use-package meta-functions
    :config
    (add-to-list 'meta-functions-meta-down-element-alist '(ledger-mode . ledger-navigate-next-xact-or-directive))
    (add-to-list 'meta-functions-meta-up-element-alist '(ledger-mode . ledger-navigate-prev-xact-or-directive))
    (meta-functions-update-function-definitions))
  )
#+end_src
** Wolfram Mathematica
:PROPERTIES:
:CREATED:  [2018-07-23 Mon 17:37]
:ID:       fbacbe1c-3e5c-47f0-9e2d-e6e5bde1fa5c
:END:
#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :if init-flag
  :ensure t
  )
#+END_SRC
** TODO Pdf view
:PROPERTIES:
:ID:       201475d1-64b3-4e1d-8e78-d850c6067761
:END:
#+begin_src emacs-lisp
  (use-package pdf-tools
    :if init-flag
    :ensure t
    :magic ("%PDF" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
		("v w" . pdf-view-fit-width-to-window)
		("v h" . pdf-view-fit-height-to-window))
    :hook ((pdf-view-mode . (lambda () (centered-window-mode -1))))
    :init
    (defun yant/pdf-view-down nil
      "Go down document in pdf-view."
      (interactive)
      (pdf-view-next-line-or-next-page 5))
    (defun yant/pdf-view-up nil
      "Go up document in pdf-view."
      (interactive)
      (pdf-view-previous-line-or-previous-page 5))
    (use-package pdf-annot)
    (use-package pdf-occur)
    (use-package pdf-history)
    (use-package pdf-links)
    (use-package pdf-outline)
    (use-package pdf-sync)
    (use-package pdf-isearch)
    (use-package pdf-cache)
    :config
    (pdf-tools-install)
    (add-hook 'pdf-view-mode-hook #'pdf-view-fit-width-to-window 'APPEND)
    (add-hook 'pdf-view-mode-hook #'pdf-tools-enable-minor-modes 'APPEND)
    (use-package meta-functions
      :config
      (add-to-list 'meta-functions-meta-down-alist '(pdf-view-mode . yant/pdf-view-down))
      (add-to-list 'meta-functions-meta-up-alist '(pdf-view-mode . yant/pdf-view-up))
      (add-to-list 'meta-functions-meta-scroll-down-alist '(pdf-view-mode . pdf-view-scroll-down-or-previous-page))
      (add-to-list 'meta-functions-meta-scroll-up-alist '(pdf-view-mode . pdf-view-scroll-up-or-next-page))
      (add-to-list 'meta-functions-meta-down-alist '(pdf-annot-list-mode . tablist-next-line))
      (add-to-list 'meta-functions-meta-up-alist '(pdf-annot-list-mode . tablist-previous-line)))
    (bind-keys :map pdf-view-mode-map
	       ("q" . (lambda() (interactive) (quit-window 'KILL)))))
#+end_src
*** Pdf rotate
:PROPERTIES:
:ID:       0ec2a69c-4284-48f2-86cb-4bac1f0a3b3f
:END:
#+begin_src emacs-lisp
(use-package pdf-tools
  :if init-flag
  :init
  (use-package pdf-view :demand t)
  (defun pdf-view--rotate (&optional counterclockwise-p page-p)
    "Rotate PDF 90 degrees.  Requires pdftk to work.\n
       Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
       non-nil for the other direction.  Rotate the whole document by
       default; set PAGE-P to non-nil to rotate only the current page.
       \nWARNING: overwrites the original file, so be careful!"
    ;; error out when pdftk is not installed
    (if (null (executable-find "pdftk"))
	(error "Rotation requires pdftk")
      ;; only rotate in pdf-view-mode
      (when (eq major-mode 'pdf-view-mode)
	(let* ((rotate (if counterclockwise-p "left" "right"))
	       (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
	       (page   (pdf-view-current-page))
	       (pages  (cond ((not page-p)                        ; whole doc?
			      (format "1-end%s" rotate))
			     ((= page 1)                          ; first page?
			      (format "%d%s %d-end"
				      page rotate (1+ page)))
			     ((= page (pdf-info-number-of-pages)) ; last page?
			      (format "1-%d %d%s"
				      (1- page) page rotate))
			     (t                                   ; interior page?
			      (format "1-%d %d%s %d-end"
				      (1- page) page rotate (1+ page))))))
	  ;; empty string if it worked
	  (if (string= "" (shell-command-to-string
			   (format (concat "pdftk %s cat %s "
					   "output %s.NEW "
					   "&& mv %s.NEW %s")
				   file pages file file file)))
	      (pdf-view-revert-buffer nil t)
	    (error "Rotation error!"))))))
  (defun pdf-view-rotate-clockwise (&optional arg)
    "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
       entire document."
    (interactive "P")
    (pdf-view--rotate nil (not arg)))
  (defun pdf-view-rotate-counterclockwise (&optional arg)
    "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
       rotate entire document."
    (interactive "P")
    (pdf-view--rotate :counterclockwise (not arg))))
#+end_src
** Utils
*** TODO Shell
**** Invokation
:PROPERTIES:
:ID:       1bdbe0fd-07db-483b-bf04-c9a6813ee351
:END:
#+begin_src emacs-lisp 
(use-package shell-pop
  :if init-flag
  :ensure t
  :bind ("M-<f9>" . shell-pop)
  :init
  (setq shell-pop-shell-type '("ansi-term" "*ansi-term*" (lambda () (ansi-term shell-pop-term-shell)))) 
  (setq shell-pop-window-position "right")
  :config
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+end_src
**** Interaction with boon
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 20:43]
:ID:       6027fccc-5e96-4c55-9e5a-12194caadefd
:END:
#+BEGIN_SRC emacs-lisp
(use-package meta-functions
  :if init-flag
  :config
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(term-mode . ignore))
  (add-to-list 'meta-functions-meta-new-line-alist '(term-mode . term-send-raw))
  (meta-functions-update-function-definitions))

#+END_SRC
*** Calc
:PROPERTIES:
:ID:       db607f5d-6270-4193-942a-c1f772a97ca6
:END:
#+begin_src emacs-lisp
(use-package calc
  :if init-flag
  :bind (:map boon-goto-map
	      ("c" . calc)))
#+end_src
*** Music
**** Mingus (mpd)
:PROPERTIES:
:ID:       dad9e1d1-308f-4706-900e-3ec546e6eb58
:END:
#+begin_src emacs-lisp
(use-package mingus
  :if init-flag
  :ensure t
  :bind (:map mingus-playlist-map
	      ("q" . (lambda() (interactive) (mingus-git-out) (delete-frame)))))
#+end_src
*** Printing
:PROPERTIES:
:ID:       7e2f9ad8-6c30-40db-bdbd-9ba3acd70b2a
:END:
#+begin_src emacs-lisp
(setq lpr-command "gtklp")
(setq lpr-add-switches "-C \"emacs-print\"")
(setq pdf-misc-print-programm "gtklp")
(setq pdf-misc-print-programm-args '("-C \"emacs-print\""))
#+end_src
** News & email
*** Elfeed
:PROPERTIES:
:ID:       9bc385e2-0ed2-460b-875e-be9ad19144a3
:END:
#+begin_src emacs-lisp
(use-package elfeed
  :if init-flag
  :ensure t
  :bind (:map elfeed-search-mode-map
	      ("q" . delete-frame)
	      ("r" . elfeed-search-update--force)
	      ("R" . elfeed-search-fetch)
	      ("t" . elfeed-search-untag-all-unread)
              ("T" . elfeed-search-tag-all-unread)
              ("b" . (lambda () (interactive)
		       (elfeed-search-tag-all 'opened)
		       (meta-up)
                       (elfeed-search-browse-url))))
  :init
  (setq elfeed-search-filter "+unread -video -science")
  (setq elfeed-sort-order 'ascending)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-date-format '("%d %b, %a, %H:%M" 20 :left))
  (unless (boundp 'elfeed-search-mode-hook) (setq elfeed-search-mode-hook nil))
  (add-hook elfeed-search-mode-hook (lambda () (setq truncate-lines t)))
  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Org/rss.org"))))
#+end_src
*** Notmuch
:PROPERTIES:
:ID:       f6ca2367-45c4-45bc-acec-49837cadc5ac
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :ensure t
  :config
  (use-package boon
    :config
    (defun yant/notmuch-show-view-html-part ()
      "Search and open html part of the message in the browser."
      (interactive)
      (notmuch-show-view-part))
    (use-package meta-functions
      :config
      (add-to-list 'meta-functions-meta-down-alist '(notmuch-search-mode . notmuch-search-next-thread))
      (add-to-list 'meta-functions-meta-up-alist '(notmuch-search-mode . notmuch-search-previous-thread))
      (add-to-list 'meta-functions-meta-down-element-alist '(notmuch-show-mode . notmuch-show-next-message))
      (add-to-list 'meta-functions-meta-up-element-alist '(notmuch-show-mode . notmuch-show-previous-message))
      (add-to-list 'meta-functions-meta-down-element-alist '(notmuch-search-mode . notmuch-search-show-thread))
      (add-to-list 'meta-functions-meta-up-element-alist '(notmuch-search-mode . ignore))
      (meta-functions-update-function-definitions)
      )
    (bind-keys :map notmuch-search-mode-map
	       ("r" . notmuch-refresh-this-buffer)
	       ("C-c C-u" . notmuch-search-unread)
	       ("C-c C-d" . notmuch-search-done)
               ("C-c C-f" . notmuch-search-nolist)
	       ("C-c C-S-d" . notmuch-search-delete)
	       :map notmuch-show-mode-map
	       ("v" . yant/notmuch-show-view-html-part)
	       ("J" . notmuch-show-next-message)
	       ("K" . notmuch-show-previous-message)
	       ("C-c C-u" . notmuch-show-unread)
	       ("C-c C-d" . notmuch-show-done)
               ("C-c C-f" . notmuch-show-nolist)
	       ("C-c C-S-d" . notmuch-show-delete))))
#+end_src
**** Sendmail setup
:PROPERTIES:
:ID:       48f4a6a2-a480-4d4f-9ad4-99da5667a15f
:END:
- multiple accounts
  #+begin_src emacs-lisp
;;autochoose account name for msmtp
(defun cg-feed-msmtp ()
  (if (message-mail-p)
      (save-excursion
	(let* ((from (save-restriction
		       (message-narrow-to-headers)
		       (message-fetch-field "from")))
	       (account (cond
			 ;; I use email address as account label in ~/.msmtprc
			 ((string-match "yantar92@gmail.com" from) "yantar92@gmail.com")
			 ((string-match "ihor_radchenko@mymail.sutd.edu.sg" from) "ihor_radchenko@mymail.sutd.edu.sg"))))
	  (setq message-sendmail-extra-arguments (list '"-a" account)))))) ; the original form of this script did not have the ' before "a" which causes a very difficult to track bug --frozencemetery
(add-hook 'message-send-mail-hook 'cg-feed-msmtp)
(setq message-sendmail-envelope-from 'header)
(setq mail-specify-envelope-from 't)
(setq mail-envelope-from 'header)
(setq message-make-forward-subject-function 'message-forward-subject-fwd)
(setq notmuch-fcc-dirs '(("ihor_radchenko@mymail.sutd.edu.sg" . "Office365/Sent +sent -unread")
			 ("yantar92@gmail.com" . "Gmail/Sent +sent -unread")))
  #+end_src
- automatic email signing
  #+begin_src emacs-lisp
(setq mml-default-sign-method "pgp")
(setq notmuch-crypto-process-mime t)
(add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)
  #+end_src
- async mail sending 
*************** TODO Make it work
*************** END

#+BEGIN_SRC emacs-lisp
;; (use-package async
;;   :if init-flag
;;   :ensure t
;;   :config
;;   (use-package smtpmail-async
;;     :ensure nil
;;     :config
;;     (setq message-send-mail-function 'message-send-mail-with-sendmail)))
#+END_SRC
**** Search via helm
:PROPERTIES:
:ID:       9d973bbc-f8ce-4c35-87e5-67c6a3bebe49
:END:
#+begin_src emacs-lisp
(use-package helm
  :if init-flag
  :defer t
  :config
  (use-package helm-notmuch
    :ensure t))
#+end_src
**** Tagging of sent messages
:PROPERTIES:
:ID:       42f1433a-3c25-47d4-b81a-76579130a611
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (bind-key  "C-c C-c"
	     (lambda()
	       (interactive)
	       (notmuch-mua-send-and-exit)
	       (start-process "Update tags"
			      nil
			      "/home/yantar92/bin/notmuch-new-messages-list-silent.sh"))
	     notmuch-message-mode-map))
#+end_src
**** Tagging functions
:PROPERTIES:
:ID:       54d9479f-a0a4-456f-bf4b-7adc2812c17b
:END:
#+begin_src emacs-lisp
(defun notmuch-show-delete () 
  (interactive) 
  (notmuch-show-tag-message "+deleted" "-inbox" "-todo" "-listinbox"))
(defun notmuch-show-unread()
  (interactive)
  (notmuch-show-tag-message "+unread"))
(defun notmuch-show-nolist()
  (interactive)
  (notmuch-show-tag-message "+inbox" "-listinbox"))
(defun notmuch-show-done()
  (interactive)
  (notmuch-show-tag-message "-todo" "-inbox" "-listinbox"))
(defun notmuch-search-delete () 
  (interactive) 
  (notmuch-search-tag '("+deleted" "-inbox" "-todo" "-listinbox")))
(defun notmuch-search-unread()
  (interactive)
  (notmuch-search-tag '("+unread")))
(defun notmuch-search-done()
  (interactive)
  (notmuch-search-tag '("-todo" "-inbox" "-listinbox")))
(defun notmuch-search-nolist()
  (interactive)
  (notmuch-search-tag '("+inbox" "-listinbox")))
#+end_src
**** Quit frame instead of bury buffer
:PROPERTIES:
:ID:       b87ec258-7b7e-4898-b828-ab8be4d474f9
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defvar-local notmuch-frame nil
    "Non nil means that frame was invoked from system (not from inside emacs).")
  (defadvice notmuch-refresh-this-buffer (around update-notmuch-frame activate)
    "Preserve `notmuch-frame' value after refresh."
    (let ((notmuch-frame-old notmuch-frame))
      ad-do-it
      (setq notmuch-frame notmuch-frame-old)))
  (bind-key "q" (lambda()
		  (interactive)
		  (if notmuch-frame
		      (delete-frame)
		    (notmuch-bury-or-kill-this-buffer)))
	    notmuch-search-mode-map)
  (bind-key  "q"
	     'notmuch-bury-or-kill-this-buffer
	     notmuch-show-mode-map))
#+end_src
**** Inline display
:PROPERTIES:
:ID:       47d58119-8dc4-48e2-b3c3-81cc955242fc
:END:
- inline view
- html renderer
  #+begin_src emacs-lisp
(custom-set-variables
 '(mm-external-terminal-program "urxvt")
 '(mm-inline-large-images-proportion 0.4)
 '(mm-inline-media-tests
   (quote
    (("image/p?jpeg" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote jpeg)
	 handle)))
     ("image/png" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote png)
	 handle)))
     ("image/gif" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote gif)
	 handle)))
     ("image/tiff" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote tiff)
	 handle)))
     ("image/xbm" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xbm)
	 handle)))
     ("image/x-xbitmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xbm)
	 handle)))
     ("image/xpm" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xpm)
	 handle)))
     ("image/x-xpixmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote xpm)
	 handle)))
     ("image/bmp" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote bmp)
	 handle)))
     ("image/x-portable-bitmap" mm-inline-image
      (lambda
	(handle)
	(mm-valid-and-fit-image-p
	 (quote pbm)
	 handle)))
     ("text/plain" mm-inline-text identity)
     ("text/enriched" mm-inline-text identity)
     ("text/richtext" mm-inline-text identity)
     ("text/x-patch" mm-display-patch-inline identity)
     ("text/x-diff" mm-display-patch-inline identity)
     ("application/emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-shellscript" mm-display-shell-script-inline identity)
     ("application/x-sh" mm-display-shell-script-inline identity)
     ("text/x-sh" mm-display-shell-script-inline identity)
     ("application/javascript" mm-display-javascript-inline identity)
     ("text/dns" mm-display-dns-inline identity)
     ("text/x-org" mm-display-org-inline identity)
     ("text/html" mm-inline-text-html
      (lambda
	(handle)
	mm-text-html-renderer))
     ("text/x-vcard" mm-inline-text-vcard
      (lambda
	(handle)
	(or
	 (featurep
	  (quote vcard))
	 (locate-library "vcard"))))
     ("message/delivery-status" mm-inline-text identity)
     ("message/rfc822" mm-inline-message identity)
     ("message/partial" mm-inline-partial identity)
     ("message/external-body" mm-inline-external-body identity)
     ("text/.*" mm-inline-text identity)
     ("application/x-.?tar\\(-.*\\)?" ignore identity)
     ("application/zip" ignore identity)
     ("audio/wav" mm-inline-audio
      (lambda
	(handle)
	(and
	 (or
	  (featurep
	   (quote nas-sound))
	  (featurep
	   (quote native-sound)))
	 (device-sound-enabled-p))))
     ("audio/au" mm-inline-audio
      (lambda
	(handle)
	(and
	 (or
	  (featurep
	   (quote nas-sound))
	  (featurep
	   (quote native-sound)))
	 (device-sound-enabled-p))))
     ("application/pgp-signature" ignore identity)
     ("application/x-pkcs7-signature" ignore identity)
     ("application/pkcs7-signature" ignore identity)
     ("application/x-pkcs7-mime" ignore identity)
     ("application/pkcs7-mime" ignore identity)
     ("multipart/alternative" ignore identity)
     ("multipart/mixed" ignore identity)
     ("multipart/related" ignore identity)
     ("image/.*" mm-inline-image
      (lambda
	(handle)
	(and
	 (mm-valid-image-format-p
	  (quote imagemagick))
	 (mm-with-unibyte-buffer
	   (mm-insert-part handle)
	   (let
	       ((image
		 (ignore-errors
		   (if
		       (fboundp
			(quote create-image))
		       (create-image
			(buffer-string)
			(quote imagemagick)
			(quote data-p))
		     (mm-create-image-xemacs
		      (mm-handle-media-subtype handle))))))
	     (when image
	       (setcar
		(cdr handle)
		(list "image/imagemagick"))
	       (mm-image-fit-p handle)))))))
     ("audio/.*" ignore ignore)
     ("image/.*" ignore ignore)
     (".*" mm-inline-text mm-readable-p))))
 '(mm-inlined-types
   (quote
    ("text/calendar" "image/.*" "text/.*" "message/delivery-status" "message/rfc822" "message/partial" "message/external-body" "application/emacs-lisp" "application/x-emacs-lisp" "application/pgp-signature" "application/x-pkcs7-signature" "application/pkcs7-signature" "application/x-pkcs7-mime" "application/pkcs7-mime" "application/pgp")))
 '(mm-text-html-renderer (quote w3m))

 '(send-mail-function (quote sendmail-send-it))
 )
(setq mm-text-html-renderer-alist '((shr . mm-shr)
				    (w3 . mm-inline-text-html-render-with-w3)
				    (w3m . mm-inline-text-html-render-with-w3m)
				    (w3m-standalone . mm-inline-text-html-render-with-w3m-standalone)
				    (gnus-w3m . gnus-article-html)
				    (links mm-inline-render-with-file mm-links-remove-leading-blank "links" "-dump" file)
				    (lynx mm-inline-render-with-stdin nil "qutebrowser-call.sh")
				    (html2text mm-inline-render-with-function html2text)))
;; Inline images?
(setq mm-attachment-override-types '("image/.*"))
;; No HTML mail
(setq mm-discouraged-alternatives '("text/html" "text/richtext" "text/rtf" "application/zip" "image/vnd.djvu" "application/x-dvi" "application/postscript" ))
;; Don't start a browser for text/html only mail
(setq mm-automatic-display
      '("text/plain" "text/enriched"
	"image/.*" "message/delivery-status" "message/rfc822"
	"text/x-patch" "application/pgp-signature" "application/emacs-lisp"))
(setq mm-inline-large-images 'resize)
  #+end_src
**** Notmuch hello
:PROPERTIES:
:ID:       645a5628-289a-4373-9668-b79e10738215
:END:
#+begin_src emacs-lisp
(setq notmuch-hello-sections '(notmuch-hello-insert-header notmuch-hello-insert-saved-searches
                                                           notmuch-hello-insert-alltags)
      notmuch-saved-searches '((:name "todo" :query "tag:todo and tag:inbox" :sort-order newest-first)
			       (:name "work" :query "tag:todo or tag:inbox and not tag:private" :sort-order newest-first)
			       (:name "inbox" :query "tag:inbox" :key "i" :sort-order newest-first)
			       (:name "all mail" :query "*" :key "a")))
#+end_src
**** TODO Show accept/decline buttons for calendar invitations
:PROPERTIES:
:ID:       1735faf3-9249-43bd-ae32-8f30500210fe
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (use-package notmuch-calendar-x))
#+end_src
**** TODO Interaction with org
***** Capture mail to org task
:PROPERTIES:
:ID:       2d9b8481-b46c-47a9-9d19-6408c6a1e82d
:END:
#+begin_src emacs-lisp
(use-package notmuch
  :if init-flag
  :defer t
  :config
  (defun bh/capture-mail()
    "Capture mail to org mode."
    (interactive)
    (org-store-link nil)
    (org-capture nil "e")
    )
  (bind-key "t" 'bh/capture-mail notmuch-show-mode-map))
#+end_src
***** Org mode list functionality when writing messages
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 16:16]
:ID:       119b23b6-1881-4446-847d-7baffbfc2c89
:END:
#+begin_src emacs-lisp
(use-package org
  :if init-flag
  :ensure org-plus-contrib
  :pin org
  :defer t
  :config
  (add-hook 'message-mode-hook 'turn-on-orgstruct++))
#+end_src

** Org mode
:PROPERTIES:
:ID:       58045c39-ffd5-4ccc-bc9d-49048c437f42
:END:
This config is inspired by [[http://doc.norang.ca/org-mode.html][Bernt Hansen's config]].
*************** TODO Describe the workflow
*************** END
#+begin_src emacs-lisp
  (use-package org
    :if (or init-flag org-export-flag)
    :ensure org-plus-contrib
    :pin org
    :mode ("\\.org$" . org-mode)
    :diminish (org-mode . (all-the-icons-icon-for-mode org-mode))
    :init (use-package all-the-icons :ensure t)
    :config
#+end_src
*** Project management
:PROPERTIES:
:ID:       8cef1ba5-d5ea-4ad1-955b-932952c77b0c
:END:
I need to deal with many projects running at the same time in my work. Hence, I need some good structure for all these projects to keep track of deadlines, have all the notes to be able to recall what is going on in the project after some time. 
**** Tags
***** General org mode tags
:PROPERTIES:
:ID:       adc6f5ae-183f-4c5f-97e8-7bfe18f028d2
:END:
#+begin_src emacs-lisp
(setq org-tag-alist (quote (("COMMON" . ?c)
			    ("PhD" . ?p)
			    ("INBOX" . ?i)
			    ("TRACK" . ?t)
			    ("BOOKMARK" . ?b)
			    ("ORG" . ?o)
			    ("NOEXPORT" . ?n)
			    ("NODEADLINE" . ?d)
			    ("SKIP" . ?s)
                            ("NOARCHIVE" . ?a)
                            ("NOCLOCK" . ?k)
			    ("ignore" . ?g))))
#+end_src
- =COMMON= :: General task
- =PhD= :: Related to work/PhD
- =INBOX= :: Need to be processed (for new captured tasks)
- =TRACK= :: The link from this task/item should be monitored for changes in the internet
*************** TODO Need to add automatic handling of this
:PROPERTIES:
:ID:       27eb85b6-114f-437f-9424-b28d400f6aa9
:END:
*************** END
- =BOOKMARK= :: Contains link
*************** TODO add link management system
*************** END
- =ORG= :: if the task is not finished - include the org file linked during agenda creation if todo keyword is =NEXT=.
           The purpose of this tag is reduce the file size: I had a large database of books, which I've read/will read. The file with all the authors included was more than =2Mb=, which
           took forever to open and, more importantly, made my agenda view build/update time *few minutes*. So, I created separate project for different authors and kept the links to that
           projects with =ORG= tag assigned, so that I can add the author book list to file/agenda view if the project is =NEXT=.
*************** NEXT need to implement this
:PROPERTIES:
:ID:       648e5339-0732-4464-80de-90a8f5f72467
:END:
Text properties: =modification-hooks=, =insert-in-front-hooks=, =insert-behind-hooks=
*************** END
- =NOEXPORT= :: Do not export an item
- =NODEADLINE= :: Do not show these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view 
- =SKIP= :: Some projects contains tasks, which can be done independently on each other. I want to see these tasks in "All other tasks" part of my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view even if the projects they belongs to has =NEXT= tasks.  
- =NOARCHIVE= :: Do not archive a task. This in not inherited.
- =ARCHIVE= :: Prevent task from unfolding (e.g. task contains bulky data, I do not want to see) 
- =NOCLOCK= :: prevent entry from being clocked in automatically (after child task clock out [[id:d1afb1ae-a3a4-45b4-8186-8e7242e0edc1][Clocking & logging]]). This is not inherited. 
***** TODO Tags for everything
***** TODO try to implement multiple files/buffers in the same buffer via text properties like modification hooks |- (Special Properties - GNU Emacs Lisp Reference Manual) :BOOKMARK:
:PROPERTIES:
:CREATED: [2018-02-12 Mon 00:51]
:Source: https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html#Special-Properties
:END:
:LOGBOOK:
CLOCK: [2018-02-12 Mon 00:51]--[2018-02-12 Mon 00:52] =>  0:01
:END:
modified b
****** TODO may be useful |- (multifiles.el/multifiles.el at master · magnars/multifiles.el) :BOOKMARK:
:PROPERTIES:
:CREATED: [2018-02-12 Mon 00:56]
:Source: https://github.com/magnars/multifiles.el/blob/master/multifiles.el
:END:
fun create-or
**** Tasks
:PROPERTIES:
:ID:       d38441a2-1431-44db-b831-8cdec011b1dc
:END:
The task is any item with todo keyword and no subtask.
  #+begin_src emacs-lisp
(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (member (org-get-todo-state) org-todo-keywords-1)
	    (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
  #+end_src
- keywords for not done tasks: =TODO=, =NEXT=, =WAITING=, =HOLD=, =CANCELLED=, =DONE=, =FAILED=, =MERGED=
  #+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t!)" "NEXT(n!)" "|" "DONE(d!)" "FAILED(f@/!)" "MERGED(m!)" )
	      (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" ))))
;; set the tags assigned to specific keywords. Not nesessary, but used by a lot of code for filtering later - hence why not
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
	      ("WAITING" ("WAITING" . t))
	      ("HOLD" ("WAITING") ("HOLD" . t))
	      (done ("WAITING") ("HOLD"))
	      ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))
	      ("FAILED" ("WAITING") ("CANCELLED") ("HOLD"))
	      )))
  #+end_src
  - TODO(t) :: task which needs to be done
  - NEXT(n) :: Task which needs to be done next. If the task is scheduled it is most likely need to be done next. Though can change manually to =TODO= if needed. 
            #+begin_src emacs-lisp
(define-advice org-schedule (:after (&optional ARG TIME) change-todo-after-schedule-state-change) 
  "Make sure that task keyword is always TODO when it is not scheduled and NEXT if it is."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components))))
	(isscheduled (org-agenda-skip-entry-if 'scheduled)))
    (if (not isscheduled)
	(when (member mystate (list "NEXT"))
	  (org-todo "TODO"))
      (when (member mystate (list "TODO"))
	(org-todo "NEXT")))))
            #+end_src
  - WAITING(w) :: I am waiting for someone/something which does not depend on me to start the task (should add comment about reason) 
  - HOLD(h) :: I am not going to do this task for now due to reason explained in the comment
  - CANCELLED(c) :: I will never do this task because of what is in the comment
  - DONE(d) :: self explanatory
  - FAILED(f) :: there is some outcome and can mark done, but the outcome is not positive, though can get some conclusions out of it 
  - MERGED(m) :: become a part of other task. The link to the task is added to =MERGED-WITH= property. The motivation of adding this state is that I sometimes create a duplicate task, find out that it is duplicate, and confused which state to set. It is just faster to
                 set =MERGED= without deciding if it is =CANCELLED= (which is not really) or =DONE= (which is also not).
*************** TODO Prompt for the link to new task, default is clocked in task. Use helm search. Store link in property
*************** END
**** Inline tasks
:PROPERTIES:
:ID:       54ee8e08-0cb5-4104-94c2-948be5830c4e
:END:
I use inline tasks to add temporary todo state (instead of notes). It should be removed once done and placed into notes when archiving.
*************** TODO Implement this on inline task done
*************** END
#+begin_src emacs-lisp
(use-package org-inlinetask)
(setq org-inlinetask-default-state "TODO")
#+end_src
**** TODO Task inheritance
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 06:10]
:ID:       d982166c-a450-4625-8211-ded63dc03f2d
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 17:59]
:END:
Some of the tasks cannot be done until some condition is met. Before that, it does not make too much sense to show it in agenda. 
I use [[http://www.nongnu.org/org-edna-el/][org-edna]] for managing dependencies. On top of blocked tasks management, it allows to schedule tasks on trigger. It introduces two new properties: =TRIGGER= and =BLOCKER= (see [[id:598c2b16-2eb8-404a-b7e9-00969a1c4d72][Properties]] for details)
#+BEGIN_SRC emacs-lisp
(use-package org-edna
  :ensure t
  :config
  (org-edna-load))
#+END_SRC
Also, the projects require all the children to be done by default.
  #+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
  #+end_src
**** Habits
:PROPERTIES:
:ID:       fa036b84-f68e-485b-943c-d5d9ad79c516
:END:
Habits are regular tasks which are treated specially in agenda to show if I missed it.
#+begin_src emacs-lisp
(use-package org-habit)
(setq org-habit-graph-column 120)
#+end_src
Allow checklists to be reset in recurring tasks when =:RESET_CHECK_BOXES:= is =t=
#+begin_src emacs-lisp
(use-package org-checklist
  :config
  (add-to-list 'org-default-properties "RESET_CHECK_BOXES"))
#+end_src
**** Projects
:PROPERTIES:
:ID:       3edce153-2927-4a2d-8b45-87d9a6151913
:END:
The project is an item with todo keyword and subtask.
#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask."
  (save-restriction
    (widen)
    (let ((has-subtask)
	  (subtree-end (save-excursion (org-end-of-subtree t)))
	  (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
	(forward-line 1)
	(while (and (not has-subtask)
		    (< (point) subtree-end)
		    (re-search-forward "^\*+ " subtree-end t))
	  (when (member (org-get-todo-state) org-todo-keywords-1)
	    (setq has-subtask t))))
      (and is-a-task has-subtask))))
#+end_src
This approach is useful in the case if I place some todo under the wrong item during refiling. It will appear in the project list in such a case. Project cannot be =DONE= if any of subtasks is =TODO=, =NEXT=, =WAITING= or =HOLD= (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
***** Top level project
:PROPERTIES:
:ID:       aa2f80d5-d05c-418f-ac41-e1c6a138afcb
:END:
The project without parent projects.
#+begin_src emacs-lisp
(defun bh/find-project-task ()
  "Move point to the parent (project) task if any."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))
(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
			      (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
	  nil
	t))))
#+end_src

***** Sub-project
:PROPERTIES:
:ID:       32faf7a0-7af7-4bd9-973b-814549420e07
:END:
The project with parent projects.
#+begin_src emacs-lisp
(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
	(is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
	(when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	  (setq is-subproject t))))
    (and is-a-task is-subproject)))
#+end_src
- if any task below is =NEXT= and the project is =TODO= then need to change to =NEXT= (it means that we need to do some task from this sub-project next) 
  #+begin_src emacs-lisp
(defun yant/mark-todo-parent-tasks-next ()
  "Visit each parent task and change TODO states to NEXT."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components)))))
    (when (member mystate (list "NEXT"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
	    (if (bh/is-subproject-p)
		(org-todo "NEXT")
	      (org-todo "NEXT"))))))
    (when (member mystate (list "TODO"))
      (save-excursion
	(while (org-up-heading-safe)
	  (when (member (nth 2 (org-heading-components)) (list "DONE"))
	    (org-todo "TODO")))))))
(add-hook 'org-after-todo-state-change-hook 'yant/mark-todo-parent-tasks-next 'append)
  #+end_src
***** TODO Standard projects
*** TODO Files
:PROPERTIES:
:ID:       f1be655e-5fc4-44b5-8197-22ce9457e489
:END:
- TODO.org :: store new entries, general home and work entries, want todo some time entries
              #+begin_src emacs-lisp
(defun gtd-open ()
  (interactive)
  (find-file "~/Org/TODO.org"))
              #+end_src
- notes.org :: all kind of generally useful information
              #+begin_src emacs-lisp
(defun notes-open ()
  (interactive)
  (find-file "~/Org/notes.org"))
              #+end_src
- articles.org :: notes on research articles
- rss.org :: rss entries for [[id:9bc385e2-0ed2-460b-875e-be9ad19144a3][Elfeed]]
- *.org :: project specific entries
- all of it is in =agenda_files=
- we can add new org files and remove existing
#+begin_src emacs-lisp
(defun add-buffer-to-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (end-of-buffer)
	  (newline)
	  (insert file_name)
	  (message "%S is added to agenda_files" file_name)
	  )
	(when pos
	  (message "%S is already in agenda_files" file_name))
	)
      )
    )
  )
(defun add-current-buffer-to-agenda-files ()
  (interactive)
  (add-buffer-to-agenda-files (current-buffer))
  )
(defun remove-buffer-from-agenda-files (buffer)
  (let ((file_name (buffer-file-name buffer)))
    (with-temp-file "~/Org/agenda_files"
      (interactive)
      (insert-file-contents "~/Org/agenda_files")
      (beginning-of-buffer)
      (let ((pos (search-forward file_name nil 't)))
	(when (not pos)
	  (message "%S is not in agenda_files" file_name))
	(when pos
	  (beginning-of-buffer)
	  (delete-matching-lines file_name)
	  (message "%S is deleted from agenda_files" file_name)
	  )
	)
      )
    )
  )
(defun remove-current-buffer-from-agenda-files ()
  (interactive)
  (remove-buffer-from-agenda-files (current-buffer))
  )
#+end_src
*** Links
**** External
:PROPERTIES:
:ID:       e74697d9-3d3e-4db4-8a4c-e9cad8f73d23
:END:
***** External apps
:PROPERTIES:
:ID:       2fe2cfaf-3ad4-4b87-99b1-2897e7c0bf20
:END:
Adjust some of the external application programs
#+begin_src emacs-lisp
(setq org-file-apps '((auto-mode . emacs)
		      ("\\.mm\\'" . default)
		      ("\\.x?html?\\'" . default)
		      ("\\.pdf\\'" . default)
		      ("\\.mp4\\'" . "mpv %s")
		      ("\\.tiff?\\'" . "/home/yantar92/bin/feh-open %s")
		      ("\\.png?\\'" . "/home/yantar92/bin/feh-open %s")
		      )
      )
#+end_src
***** =Pdf-view= links
:PROPERTIES:
:ID:       f6b6301d-6ccb-4ee1-a454-ca6f5af845ea
:END:
Store links to pages in pdf
#+begin_src emacs-lisp
(use-package org-pdfview
  :if init-flag
  :ensure t)
(add-to-list 'org-file-apps '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))
#+end_src
***** TODO Links to attached files
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 21:46]
:ID:       1460419f-52b8-4687-955c-936a1f99ae7c
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-23 Mon 15:33]
- State "TODO"       from              [2018-07-10 Tue 22:49]
CLOCK: [2018-07-09 Mon 21:47]--[2018-07-09 Mon 23:02] =>  1:15
- State "TODO"       from              [2018-07-09 Mon 21:47]
:END:

I have symlinks to the attached files stored in the directory tree mimicking org file structure (see [[id:9361bc68-010b-45f1-bddd-4638d6344758][Store files in folder structure, following my org tree structure]])
However, they are moved upon refiling. 
Hence, it is better to avoid symlinks in =file= links to the attached files.
I achieve it by forcing the path in =file= links to not contain symlinks /via/ advising [[file:/usr/share/emacs/26.1/lisp/files.el::(defun%20abbreviate-file-name%20(filename)][abbreviate-file-name]], which is called during the =file= link storing in [[file:/usr/share/emacs/site-lisp/org-mode/org.el::(defun%20org-store-link%20(arg)][org-store-link]].

#+BEGIN_SRC emacs-lisp :tangle no
(define-advice abbreviate-file-name (:filter-args (filename) readlink-on-filepath)
  "Process all the filepaths with readlink command to avoid symlinks."
  (pcase filename
    ((pred stringp)
     (let* (
	    (result (and (f-exists-p filename)
			 (shell-command-to-string (format "readlink -qmn '%s'" (expand-file-name filename))))))
       (if (seq-empty-p result)
	   filename
	 (if (f-directory-p result)
             (file-name-as-directory result)
           result))))
    ((pred listp)
     (mapcar #'abbreviate-file-name@readlink-on-filepath filename))
    (_ filename)))
#+END_SRC

**** Internal
:PROPERTIES:
:ID:       5aebc1b8-8d85-4254-b177-c216c053e8f3
:END:
#+begin_src emacs-lisp
(use-package org-id)
(setq org-id-method (quote uuidgen))
(setq org-id-link-to-org-use-id 't)
#+end_src
**** TODO Org-ref
:PROPERTIES:
:ID:       f944c2c8-f1fa-49ea-ab24-bf1b018013f1
:END:
:LOGBOOK:
- State "TODO"       from              [2018-03-12 Mon 18:04]
:END:
#+begin_src emacs-lisp
(use-package org-ref
  :if init-flag
  :ensure t
  :config
  (setq org-latex-prefer-user-labels t)
  (use-package org-ref-pdf)
  (use-package org-ref-url-utils)
  (setq org-ref-bibliography-notes "~/Books/articles/articles.org"
	bibtex-completion-notes-path "~/Books/articles/articles.org"
	org-ref-default-bibliography '("~/Books/References.bib")
	org-ref-pdf-directory "~/Books/articles/_symlinks/"
        bibtex-completion-library-path org-ref-pdf-directory
	org-ref-note-title-format "** TODO [%A] %t\n    :PROPERTIES:\n    :Custom_ID: %k\n    :AUTHOR: %9a\n    :JOURNAL: %j\n    :YEAR: %y\n    :VOLUME: %v\n    :PAGES: %p\n    :DOI: %D\n    :URL: %U\n    :END:\n    ")
  (setq reftex-default-bibliography (quote ("~/Books/References.bib")))
  (bind-key* "C-c ]" #'org-ref-helm-insert-cite-link)
  (bind-keys :map org-mode-map
	     ("C-c [" . org-ref-helm-insert-ref-link))
  (bind-keys :map bibtex-mode-map ("C-c [" . helm-bibtex))
  (bind-keys :map pdf-view-mode-map ("C-c [" . org-ref-pdf-to-bibtex)))
#+end_src 
*** TODO Properties
:PROPERTIES:
:ID:       598c2b16-2eb8-404a-b7e9-00969a1c4d72
:END:
#+begin_src emacs-lisp 
(setq org-use-property-inheritance 't)
#+end_src
- =:SHOWFROMTIME:= (always inheriting) :: The purpose of this is to be able to assign specific projects for different days of week or, say, show the home items only in the evening of weekdays and not annoy it at work when I cannot do it any way. Hence, I can focus on the items I really need to do now in this agenda. 
     #+begin_src emacs-lisp
(add-to-list 'org-default-properties "SHOWFROMTIME")
(defun org-agenda-skip-before-SHOWFROMTIME-property ()
  "Skip agenda item if :SHOWFROMTIME: property is set and time of day is before it"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (let ((showfromtime (parse-time-string (or (org-entry-get (point) "SHOWFROMTIME" 'inherit)
						 "00:00:01")))
	    (currenttime (parse-time-string (format-time-string "%T"))))
	(if (< (nth 2 currenttime) (nth 2 showfromtime))
	    next-headline
	  (if (< (nth 1 currenttime) (nth 1 showfromtime))
	      next-headline
	    (if (< (nth 0 currenttime) (nth 0 showfromtime))
		next-headline
	      nil)))))))
     #+end_src
- =:SHOWDATES:= (always inheriting) :: It contains dairy =sexps= to set when the project should be shown. For example, I may want to work on Saturday once or twice, but the working items should not be shown on weekend normally. Hence, I can define it. Or some things can only be done on specific dates (say, going to some shop, which is open few days a week only) 
     #+begin_src emacs-lisp
(add-to-list 'org-default-properties "SHOWDATES")
(defun org-agenda-skip-noshowdates()
  "Skip agenda item if :SHOWDATES: property sexp is not matching today"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	  (entry (org-entry-get (point) "SHOWDATES" 'inherit))
	  (date (diary-make-date (nth 4 (decode-time)) (nth 3 (decode-time)) (nth 5 (decode-time)))))
      (let ((result (and entry (pcase (eval (car (read-from-string entry)))
				 ((and (pred listp) res)
				  (cdr res))
				 (res res)))))
	(if (and entry (not result))
	    next-headline
	  nil)))))

(defun yant/daysofweek (&rest days)
  "Return 't if any of the listed weekdays (Mon, Tue, Wed, Thu, Fri, Sat, Sun) is today. Work only in the context of :SHOWDATES: property."
  (let ((data (list
	       (if (member "Mon" days) '(7 7 24 2017) nil)
	       (if (member "Tue" days) '(7 7 25 2017) nil)
	       (if (member "Wed" days) '(7 7 26 2017) nil)
	       (if (member "Thu" days) '(7 7 27 2017) nil)
	       (if (member "Fri" days) '(7 7 28 2017) nil)
	       (if (member "Sat" days) '(7 7 29 2017) nil)
	       (if (member "Sun" days) '(7 7 30 2017) nil))))
    (some #'(lambda (&rest args) (apply #'diary-cyclic (car args))) (remove nil data))))
     #+end_src
- =:CREATED:= :: Entry creation time. Inserted for all the new headings.
  #+BEGIN_SRC emacs-lisp
(defun yant/insert-heading-created-property (&optional time)
  "Add :CREATED: property to the task at point and set it to current time.
The property is set to TIME if it is supplied."
  (org-set-property "CREATED" (with-temp-buffer (org-insert-time-stamp time t t))))
(add-hook 'org-insert-heading-hook 'yant/insert-heading-created-property 'append)
  #+END_SRC
- =:BLOCKER:= :: Conditions to be met before allowing the entry to be
                 marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]]) 
- =:TRIGGER:= :: Actions to be done when the item is marked done (see [[id:d982166c-a450-4625-8211-ded63dc03f2d][Task inheritance]])
- =:MERGED-WITH:= :: If the task is marked =MERGED=, contains a link to the new task  
- =:SOURCE:= :: The link to the file/URL, which this task refers to
*** NEXT Attach
:PROPERTIES:
:ID:       bb8263f5-8ef4-4444-941c-9ffbb338185d
:END:
#+begin_src emacs-lisp
(use-package org-attach
:config
(setq org-attach-method 'mv)
(setq org-attach-store-link-p 't)
(setq org-attach-directory "~/.data/")
#+end_src
I usually have a huge numbers of files, related to the project. I would like to use attach to associate the files with the proper entry, but searching them later in my Dropbox is a pain because of the way, Org saves the attachments. 
It makes more sense for me to make attachments follow the org tree structure in the project by default (unless I change the attach folder to something else). 

**** TODO Store files in folder structure, following my org tree structure
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:11]
:ID:       9361bc68-010b-45f1-bddd-4638d6344758
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"          [2018-01-01 Mon 13:17]
:END:

This can be done if we make attachment by creating a symbolic link to the attach folder in the place, according to the headline path.
This way allows to keep all the file attached to the project accessible with relative paths.

*************** TODO I do not handle the situation when the entry uid is being changed.. 
Try to look in symlinks?
*************** END

*************** TODO refiling tasks is not moving the attached files due to local storage of attachments (local to current org file)
*************** END
*************** TODO make the advice work per item - do not save symlinks in global file, but in local folder variable
*************** END

#+BEGIN_SRC emacs-lisp
(defvar-local yant/org-attach-parent-ids nil
  "List of Ids of the parent org entry/entries, which the file/dir belongs to.
It is a directory-local variable.")
(put 'yant/org-attach-parent-ids 'safe-local-variable 'listp)

(defvar-local yant/org-attach-file-symlink-path nil
  "Path to directory where the symlink hierarchy is created for the current org buffer.
Use `default-directory' if nil.")
(put 'yant/org-attach-file-symlink-path 'safe-local-variable 'stringp)

(defvar yant/org-attach-attachments-symlink-directory "_data"
  "Name of the symlink to the attach file folder.")
(defvar yant/org-attach-symlinks-directory ".org.symlinks"
  "Name of the folder containing symlinks to the entry children attach folders.")

(defmacro yant/set-dir-variable (directory mode variable value)
  "Set DIRECTORY local VARIABLE to VALUE in MODE."
  `(if (f-directory-p (f-long ,directory))
       (save-window-excursion
	 (with-current-buffer (find-file-noselect (f-long ,directory))
	   (add-dir-local-variable ,mode ,variable ,value)
           (save-buffer)))
     (error (format "Not a directory: %s" ,directory))))

(defmacro yant/get-dir-variable (directory variable)
  "Get DIRECTORY local VARIABLE."
  `(if (f-directory-p ,directory)
       (with-current-buffer (find-file-noselect ,directory)
	 (hack-dir-local-variables-non-file-buffer)
	 (pcase ,variable
	   ((pred symbolp)
	    (symbol-value ,variable))
	   (_ ,variable)))
     (error (format "Not a directory: %s" ,directory))))

(define-advice org-attach-dir (:filter-return (dir) yant/org-attach-ensure-attach-dir-symlink)
  "Make sure that the attach DIR for the current entry has a link in the org structure based directory structure.
The advise also sets directory-local variable `org-attach-parent-ids'.
The DIR is ensured to be in the symlink mirror dir structure for the entry."
  (prog1
      dir
    (when (and (equal major-mode 'org-mode)
	       dir
               (f-exists-p dir)
               (f-dir-p dir))
      (let* ((attach-path dir)
	     (symlinks-directory (f-slash (f-join dir
						  yant/org-attach-symlinks-directory)))
             (attachments-symlink-directory (f-slash (f-join symlinks-directory
							     yant/org-attach-attachments-symlink-directory)))
	     (org-id (org-id-get))
             (entry-name (replace-regexp-in-string "[/<>|:&/]" "-" ;; make sure that entry title can be used as a directory name
						   (org-get-heading 'NO-TAGS 'NO-TODO 'NO-PRIORITY 'NO-COMMENT)))
             (entry-name (replace-regexp-in-string " *\\[.+\\] *" "" ;; remove statistics cookies
						   entry-name
						   )))
	
	(when (f-file-p symlinks-directory)
          (error (format "File exist in place of dir: %s" symlinks-directory)))
	(when (and (f-exists-p attachments-symlink-directory)
		   (not (f-symlink-p (directory-file-name attachments-symlink-directory))))
          (error (format "Not a symlink: %s" attachments-symlink-directory)))

	;; create dirs
	(unless (f-exists-p symlinks-directory)
          (f-mkdir symlinks-directory))
	(unless (f-exists-p attachments-symlink-directory)
          (f-symlink attach-path (directory-file-name attachments-symlink-directory)))

	;; set local-vars
	(unless (member org-id (yant/get-dir-variable (f-canonical attach-path) 'yant/org-attach-parent-ids))
	  (yant/set-dir-variable attach-path nil 'yant/org-attach-parent-ids
				 (add-to-list 'yant/org-attach-parent-ids org-id));; propagate for all the files in the attach dir, including `yant/org-attach-symlinks-directory'
	  )

	;; add to parent entry attachment dir
	(unless (seq-empty-p entry-name) ;; prevent empty folders
          (org-with-wide-buffer
           (let ((entry-symlink-name (if (org-up-heading-safe)
					 (directory-file-name (f-join (f-join (org-attach-dir 'CREATE)
									      yant/org-attach-symlinks-directory)
                                                                      entry-name))
                                       (directory-file-name (f-join (or yant/org-attach-file-symlink-path
									default-directory)
								    entry-name)))))
             (if (not (f-exists-p entry-symlink-name))
		 (f-symlink symlinks-directory entry-symlink-name)
               (unless (f-symlink-p entry-symlink-name)
		 (error (format "File exists: %s" entry-symlink-name)))))))

	;; check children
	(let ((child-ids '()))
	  (org-with-wide-buffer
           (org-back-to-heading)
           (let ((subtree-end (save-excursion (org-end-of-subtree))))
             (forward-line 1)
             (re-search-forward "^\*+" subtree-end t)
             (while (< (point) subtree-end)
               (let ((ID (org-id-get)))
		 (when ID
		   (add-to-list 'child-ids ID)))
               (or (outline-get-next-sibling)
		   (goto-char subtree-end)))))
          (mapc (lambda (d)
		  (let ((dir (f-long d)))
		    (unless (or (string= (f-slash dir) (f-slash attachments-symlink-directory))
				(not (f-symlink-p (directory-file-name dir))))
                      (let ((ids (yant/get-dir-variable (f-canonical dir) 'yant/org-attach-parent-ids)))
			(when (seq-empty-p (seq-intersection ids child-ids))
			  (f-delete dir))))))
		(f-directories symlinks-directory)))))))

(defun org-attach-dir-symlink (&optional create-if-not-exists-p no-data-dir)
  "Return symlink based path to the attach dir of current entry.
Do not append symlink to data directory if NO-DATA-dir is not nil."
  (let* ((entry-name (replace-regexp-in-string "[/<>|:&/]" "-" ;; make sure that entry title can be used as a directory name
					       (org-get-heading 'NO-TAGS 'NO-TODO 'NO-PRIORITY 'NO-COMMENT)))
         (entry-name (replace-regexp-in-string " *\\[.+\\] *" "" ;; remove statistics cookies
					       entry-name
					       ))
         (entry-path (f-join entry-name (if no-data-dir "" yant/org-attach-attachments-symlink-directory))))

    (unless (seq-empty-p entry-name) ;; prevent empty folders
      (org-with-wide-buffer
       (if (org-up-heading-safe)
	   (let ((head-path (org-attach-dir-symlink 'create 'no-data-dir)))
	     (when head-path (f-join head-path entry-path)))
         (f-join (or yant/org-attach-file-symlink-path
		     default-directory)
		 entry-path))))))

(define-advice org-attach-reveal (:around (OLDFUN &optional if-exists) reveal-symlink)
  "Go to symlink attach dir structure instead of an actual attach dir."
  (org-attach-dir (not if-exists))
  (letf (((symbol-function 'org-attach-dir) #'org-attach-dir-symlink))
    (funcall OLDFUN if-exists)))

(define-advice org-attach-reveal-in-emacs (:around (OLDFUN &rest args) reveal-symlink)
  #'org-attach-reveal@reveal-symlink)
#+END_SRC

*************** TODO make it handle refile (search by id) in directory local vars via filesystem search
*************** END


Files, out of the folder structure, will appear in my agenda to attach them to the relevant project (unless explicitly specified in special variable). 


***** TODO handle cases when we need files in the same dir with the org file [[id:9dc72877-1e7b-4084-a262-6e39b08ced49][LaTeX class]]
:PROPERTIES:
:CREATED: [2018-07-09 Mon 12:40]
:END:
:LOGBOOK:
CLOCK: [2018-07-09 Mon 12:40]--[2018-07-09 Mon 12:41] =>  0:01
:END:
***** TODO honor inherit export directory
:PROPERTIES:
:CREATED: [2018-07-09 Mon 13:01]
:END:
***** DONE make org-attach-dir give trailing "/" [[pdfview:/home/yantar92/Org/_data/63/b9ca36-f366-4048-acdf-5f92ec8c44d2/Lab2.Sandwich-composites.pdf::2][/home/yantar92/Org/_data/63/b9ca36-f366-4048-acdf-5f92ec8c44d2/Lab2.Sandwich-composites.pdf]]
CLOSED: [2018-07-11 Wed 16:54]
:PROPERTIES:
:CREATED: [2018-07-09 Mon 14:43]
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-07-11 Wed 16:54]
:END:
**** NEXT Saving web pages into notes
:PROPERTIES:
:CREATED:  [2017-12-30 Sat 22:20]
:ID:       8e1af85e-3e47-40c3-9b33-34a5e848b483
:END:
:LOGBOOK:
- State "TODO"       from              [2017-12-30 Sat 22:20]
:END:
#+BEGIN_SRC emacs-lisp
(use-package org-board
  :ensure t
  :init
  (setq org-board-default-browser 'system)
  :config
  (bind-key "C-c C-S-o" org-board-keymap org-mode-map))
#+END_SRC

- =org-board= uses =URL= property, while I use =Source= property. At least, it make sense to default the prompt of =org-board-new= to the value of =Source= property.
#+BEGIN_SRC emacs-lisp
(define-advice org-board-new (:around (OLDFUN &optional URL) org-board-new-default-to-Source)
  "Set default prompt in `org-board-new' to value of :Source: property of the entry."
  (interactive)
  (let ((URL (or URL (completing-read "URL: " nil nil nil (org-entry-get nil "Source")))))
    (funcall OLDFUN URL)))
#+END_SRC
**** =_epilogue=
:PROPERTIES:
:ID:       fdd42cf4-96cb-4c9f-b855-3fb8437f9d9c
:END:
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** Agenda & scheduling
:PROPERTIES:
:ID:       ff70b03f-3876-4b2b-9aab-c3209bd31cb8
:END:
#+begin_src emacs-lisp
(require 'org-agenda)
(setq org-agenda-restore-windows-after-quit t)
(setq org-agenda-window-setup 'only-window)
(setq org-agenda-todo-list-sublevels t)
(setq org-directory "~/Org")
(setq org-agenda-files "~/Org/agenda_files")
(setq org-deadline-warning-days 30)
(setq org-agenda-span 'day)
(setq org-agenda-sorting-strategy '((agenda deadline-up time-up habit-up priority-down timestamp-down category-keep)
				    (todo priority-down category-keep)
				    (tags priority-down category-keep)
				    (search category-keep)))
(setq org-agenda-tags-todo-honor-ignore-options t)
(setf org-agenda-sticky t)
(setq org-agenda-skip-scheduled-if-deadline-is-shown t)
(setq org-habit-show-habits-only-for-today t) ; do not show habits in future if scheduled withing agenda time range. E.g. do not show future habits in week view/calendar
#+end_src
- I use several agenda views
  - Focused daily agenda :: When we mark the item scheduled, it means that we need to start working on it from that day. However, it leads to a situation when there are so many items being active in agenda that it is useful to focus on what we need to do during the day. That's why I need an additional agenda which focuses on what I really need to do today, but not what I need to start today and what I have started to do which is the case for default daily agenda. 
  - Normal daily agenda :: Standard agenda with minor tweaks.
  - Full agenda for GTD self-check :: see below.
  - List of projects agenda :: List of all active projects.
  - *Agenda view for captured tasks* :: tasks, which needs to be refiled (with =:INBOX:= tag)
- I use different skip functions here in agenda to filter the agenda. Some of them are used, some of them are just kept here for future if I need them. 
  #+begin_src emacs-lisp
(defun bh/skip-non-stuck-projects-and-non-next-subprojects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
					;      (if (bh/is-project-p)
      (if (and (bh/is-project-p)
	       (or (not (bh/is-subproject-p))
		   (member (org-get-todo-state) (list "NEXT"))))
	  (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
		 (has-next ))
	    (save-excursion
	      (forward-line 1)
	      (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
		(unless (member "WAITING" (org-get-tags-at))
		  (setq has-next t))))
	    (if has-next
		next-headline
	      nil)) ; a stuck project, has subtasks but no next task
	next-headline))))
(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  ;;  (if (save-restriction (bh/skip-non-stuck-projects-and-non-next-subprojects))
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((and (bh/is-project-p) (not (bh/is-subproject-p)))
	nil)
       (t
	subtree-end)))
    ))
(defun bh/skip-non-tasks ()
  "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
	nil)
       (t
	next-headline)))))
(defun bh/skip-subprojects ()
  "Show non-subproject tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((not (bh/is-subproject-p))
	nil)
       (t
	next-headline)))))

(defun bh/skip-habits ()
  "Skip habits"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (org-is-habit-p)
	  next-headline
	nil))))

(defun bh/skip-nohabits ()
  "Skip not habits."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (org-is-habit-p)
	  nil
	next-headline))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
	next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
	     (member "WAITING" (org-get-tags-at)))
	next-headline)
       ((bh/is-project-p)
	next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
	next-headline)
       (t
	nil)))))
(defun zin/org-agenda-skip-tag (tag &optional others)
  "Skip all entries that correspond to TAG.
      If OTHERS is true, skip all entries that do not correspond to TAG."
  (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	(current-headline (or (and (org-at-heading-p)
				   (point))
			      (save-excursion (org-back-to-heading)))))
    (if others
	(if (not (member tag (org-get-tags-at current-headline)))
	    next-headline
	  nil)
      (if (member tag (org-get-tags-at current-headline))
	  next-headline
	nil))))
  #+end_src
  #+begin_src emacs-lisp
(defvar bh/hide-scheduled-and-waiting-next-tasks 't)
(setq org-agenda-custom-commands
      (quote (
	      ("p" "Projects" tags-todo "-CANCELLED/!"
	       ((org-agenda-overriding-header "Project list")
		(org-agenda-prefix-format "%?-12t")
		(org-agenda-skip-function 'bh/skip-non-projects)
		(org-agenda-sorting-strategy
		 '(todo-state-down effort-up category-keep))))
	      ("d" "Focus daily agenda" agenda ""
	       ((org-agenda-skip-function 'yant/org-agenda-skip-nofocus)))
	      ("i" "Inbox items"
	       ((tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "Inbox")
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notscheduled)))
		       (org-agenda-prefix-format "S\t\t%-12.12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'notdeadline)))
		       (org-agenda-prefix-format "D\t\t%-12.12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))
		(tags "+INBOX-DEFAULT"
		      ((org-agenda-overriding-header "")
		       (org-agenda-block-separator nil)
		       (org-agenda-skip-function '(or (yant/org-agenda-inbox-items) (org-agenda-skip-entry-if 'scheduled 'deadline)))
		       (org-agenda-prefix-format "\t\t%-12.12:c\t%?-12t")
		       (org-tags-match-list-sublevels nil)))))
	      (" " "Agenda"
	       ((agenda ""
			((org-agenda-prefix-format "%-12s\t%-12.12:c\t%?-12t")
			 (org-agenda-skip-function '(zin/org-agenda-skip-tag "HOLD"))))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "Inbox")
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))
			    (org-agenda-prefix-format "S\t\t%-12.12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
			    (org-agenda-prefix-format "D\t\t%-12.12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "INBOX-DEFAULT"
			   ((org-agenda-overriding-header "")
			    (org-agenda-block-separator nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))
			    (org-agenda-prefix-format "\t\t%-12.12:c\t%?-12t")
			    (org-tags-match-list-sublevels nil)))
		(tags-todo "-CANCELLED-WAITING-HOLD/!"
			   ((org-agenda-overriding-header "Stuck Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%-12.12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-stuck-projects-and-non-next-subprojects)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(category-keep))))
		(tags-todo "-CANCELLED+WAITING|HOLD/!"
			   ((org-agenda-overriding-header (concat "Waiting and Hold Tasks" ""))
			    (org-agenda-prefix-format "%-12.12:c\t%?-12t")
			    (org-use-tag-inheritance nil)
			    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
			    (org-tags-match-list-sublevels nil)
			    (org-agenda-sorting-strategy
			     '(todo-state-down))))
		(tags-todo "-CANCELLED-HOLD-WAITING/!NEXT"
			   ((org-agenda-overriding-header (concat "Project Next Tasks"
								  (if bh/hide-scheduled-and-waiting-next-tasks
								      ""
								    " (including WAITING and SCHEDULED tasks)")))
			    (org-agenda-prefix-format "%-12.12:c\t%?-12t")
			    (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
			    (org-tags-match-list-sublevels t)
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-sorting-strategy
			     '(priority-down todo-state-down effort-up category-keep))))
		(tags "/"
		      ((org-agenda-overriding-header "Tasks to Archive")
		       (org-agenda-prefix-format "%-12.12:c\t%?-12t")
		       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		       (org-tags-match-list-sublevels nil)))
		(tags-todo "-CANCELLED/!"
			   ((org-agenda-overriding-header "Projects")
			    (org-agenda-dim-blocked-tasks nil)
			    (org-agenda-prefix-format "%?-12t")
			    (org-agenda-skip-function 'bh/skip-non-projects)
			    (org-agenda-sorting-strategy
			     '(todo-state-down effort-up category-keep))))
		(tags-todo "-CANCELLED-WAITING-HOLD-DEFAULT/!"
			   ((org-agenda-overriding-header "All other active tasks")
			    (org-agenda-dim-blocked-tasks 'invisible)
			    (org-agenda-prefix-format "%-12.12:c\t%?-12t")
			    (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
			    (org-agenda-skip-function '(lambda()
							 (or
							  (bh/skip-non-tasks)
							  (and (not (zin/org-agenda-skip-tag "SKIP"))
							       (bh/skip-subprojects))
							  (zin/org-agenda-skip-tag "NODEADLINE")
							  (bh/skip-habits)))))))
	       nil))))
  #+end_src
**** Focused daily agenda
:PROPERTIES:
:ID:       a6054643-449e-48d7-afff-4155465efc19
:END:
This agenda show the items for the current day and time.
+ all the items with deadline, according =org-deadline-warning-days=, unless the item is scheduled. If the item is scheduled, it is shown from the scheduled day.
  #+begin_src emacs-lisp
(defun org-agenda-skip-deadlines-before-schedule ()
  "Skip tasks, with deadline and scheduled in future and tasks without deadline."
  (require 'org-agenda)
  (save-restriction
    (widen)
    (let* ((next-headline (save-excursion
			    (or (outline-next-heading)
				(point-max))))
	   (tmp-deadline-time (org-get-deadline-time (point)))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-deadline (time-to-days tmp-deadline-time))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (if (or
	   (not tmp-deadline-time)
	   (and
	    tmp-scheduled-time
	    tmp-deadline-time
	    (> tmp-cur-schedule tmp-cur-day)
	    ;;(> tmp-cur-deadline tmp-cur-day)
            ))
	  next-headline
	nil))))
  #+end_src

+ all [#A] priority items, with matching =:SHOWDATES:= and =:SHOWFROMTIME:=, unless they are scheduled in the future
  #+begin_src emacs-lisp
(defun org-agenda-skip-nonurgent ()
  (save-restriction
    (widen)
    (let* (
	   (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (cur-priority (org-entry-get (point) "PRIORITY"))
	   (tmp-scheduled-time (org-get-scheduled-time (point)))
	   (tmp-cur-schedule (time-to-days tmp-scheduled-time))
	   (tmp-cur-day (time-to-days (apply #'encode-time
					     (append '(0 0 0)
						     (list (nth 1 org-agenda-current-date))
						     (list (nth 0 org-agenda-current-date))
						     (list (nth 2 org-agenda-current-date)))))))
      (if (and (string-equal cur-priority "A")
	       (or (not tmp-scheduled-time)
		   (<= tmp-cur-schedule tmp-cur-day)))
	  nil
	next-headline))))
  #+end_src
+ all the items scheduled for today and matching =:SHOWFROMTIME:=
  #+begin_src emacs-lisp
(defun org-agenda-skip-not-today ()
  "Skip items which a not scheduled today."
  (save-restriction
    (widen)
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (scheduleddate (subseq (decode-time (org-get-scheduled-time (point))) 3 6))
	   (currentdate	(list (nth 1 org-agenda-current-date) (nth 0 org-agenda-current-date) (nth 2 org-agenda-current-date)))
	   )
      (if (equal scheduleddate currentdate) nil next-headline))))
  #+end_src
+ items from diary/with timestamps (shown by default in org)
+ habits
  #+begin_src emacs-lisp
(defun yant/org-agenda-skip-nofocus()
  "Filter tasks for focus agenda."
  (and
   (or
    (and
     (org-agenda-skip-nonurgent) ; show urgent items
     (bh/skip-nohabits) ; and habits
     )
					;  if day and time are appropriate
    (org-agenda-skip-before-SHOWFROMTIME-property)
    (org-agenda-skip-noshowdates))
   (or
    (org-agenda-skip-not-today) ; and items, scheduled for today
    (org-agenda-skip-before-SHOWFROMTIME-property) ; if time is appropriate (day is, since it is scheduled)
    )
   (org-agenda-skip-deadlines-before-schedule) ; always show deadlines, unless scheduled in future
   ))
  #+end_src
**** Normal daily agenda
:PROPERTIES:
:ID:       f50074e7-42b2-4da5-9421-04ec9deccf07
:END:
This is a standard org mode agenda showing deadlines, schedules, diary items and items with timestamps.
#+begin_src emacs-lisp
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-include-inactive-timestamps nil)
#+end_src
**** GTD self-check
:PROPERTIES:
:ID:       d110dae9-f563-48bb-8293-a10b1afbe772
:END:
1. Full daily agenda without hold tasks
2. =INBOX= items to refile to other places
   - scheduled
   - with deadline
   - not scheduled
3. Next tasks which are not yet scheduled
4. Done tasks to archive, unless have =:NOARCHIVE:= tag.
5. Project list
6. Waiting and hold tasks, which are not scheduled
7. Other tasks which are not part of project or has =SKIP= tag. Useful to catch wrong refiles and look for the new things to do. Blocked tasks are not shown here.
*************** NEXT I actually want to see independent tasks and non blocked by edna TODO tasks from subtree with NEXT tasks grouped under subtree name
:LOGBOOK:
CLOCK: [2017-12-29 Fri 07:36]--[2017-12-29 Fri 07:37] =>  0:01
CLOCK: [2017-12-29 Fri 07:26]--[2017-12-29 Fri 07:36] =>  0:10
CLOCK: [2017-12-29 Fri 07:17]--[2017-12-29 Fri 07:26] =>  0:09
CLOCK: [2017-12-29 Fri 06:45]--[2017-12-29 Fri 07:17] =>  0:32
CLOCK: [2017-12-28 Thu 22:49]--[2017-12-28 Thu 22:52] =>  0:03
CLOCK: [2017-12-28 Thu 22:27]--[2017-12-28 Thu 22:49] =>  0:22
CLOCK: [2017-12-28 Thu 22:24]--[2017-12-28 Thu 22:26] =>  0:02
CLOCK: [2017-12-28 Thu 21:35]--[2017-12-28 Thu 22:24] =>  0:49
CLOCK: [2017-12-28 Thu 21:28]--[2017-12-28 Thu 21:35] =>  0:07
CLOCK: [2017-12-28 Thu 21:22]--[2017-12-28 Thu 21:27] =>  0:05
CLOCK: [2017-12-28 Thu 21:18]--[2017-12-28 Thu 21:22] =>  0:04
CLOCK: [2017-12-28 Thu 17:52]--[2017-12-28 Thu 17:56] =>  0:04
:END:
Use TODO dependencies to filter out subprojects/tasks, which cannot
be done before NEXT task is done. Do not use SKIP tag, but mark tasks,
which should be kept without archiving.
- checking dependencies (nil - blocked)
#+BEGIN_SRC emacs-lisp :tangle no
(defun yant/is-blocked-p ()
  "Check if the task is blocked."
  (not (save-excursion
    (save-match-data
      (org-with-wide-buffer
       (run-hook-with-args-until-failure
	'org-blocker-hook '(:type todo-state-change :from "TODO" :to "DONE")))))))
#+END_SRC

*************** END
**** Captured items, which should be refiled
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 22:28]
:ID:       18a47cca-2dfa-4e27-9814-a2edfd54a9f4
:END:
These items should have =:INBOX:= tag. Also, if both project and subproject have =:INBOX:= tag, only topmost project should be refiled.
#+BEGIN_SRC emacs-lisp
(defun yant/org-agenda-inbox-items ()
  "Only show items with INBOX tag, which parents does not have this tag."
  (save-excursion
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point)))
	    (next-headline (save-excursion (or (outline-next-heading) (point-max))))
	    result)
	(if (not (member "INBOX" (org-get-tags-at (point))))
	    next-headline
	  (while (and (not result)
		      (org-up-heading-safe))
	    (when (member "INBOX" (org-get-tags-at (point)))
	      (setq result next-headline)))
	  result)))))
#+END_SRC
**** TODO Ever standing project list
**** =CalFW=
:PROPERTIES:
:ID:       1d03f6e7-0f52-4aad-926e-a6762cd2d7dc
:END:
Agenda is excellent for short term planning, however it is not very useful if I need to schedule something, say, for 3 month later. I prefer something like normal calendar with short summary of the scheduled tasks to plan the task being scheduled.
#+begin_src emacs-lisp
(use-package calfw
  :if init-flag
  :ensure t
  :config
  (use-package calfw-org
    :ensure t
    :config
    (setq calendar-week-start-day 1)
    (defun cfw:open-calendar ()
      (interactive)
      (let ((cp
	     (cfw:create-calendar-component-buffer
	      :view 'week
	      :contents-sources
	      (list 
	       (cfw:org-create-source)))))
	(switch-to-buffer (cfw:cp-get-buffer cp))))
    (use-package boon
      :config
      (bind-key "A" 'cfw:open-calendar 'boon-goto-map))
    (custom-set-faces
     '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
     '(cfw:face-header ((t (:foreground "#d0bf8f" :weight bold))))
     '(cfw:face-sunday ((t :foreground "#cc9393" :background "grey10" :weight bold)))
     '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "grey10" :weight bold)))
     '(cfw:face-holiday ((t :background "grey10" :foreground "#8c5353" :weight bold)))
     '(cfw:face-grid ((t :foreground "DarkGrey")))
     '(cfw:face-default-content ((t :foreground "#bfebbf" :height 0.7)))
     '(cfw:face-periods ((t :foreground "cyan")))
     '(cfw:face-day-title ((t :background "grey10")))
     '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
     '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
     '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
     '(cfw:face-today-title ((t :background "#7f9f7f" :weight bold)))
     '(cfw:face-today ((t :background: "grey10" :weight bold)))
     '(cfw:face-select ((t :background "#2f2f2f")))
     '(cfw:face-toolbar ((t :foreground "Steelblue4" :background "Steelblue4")))
     '(cfw:face-toolbar-button-off ((t :foreground "Gray10" :weight bold)))
     '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold))))
    ;; Unicode characters
    (setq cfw:fchar-junction ?╋
	  cfw:fchar-vertical-line ?┃
	  cfw:fchar-horizontal-line ?━
	  cfw:fchar-left-junction ?┣
	  cfw:fchar-right-junction ?┫
	  cfw:fchar-top-junction ?┯
	  cfw:fchar-top-left-corner ?┏
	  cfw:fchar-top-right-corner ?┓)))
#+end_src
**** =Gcal= - sync with Google calendar
:PROPERTIES:
:ID:       b66193fa-9189-4822-b68f-87f5bc30c3fd
:END:
***** General setup
:PROPERTIES:
:ID:       9eda87f8-8e84-4b3d-b5a6-876ba287c7bb
:END:
#+begin_src emacs-lisp
(use-package org-gcal
  :if init-flag
  :ensure t
  :config
  (setq org-gcal-down-days 360)
  (setq org-gcal-sync-idle-secs (* 60 10)) ; 10 min
  (defun org-gcal-sync-enable ()
    "Enable gcal idle sync."
    (interactive)
    (setq org-gcal-sync-timer
	  (run-with-idle-timer org-gcal-sync-idle-secs t
			       'org-gcal-sync)))
  (defun org-gcal-sync-disable ()
    "Disable mobile org idle sync."
    (interactive)
    (cancel-timer org-gcal-sync-timer))
  (org-gcal-sync-enable))
#+end_src
***** TODO Avoid duplicates in agenda for gcal entries and other entries
Usually, I have some events scheduled locally in my computer and some are scheduled in Google calendar. Of course, I want to see both. It is easy - just add my gcal org file to agenda. However, the problem appears when I want to see locally scheduled events in Google Calendar (for mobile notifications). In such a case I need to copy the entries from my local org files to GCal. In such a case, these entries appears in my local agenda twice, which is annoying.
***** Suppress =libnotify= notifications
:PROPERTIES:
:CREATED:  [2018-03-12 Mon 21:18]
:ID:       a818576a-f55a-428b-86e9-0df97ae445c1
:END:
#+BEGIN_SRC emacs-lisp
(define-advice org-gcal--notify (:around (OLDFUN &rest args) org-gcal-force-message-notifications)
  "Force org-gcal to use message area notifications, not libnotify (it is too spammy)."
  (let ((alert-default-style 'message))
    (apply OLDFUN args)))
#+END_SRC
**** Handling different time zones in time stamps :ARCHIVE:
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 18:36]
:END:
It is sometimes very annoying when org mode assumes that all the time
stamps are in local time zone. Foe example, I have a round flight, and
want to schedule it to not forget coming back ;). But the timing will
be shifted for return flight if I go to different time zone. Hence I
would like to have some way to fix the time zone of time stamp. I do
it by defining time stamp like =<YYYY-MM-DD HH:MM #TIMEZONE#>=, where
=TIMEZONE= is time zone as in =/usr/share/zoneinfo=.
It is implemented by wrapping the hook to correct the time around
=org-parse-time-string=, which seems to be enough to correct org mode
behavior. The stamps without time are not parsed (how?).
*************** NEXT [#A] Make sure it works
SCHEDULED: <2017-12-23 Sat>
:LOGBOOK:
CLOCK: [2017-12-24 Sun 15:55]--[2017-12-24 Sun 17:52] =>  1:57
CLOCK: [2017-12-24 Sun 15:24]--[2017-12-24 Sun 15:54] =>  0:30
CLOCK: [2017-12-24 Sun 15:00]--[2017-12-24 Sun 15:24] =>  0:24
CLOCK: [2017-12-24 Sun 11:51]--[2017-12-24 Sun 13:15] =>  1:24
CLOCK: [2017-12-24 Sun 09:26]--[2017-12-24 Sun 10:12] =>  0:46
CLOCK: [2017-12-24 Sun 08:23]--[2017-12-24 Sun 09:26] =>  1:03
CLOCK: [2017-12-24 Sun 08:01]--[2017-12-24 Sun 08:09] =>  0:08
:END:
- agenda does not use =org-parse-time-string= to find displayed string
  in timeline, even though task will be shown/not shown respecting time zone
*************** END
#+begin_src emacs-lisp :tangle no
;; force matching of time zone formatted time stamps
(setf org-scheduled-time-hour-regexp (concat "\\<" org-scheduled-string
					     " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(setf org-deadline-time-hour-regexp (concat "\\<" org-deadline-string
					    " *<\\([^>]+[0-9]\\{1,2\\}:[0-9]\\{2\\}[0-9-+:hdwmy \t.]*\\(?:#[^#]+#* \\)?\\)>"))
(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-parse-timezone)
  "Convert time stamp to local time if time zone information is present.
Do not handle time stamps without time.
Time zone is located like '<YYYY-MM-DD HH:MM #TIMEZONE#>'.
TIMEZONE is according to system timezone format (as accepted by `current-time-zone')."
  (let ((return-val (funcall oldfun s NODEFAULT)))
    (if (and (string-match org-ts-regexp0 s)
	     (not NODEFAULT))
	(if (string-match "#\\([^#]+\\)#" s)
	    (let ((result (decode-time (- (float-time (apply 'encode-time
							     return-val))
					  (- (car (current-time-zone nil (match-string 1 s)))
					     (car (current-time-zone)))))))
	      (setf (car result) 0)
              (append (butlast result 3) '(nil nil nil)))
	  return-val)
      return-val)))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-convert-atpm-to-24)
  "Honor am/pm format by `org-parse-time-string'."
  (let* ((match (string-match " *#[^#]+#" s)) ; avoid infinite recursion loop with time zone parsing in `org-get-time-of-day'
	 (timeofday (org-get-time-of-day (if match
					     (replace-match "" nil nil s)
					   s)
					 'string)))
    (if (or (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *" s)
	    (string-match "\\<\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *" s))
	(funcall oldfun (replace-match timeofday nil nil s) NODEFAULT)
      (funcall oldfun s NODEFAULT))))

(define-advice org-parse-time-string (:around (oldfun s &optional NODEFAULT) org-timestamp-parse-no-date)
  "Make `org-parse-time-string' work with time stamps without date (just consider today)."
  (when (and (not (string-match "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}" s))
	     (or (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)\\([AaPp][Mm]\\)?\\> *\\)" s)
		 (string-match "\\<\\(\\([012]?[0-9]\\)\\(:\\([0-5][0-9]\\)\\)?\\([AaPp][Mm]\\)\\> *\\)" s)))
    (setf s (replace-match (concat (format-time-string "%Y-%m-%d %a " (org-matcher-time "<today>"))
				   "\\&")
			   nil nil s)))
  (funcall oldfun s NODEFAULT))

(define-advice org-get-time-of-day (:around (oldfun s &optional string mod24) org-timestamp-convert-to-local-timezone)
  "Convert time stamp with #TIMEZONE# to time stamp in local time zone."
  (if (string-match "#[^#]+#" s)
      (funcall oldfun (format-time-string "%Y-%m-%d %k:%M"
					  (apply #'encode-time
						 (org-parse-time-string s)))
	       string mod24)
    (funcall oldfun s string mod24)))
#+end_src
Unfortunately, =org-agenda-get-scheduled= has hard coded setting to
calculate time of the entry and not respecting =org-parse-timestring= or
=org-get-time-of-day=. Hence, I need to rewrite it just for sake of
changing =(concat (substring s (match-beginning 1)) " "))= into =(concat
(org-get-time-of-day s t) " ")).= 
#+begin_src emacs-lisp :tangle no
(defun org-agenda-get-scheduled (&optional deadlines with-hour)
  "Return the scheduled information for agenda display.
Optional argument DEADLINES is a list of deadline items to be
displayed in agenda view.  When WITH-HOUR is non-nil, only return
scheduled items with an hour specification like [h]h:mm."
  (let* ((props (list 'org-not-done-regexp org-not-done-regexp
		      'org-todo-regexp org-todo-regexp
		      'org-complex-heading-regexp org-complex-heading-regexp
		      'done-face 'org-agenda-done
		      'mouse-face 'highlight
		      'help-echo
		      (format "mouse-2 or RET jump to Org file %s"
			      (abbreviate-file-name buffer-file-name))))
	 (regexp (if with-hour
		     org-scheduled-time-hour-regexp
		   org-scheduled-time-regexp))
	 (today (org-today))
	 (todayp (org-agenda-today-p date)) ; DATE bound by calendar.
	 (current (calendar-absolute-from-gregorian date))
	 (deadline-pos
	  (mapcar (lambda (d)
		    (let ((m (get-text-property 0 'org-hd-marker d)))
		      (and m (marker-position m))))
		  deadlines))
	 scheduled-items)
    (goto-char (point-min))
    (while (re-search-forward regexp nil t)
      (catch :skip
	(unless (save-match-data (org-at-planning-p)) (throw :skip nil))
	(org-agenda-skip)
	(let* ((s (match-string 1))
	       (pos (1- (match-beginning 1)))
	       (todo-state (save-match-data (org-get-todo-state)))
	       (donep (member todo-state org-done-keywords))
	       (show-all (or (eq org-agenda-repeating-timestamp-show-all t)
			     (member todo-state
				     org-agenda-repeating-timestamp-show-all)))
	       ;; SCHEDULE is the bare scheduled date, i.e., without
	       ;; any repeater if non-nil, or last repeat if SHOW-ALL
	       ;; is nil.  REPEAT is the closest repeat after CURRENT,
	       ;; if all repeated time stamps are to be shown, or
	       ;; after TODAY otherwise.  REPEAT only applies to
	       ;; future dates.
	       (schedule (if show-all (org-agenda--timestamp-to-absolute s)
			   (org-agenda--timestamp-to-absolute
			    s today 'past (current-buffer) pos)))
	       (repeat (cond ((< current today) schedule)
			     (show-all
			      (org-agenda--timestamp-to-absolute
			       s current 'future (current-buffer) pos))
			     (t
			      (org-agenda--timestamp-to-absolute
			       s today 'future (current-buffer) pos))))
	       (diff (- current schedule))
	       (warntime (get-text-property (point) 'org-appt-warntime))
	       (pastschedp (< schedule today))
	       (habitp (and (fboundp 'org-is-habit-p) (org-is-habit-p)))
	       (suppress-delay
		(let ((deadline (and org-agenda-skip-scheduled-delay-if-deadline
				     (org-entry-get nil "DEADLINE"))))
		  (cond
		   ((not deadline) nil)
		   ;; The current item has a deadline date, so
		   ;; evaluate its delay time.
		   ((integerp org-agenda-skip-scheduled-delay-if-deadline)
		    ;; Use global delay time.
		    (- org-agenda-skip-scheduled-delay-if-deadline))
		   ((eq org-agenda-skip-scheduled-delay-if-deadline
			'post-deadline)
		    ;; Set delay to no later than DEADLINE.
		    (min (- schedule
			    (org-agenda--timestamp-to-absolute deadline))
			 org-scheduled-delay-days))
		   (t 0))))
	       (ddays
		(cond
		 ;; Nullify delay when a repeater triggered already
		 ;; and the delay is of the form --Xd.
		 ((and (string-match-p "--[0-9]+[hdwmy]" s)
		       (> current schedule))
		  0)
		 (suppress-delay
		  (let ((org-scheduled-delay-days suppress-delay))
		    (org-get-wdays s t t)))
		 (t (org-get-wdays s t)))))
	  ;; Display scheduled items at base date (SCHEDULE), today if
	  ;; scheduled before the current date, and at any repeat past
	  ;; today.  However, skip delayed items and items that have
	  ;; been displayed for more than `org-scheduled-past-days'.
	  (unless (and todayp
		       habitp
		       (bound-and-true-p org-habit-show-all-today))
	    (when (or (and (> ddays 0) (< diff ddays))
		      (> diff org-scheduled-past-days)
		      (> schedule current)
		      (and (< schedule current)
			   (not todayp)
			   (/= repeat current)))
	      (throw :skip nil)))
	  ;; Possibly skip done tasks.
	  (when (and donep
		     (or org-agenda-skip-scheduled-if-done
			 (/= schedule current)))
	    (throw :skip nil))
	  ;; Skip entry if it already appears as a deadline, per
	  ;; `org-agenda-skip-scheduled-if-deadline-is-shown'.  This
	  ;; doesn't apply to habits.
	  (when (pcase org-agenda-skip-scheduled-if-deadline-is-shown
		  ((guard
		    (or (not (memq (line-beginning-position 0) deadline-pos))
			habitp))
		   nil)
		  (`repeated-after-deadline
		   (>= repeat (time-to-days (org-get-deadline-time (point)))))
		  (`not-today pastschedp)
		  (`t t)
		  (_ nil))
	    (throw :skip nil))
	  ;; Skip habits if `org-habit-show-habits' is nil, or if we
	  ;; only show them for today.  Also skip done habits.
	  (when (and habitp
		     (or donep
			 (not (bound-and-true-p org-habit-show-habits))
			 (and (not todayp)
			      (bound-and-true-p
			       org-habit-show-habits-only-for-today))))
	    (throw :skip nil))
	  (save-excursion
	    (re-search-backward "^\\*+[ \t]+" nil t)
	    (goto-char (match-end 0))
	    (let* ((category (org-get-category))
		   (inherited-tags
		    (or (eq org-agenda-show-inherited-tags 'always)
			(and (listp org-agenda-show-inherited-tags)
			     (memq 'agenda org-agenda-show-inherited-tags))
			(and (eq org-agenda-show-inherited-tags t)
			     (or (eq org-agenda-use-tag-inheritance t)
				 (memq 'agenda
				       org-agenda-use-tag-inheritance)))))
		   (tags (org-get-tags-at nil (not inherited-tags)))
		   (level
		    (make-string (org-reduced-level (org-outline-level)) ?\s))
		   (head (buffer-substring (point) (line-end-position)))
		   (time
		    (cond
		     ;; No time of day designation if it is only
		     ;; a reminder.
		     ((and (/= current schedule) (/= current repeat)) nil)
		     ((string-match " \\([012]?[0-9]:[0-9][0-9]\\)" s)
		      (concat (org-get-time-of-day s t) " "))
		     (t 'time)))
		   (item
		    (org-agenda-format-item
		     (pcase-let ((`(,first ,next) org-agenda-scheduled-leaders))
		       (cond
			;; If CURRENT is in the future, don't use past
			;; scheduled prefix.
			((> current today) first)
			;; SHOW-ALL focuses on future repeats.  If one
			;; such repeat happens today, ignore late
			;; schedule reminder.  However, still report
			;; such reminders when repeat happens later.
			((and (not show-all) (= repeat today)) first)
			;; Initial report.
			((= schedule current) first)
			;; Subsequent reminders.  Count from base
			;; schedule.
			(t (format next (1+ diff)))))
		     head level category tags time nil habitp))
		   (face (cond ((and (not habitp) pastschedp)
				'org-scheduled-previously)
			       (todayp 'org-scheduled-today)
			       (t 'org-scheduled)))
		   (habitp (and habitp (org-habit-parse-todo))))
	      (org-add-props item props
		'undone-face face
		'face (if donep 'org-agenda-done face)
		'org-marker (org-agenda-new-marker pos)
		'org-hd-marker (org-agenda-new-marker (line-beginning-position))
		'type (if pastschedp "past-scheduled" "scheduled")
		'date (if pastschedp schedule date)
		'ts-date schedule
		'warntime warntime
		'level level
		'priority (if habitp (org-habit-get-priority habitp)
			    (+ 99 diff (org-get-priority item)))
		'org-habit-p habitp
		'todo-state todo-state)
	      (push item scheduled-items))))))
    (nreverse scheduled-items)))
#+end_src

*** TODO Column mode
:PROPERTIES:
:ID:       0d6d40dd-e4cb-4297-8695-6b66f2a1a706
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Sometimes, I forget what was happening with a task when I did it last time. Notes are useful in such a case.
However, I do not find it comfortable to look into notes (which are stored in drawer) every time I come back to the task. Instead, I use column mode to show the last stored note.
#+begin_src emacs-lisp
;; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%TODO %40ITEM(Task) %40SUMMARY(Summary)")

(defvar yant/last-note-taken ""
  "Text of the last note taken.")

(define-advice org-store-log-note (:before (&rest args) yant/org-store-last-note)
  "Store the last saved note into `yant/last-note-taken'."
  (let ((txt (buffer-string)))
    (while (string-match "\\`# .*\n[ \t\n]*" txt)
      (setq txt (replace-match "" t t txt)))
    (when (string-match "\\s-+\\'" txt)
      (setq txt (replace-match " " t t txt)))
    (when (string-match "\n" txt)
      (setq txt (replace-match " " t t txt)))
    (if (not (seq-empty-p txt))
	(setq yant/last-note-taken txt))))

(define-advice org-store-log-note (:after (&rest args) yant/org-save-last-note-into-summary-prop)
  "Save the last saved note into SUMMARY property."
  (when (and (not org-note-abort)
	     (boundp 'org-mode))
    (org-set-property "SUMMARY" (or yant/last-note-taken ""))))

#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       0de5d1d1-568f-4991-a627-e1b46b4e481f
:END:
#+begin_src emacs-lisp
)
#+end_src
*** TODO Auto sort
:PROPERTIES:
:ID:       aa092c63-f695-4c03-8639-b34fa262d5fe
:END:
#+begin_src emacs-lisp 
(use-package org-autosort)
(setq org-autosort-todo-cmp-order '("WAITING" "NEXT" "HOLD" "TODO" "MERGED" "FAILED" "DONE" "CANCELLED"))
(bind-key "C-c C-S-s" (lambda () (interactive) (org-autosort-sort-entries-at-point)) org-mode-map)
(add-to-list 'org-default-properties "SORT")
#+end_src
*** Clocking & logging
:PROPERTIES:
:ID:       d1afb1ae-a3a4-45b4-8186-8e7242e0edc1
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
The main purpose of clocking for me is to control the time I spend for important projects and for other staff (like configuring Emacs ;)). Hence, it is important to do a continuous tracking of the tasks, which I can choose to do or not to do (e.g. it is useless to keep track of how much time I spend brushing my teeth in the morning - anyway, I have to do it). 
A lot of time, the task I am doing is not useful to add to my org files explicitly (e.g. initial checks on some side project, which may or may not work; routine work). I use special tasks for all kinds of such activity: 
- Organization :: related to work, general
- Check TORead ... :: related to home, browsing, reading fiction, etc I start the activity from clocking in one of these tasks. Later, I clock in the task, which I am doing at the moment. Once it's done, clocking automatically comes back to higher level task (unless it is marked =:NOCLOCK=, see [[id:adc6f5ae-183f-4c5f-97e8-7bfe18f028d2][General org mode tags]]) or to one of the tasks above when I clocked out top level project.  
     Captures are also clocked, but once done, clocking comes back to previously active task, if any, or to default task otherwise.
*************** TODO The default task is not being saved if I restart emacs
*************** END
*************** TODO Clock out from subtask from home is wrongly activating home task
*************** END
     #+begin_src emacs-lisp
(setq org-duration-format '(("h" . h:mm) ("min" . h:mm)))
(setq org-clock-out-remove-zero-time-clocks t)
(setq org-clock-out-when-done t)
(setq org-clock-in-resume t)
(setq org-clock-persist t)
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
(setq org-clock-persist-query-resume nil)
(org-clock-persistence-insinuate)

(defvar bh/keep-clock-running nil
  "Continue in default task if no task is clocked in.")
(defvar bh/organization-task-id "Organization"
  "ID of default usefull work task.")
(defvar yant/home-task-id "Homedef"
  "ID of default useless activity task.")

(defun yant/punch-in-organization ()
  "Clock in Organization task."
  (interactive)
  (setq bh/keep-clock-running 'yant/punch-in-organization)
  (org-with-point-at (org-id-find bh/organization-task-id
				  'marker)
    (org-clock-in '(16))))

(defun yant/punch-in-home ()
  "Clock in home (random activity) task."
  (interactive)
  (setq bh/keep-clock-running 'yant/punch-in-home)
  (org-with-point-at (org-id-find yant/home-task-id
				  'marker)
    (org-clock-in '(16))))

(defun yant/punch-out nil
  "Set `org-clock-default-task' to nil and clock out."
  (save-excursion
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and does not have local tag NOCLOCK and clock in."
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (and (member (nth 2 (org-heading-components)) org-todo-keywords-1)
		     (not (member "NOCLOCK" (org-get-tags-at (point) 'LOCAL))))
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (if bh/keep-clock-running
              (bh/clock-in-default-task)
            (org-clock-out)))))))

(defun yant/clock-out-maybe nil
  "Clock out and clock in to default task if `bh/keep-clock-running' is not nil."
  (when (and bh/keep-clock-running
	     (not org-clock-clocking-in)
	     (marker-buffer org-clock-default-task)
	     (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'yant/clock-out-maybe 'append)
(add-hook 'org-clock-in-hook (lambda () (setq bh/keep-clock-running t)))
     #+end_src

     Once I keep all my time tracked, I can calculate the estimated balance of my time. The idea is that I assign the weight to each task/project (=:TIMEWEIGHT:=), which is positive for useful tasks I
     do not want to do, and negative for fun tasks (they may be useful, but the purpose is to force myself doing what I do not like to do). All I need to do now, is to keep this balance
     positive. 
*************** TODO Implement this (current month summary)
*************** END
**** Agenda log mode & clock report
:PROPERTIES:
:ID:       104927a5-4dea-4ee0-91d7-36afc6b15c7f
:END:
Reviewing previously clocked task is important to keep track of mistakes and clashes during clocking. I do it once per week. 
#+begin_src emacs-lisp
(setq org-clock-report-include-clocking-task t)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src
- set up consistency checks (do not show too short clocking gaps)
  #+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      (plist-put org-agenda-clock-consistency-checks
		 :max-gap "2:00"))
  #+end_src
**** Logging clocking data
:PROPERTIES:
:ID:       973d6eff-3d91-48f0-a3b5-b438feccf28f
:END:
#+begin_src emacs-lisp
(setq org-log-into-drawer t)
(setq org-log-done 'time)
(setq org-clock-into-drawer t)
#+end_src
- Do not create empty drawers
  #+begin_src emacs-lisp
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))
(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
  #+end_src
  - Relative to my [[id:d38441a2-1431-44db-b831-8cdec011b1dc][todo keyword structure]], it make sense that clock task is always =NEXT=
  #+begin_src emacs-lisp
(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (when (and (member (org-get-todo-state) (list "TODO" "DONE"))
	       (bh/is-task-p))
      "NEXT")))
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  #+end_src
**** Display clocked in entry
:PROPERTIES:
:ID:       13012cf7-322e-4433-a22c-e81b7c5feda0
:END:
I do not show current task in Emacs, instead I use =awesome wm= widget. Hence need to save current task in file. The widget shows clocked time and full path to the clocked tasks (i.e. =[hh:mm] Project/Subproject/Subsubproject/.../task=) or =[hh:mm] Capturing ...= for capturing (the title is being edited there and it does not make sense to keep that updated in widget as well). 
#+begin_src emacs-lisp
(setq org-clock-mode-line-total (quote today))
(setq org-clock-clocked-in-display nil)
(defvar yant/org-clocking-info-file "~/.org-clock-in"
  "File to save current clocking info.\nIt will be overwriten!")

(defun yant/task-fulltitle ()
  "Construct full path for the task at point."
  (when (fboundp 'org-mode)
    (save-excursion
      (save-restriction
	(org-back-to-heading)
	(mapconcat #'identity (org-get-outline-path 'with-self 'cache) "||")))))

(defun yant/clocked-fulltitle ()
  "Construct string, describing currently clocked entry time and full path to this entry."
  (use-package org-clock)
  (if org-capture-mode
      (concat "Capturing " (plist-get org-capture-plist :description) "...")
    (yant/task-fulltitle)))
(setq org-clock-heading-function 'yant/clocked-fulltitle)

(defun yant/save-noclock ()
  "Save info, that there is no clocked in entry."
  (use-package org-clock)
  (save-current-buffer
    (save-excursion
      (let ((buf (find-file-noselect yant/org-clocking-info-file)))
	(set-buffer buf)
	(erase-buffer)
	(insert (format "\"No clocked in task\"\n%s" org-time-balance))
	(save-buffer)
	(kill-buffer)))))

(defun yant/save-clocked ()
  "Save current clocked state into file."
  (if (org-clock-is-active)
      (save-excursion
	(save-restriction
	  (let* ((buf yant/org-clocking-info-file)
		 (str (org-clock-get-clock-string))
                 (org-time-multiplier org-clock-multiplier)
                 (time-balance org-time-balance))
	    (with-temp-file buf (insert (format "%s\n%s\n%s" str time-balance org-time-multiplier))))))
    (yant/save-noclock))
  (async-start-process "Update balance widget" "/home/yantar92/bin/balance-monitor.sh" #'ignore))

(add-hook 'org-clock-in-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-out-hook 'yant/save-clocked 'append)
(add-hook 'org-clock-cancel-hook 'yant/save-clocked 'append)
#+end_src
**** Clocking history
:PROPERTIES:
:ID:       9e2c7a88-8a56-4213-b458-ccebcd59812a
:END:
Sometimes I need to jump to some urgent task. After it is done, I hate searching for the last task buffer and start clocking it again. Hence, I use clocking history and quick key combination to clock in task from recent clocked in tasks. 
#+begin_src emacs-lisp
(setq org-clock-history-length 23)
(use-package boon
  :config
  (defun yant/org-clock-in-history-select nil
    "Force select entry to clock in from clocking history."
    (interactive)
    (org-clock-in '(4)))
  (bind-keys :map boon-goto-map
	     ("I" . yant/org-clock-in-history-select)))
#+end_src
**** Pomodoro technique
:PROPERTIES:
:ID:       ee371af1-c478-49d1-9814-1eb78242a341
:END:
Sometimes I need to do important task, but I just hate it. I tend to do anything, but not that freaking task. In this case, =pomodoro= works for me - I just switch between the task and something I like. 
About: [[https://habrahabr.ru/post/323576/][habr]]
#+begin_src emacs-lisp
(use-package pomidor
  :ensure t
  :bind (([f7] . pomidor))
  :config
  (setq alert-default-style 'libnotify))
#+end_src
**** [[id:8a2ae3c3-69b0-495b-b796-9c9916dc40c6][Bonus/penalty based time management]]
:PROPERTIES:
:CREATED:  [2018-07-21 Sat 16:40]
:ID:       38d9103d-a969-4c69-ae0e-a9a50912fba0
:END:
The idea is to assign time bonus/penalty during working on different tasks, so that the total balanced time spent under all the tasks (=org-time-balance=) is kept positive.
 
I calculate the effective time by setting =ORG-TIME-BALANCE-MULTIPLIER= property for various tasks.
If the value is positive then the task is useful. Otherwise, it is negative and I do not want to spend too much time doing such tasks. 
The property can be different for various classes of tasks allowing to avoid/promote doing various tasks.
Setting =ORG-TIME-BALANCE-MULTIPLIER= for every single task is annoying, so I make it inherited during calculation.

It does not make sense to set =ORG-TIME-BALANCE-MULTIPLIER= for tasks like buying something in the shop. 
I just do not clock them in. 
Instead, I use =ORG-TIME-BONUS-ON-DONE= property to add fixed extra time for finishing the task (only =DONE= keyword is considered).

=org-time-balance= is calculated for the last month only at the initial calculation to avoid counting old tasks and projects, which were not [[id:85dadb9c-2a7e-47cf-ba98-a0e73377653d][archived]].
The initial calculation is a time consuming procedure (=org-map-entries=) and =org-time-balance= is updated in the =org-clock-in/out= hooks/advises.
The resulting value of =org-time-balance= contains the balanced time from *one month before its initial value calculation* till the current moment of time.

#+begin_src emacs-lisp 
(defvar org-time-balance nil
  "Weighted time spent for all the tasks in agenda files.")

(defun org-get-time-balance-multiplier-at-point ()
  "Get value of :ORG-TIME-BALANCE-MULTIPLIER property of an item at point or return 1."
  (save-excursion
    (save-restriction
      (let  ((multiplier (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)))
	(if (seq-empty-p multiplier)
	    1
	  (string-to-number multiplier))))))

(defun org-get-org-time-bonus-on-done-at-point ()
  "Get value of :ORG-TIME-BONUS-ON-DONE property of an item at point or return 0."
  (save-excursion
    (save-restriction
      (org-back-to-heading)
      (let  ((bonus (org-entry-get (point) "ORG-TIME-BONUS-ON-DONE")))
	(if (seq-empty-p bonus)
	    0
	  (string-to-number bonus))))))

(defun org-accumulate-weighted-time (&optional return)
  "Aggregate `org-time-balance' counter at point for a month.
Use :ORG-TIME-BALANCE-MULTIPLIER: property to set the weight.
Just return the value at point if RETURN is not nil."
  (when org-time-balance
    (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
	   (a-month-ago (* 60 60 24 (+ daynr 1)))
	   (last-month (time-subtract (current-time) (seconds-to-time a-month-ago)))
           (value-at-point (* (org-clock-sum-current-item last-month)
                              (org-get-time-balance-multiplier-at-point))))
      (when (string= (org-get-todo-state) "DONE")
	(setq value-at-point (+ value-at-point (org-get-org-time-bonus-on-done-at-point))))
      (if return
	  value-at-point
	(setq org-time-balance (+ org-time-balance value-at-point))))))

(defun org-get-total-weighted-time (&optional force scope)
  "Calculate total weighted time clocked in all agenda files.
Ignore current value if FORCE is not nil.
If FORCE is non nil calculate the time in SCOPE if it is not nil."
  (when (or force (not org-time-balance))
    (setq org-time-balance 0)
    (org-map-entries #'org-accumulate-weighted-time t (or scope 'agenda)))
  org-time-balance)

(define-advice org-clock-out (:around (OLDFUN &rest args) yant/org-increment-weighted-time)
  "Add the current clock time to `org-time-balance'."
  (save-excursion ; Do not replace this with `with-current-buffer'.
    (with-no-warnings (set-buffer (org-clocking-buffer)))
    (save-restriction
      (widen)
      (goto-char org-clock-marker)
      (setq org-time-balance (- org-time-balance
				(org-accumulate-weighted-time 'return)))
      (apply OLDFUN args)
      (setq org-time-balance (+ org-time-balance
				(org-accumulate-weighted-time 'return)))
      (yant/save-clocked))))

(define-advice org-todo (:around (OLDFUN &rest args) yant/org-increment-weighted-time)
  "Probably add the current item time bonus to `org-time-balance'."
  (setq org-time-balance (- org-time-balance
			    (org-accumulate-weighted-time 'return)))
  (apply OLDFUN args)
  (setq org-time-balance (+ org-time-balance
			    (org-accumulate-weighted-time 'return)))
  (yant/save-clocked))



(defvar org-clock-multiplier 0
  "Multiplier of the currently clocked entry.")

(defun org-clock-save-clock-multiplier ()
  "Save value of ORG-TIME-BALANCE-MULTIPLIER of the item at point to `org-clock-multiplier'."
  (org-with-wide-buffer
   (org-get-total-weighted-time)
   (setq org-clock-multiplier (or (org-entry-get (point) "ORG-TIME-BALANCE-MULTIPLIER" 'inherit)
				  1))))

(add-hook 'org-clock-in-hook #'org-clock-save-clock-multiplier)

(add-to-list 'org-default-properties "ORG-TIME-BALANCE-MULTIPLIER")
(add-to-list 'org-default-properties "ORG-TIME-BONUS-ON-DONE")
#+end_src
***** NEXT [#A] recalc balanced time on refile
SCHEDULED: <2018-08-13 Mon>
:PROPERTIES:
:CREATED: [2018-07-24 Tue 12:27]
:END:
:LOGBOOK:
- State "NEXT"       from "TODO"       [2018-07-24 Tue 12:27]
:END:
**** =__epilogue=
:PROPERTIES:
:ID:       e26ec668-12c9-41f1-ad8a-a3dd96007f5c
:END:
#+begin_src emacs-lisp
)
#+end_src
*** Capture
:PROPERTIES:
:ID:       fbb770b4-2232-431d-b2e5-75d001ff49b0
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
Capturing is an important part of my workflow. It allows me to quickly note down the task or thought for future consideration and continue the current task. 
This should be done quickly, and from any place (not only from inside emacs):
 - system wide key combination for capturing allows to capture from anywhere
 - open new frame for capturing
 - use capture templates for most common types of quick captures
There is also one more use case when I prefer to use capture - creating a new big projects. The reason to use capture here is that common types of projects require some set of needed actions, which I tend to forget. Capture templates here allows to remind necessary project tasks to myself.
**** System wide capture 
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:49]
:ID:       0702c999-0ee5-494c-a1d7-1bb4024c43f7
:END:
#+begin_src emacs-lisp
(use-package org-protocol)
#+end_src
*************** TODO Include system scripts here
*************** END
New frame for capturing. The frame should only have capture buffer in it.
  #+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :ensure t
  :config
  (defadvice org-capture-place-template (after delete-windows activate) (delete-other-windows))
  (defadvice org-capture-select-template (around delete-capture-frame activate)
    "Advise org-capture-select-template to close the frame on abort.  From https://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection#23517820"
    (unless (ignore-errors ad-do-it t)
      (setq ad-return-value "q"))
    (if (and (equal "q" ad-return-value)
	     (equal "org-capture-pop-frame" (frame-parameter nil 'name)))
	(delete-frame))))
  #+end_src
**** Capture templates
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 21:51]
:ID:       e3d02bee-a924-4808-9a2f-fe577065038d
:END:
All these templates generally record the creation time in =:CREATED:=
  - TODO item :: Normal TODO item.
  - Habit :: Habit. I default it to no logging.
  - Meeting/Event :: Scheduled event. It is saved to =org-gcal= org file.
  - Project :: I need literature review, reports and ideas in most of the cases.
  - Conference presentation/poster :: I mark this with =conference= tag. Typical workflow here is:
      1. Write an abstract
      2. Revise abstract (habit, since it is multiple times most likely)
      3. Submit abstract
      4. Get accepted
      5. Handle finance
         - Apply for funding
         - Book flight
         - Book hotel
         - Register for conference
      6. Make presentation/poster
      7. Do trial + further revisions (habit)
      8. Print poster if it is poster
      9. Present
      10. Reimburse money
  - Research publication :: I mark this with =publication= tag. Typical workflow here is:
      1. Write outline
         1. Introduction
         2. Methodology
         3. Results
         4. Discussion
         5. Conclusions
         6. Abstract
      2. Revise (habit)
      3. Write cover letter
      4. Submit
      5. Revise according to comments (habit)
      6. Get accepted
      7. Publish in ArXiv before journal take over the copyright
      8. Publish in journal
      9. Add to publication list
  - Link from browser :: It has =:SOURCE:= with URL of the page and page title in headline. =:SOURCE:= is the only place, where the URL is shown. I tag the entry with tag =BOOKMARK= to make it clear.
  - Selection from browser :: Same as previous, but selection is used as headline 
  - Link to email :: It has =:EMAIL-SOURCE:= with link to =notmuch= email (more about working with emails in [[id:e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326][Notmuch interaction]]). I also mark with tag =EMAIL=. 
        #+begin_src emacs-lisp
(setq org-capture-templates
      '(("n" "TODO item" entry (file "~/Org/inbox.org")
	 "* TODO %? %a\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-in t :clock-resume t)
	("p" "Conference presentation/poster" entry (file "~/Org/inbox.org")
	 "* NEXT [presentation/poster] %^{Title of presentation/poster} :conference:NOARCHIVE:\n:PROPERTIES:\n:CREATED: %U\n:END:\n** NEXT Write an abstract\n** TODO Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Submit abstract\nDEADLINE: %^t\n** TODO Get accepted\n** TODO Finance matters\n*** TODO Apply for conference funding\n*** TODO Book a flight\n*** TODO Book accomodation\n*** TODO Register for a conference\n** TODO Make presentation/poster\n** TODO Trial presentation\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Print poster/slides\n** TODO Present\n** TODO Submit the claim\n** Get reimbursement\n" :clock-in t :clock-resume t)
	("j" "Journal publication" entry (file "~/Org/inbox.org")
	 "* NEXT [paper] %^{Aproximate title of the paper} :publication:NOARCHIVE:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%^{Short description}\n** TODO Outline\nDEADLINE: %^t\n*** NEXT Abstract\n*** TODO Introduction\n*** TODO Methods\n*** TODO Results\n*** TODO Discussion\n*** TODO Conclusions\n** TODO Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Cover letter\n** TODO Submit\n** Revise\n:PROPERTIES:\n:REPEAT_TO_STATE: NEXT\n:LOGGING: nil\n:END:\n** TODO Get accepted\n** TODO Publish on ArXiv\n** TODO Get published\n** TODO Add to pub list\n" :clock-in t :clock-resume t)
	("P" "Research project" entry (file "~/Org/inbox.org")
	 "* TODO %^{Project title} :%^G:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%^{Project description}\n** TODO Literature review\n** TODO %?\n** TODO Summary\n** TODO Reports\n** Ideas\n" :clock-in t :clock-resume t)
	("e" "Email" entry (file "~/Org/inbox.org")
	 "* TODO %? email |- %:from: %:subject :EMAIL:\n:PROPERTIES:\n:CREATED: %U\n:EMAIL-SOURCE: %l\n:END:\n%U\n" :clock-in t :clock-resume t)
	("b" "Link from browser" entry (file "~/Org/inbox.org")
	 "* TODO %? |- (%:description) :BOOKMARK:\n:PROPERTIES:\n:CREATED: %U\n:Source: %:link\n:END:\n%i\n" :clock-in t :clock-resume t)
	("s" "Selection from browser" entry (file "~/Org/inbox.org")
	 "* TODO %? :BOOKMARK:\n%(replace-regexp-in-string \"\n.*\" \"\" \"%i\")\n:PROPERTIES:\n:CREATED: %U\n:Source: %:link\n:END:\n%i\n" :clock-in t :clock-resume t)
	("h" "Habit" entry (file "~/Org/inbox.org")
	 "* NEXT %?\nSCHEDULED: <%<%Y-%m-%d %a .+1d>>\n:PROPERTIES:\n:CREATED: %U\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:LOGGING: DONE(!)\n:ARCHIVE: %%s_archive::* Habits\n:END:\n%U\n")
	("m" "Scheduled event/Meeting" entry (file "~/Org/schedule.org")
	 "* %?\n")
        ("C" "Contacts" entry (file "~/Org/contacts.org")
         "* %(org-contacts-template-name)
:PROPERTIES:
:EMAIL: %(org-contacts-template-email)
:PHONE:
:ALIAS:
:NICKNAME:
:IGNORE:
:ICON:
:NOTE:
:ADDRESS:
:BIRTHDAY:
:END:")))
      #+end_src
      #+begin_src emacs-lisp
  )
      #+end_src


*** Refile
:PROPERTIES:
:ID:       c048269c-57b9-434a-a19b-6da8d70e5e0f
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src

Once capturing is done and I have some time, the captured notes should be scheduled and moved to the appropriate places (refiled). All the captured tasks are tagged =:INBOX:= (default tag in =inbox.org=) and can be viewed in special agenda view. The agenda has 3 groups of tasks: with deadline, scheduled, not scheduled without deadline.
First, I schedule/set deadline for all the tasks, where needed. Secondly, I set the priorities (=#A= will be always shown focused agenda). Lastly, I refile the tasks into the right projects.

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-cache t)
(setq org-refile-targets (quote ((nil :maxlevel . 9)
				 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)
					; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC

The most time consuming part of refiling is selecting the right subtree. Yes, I use helm, but it is not enough - there are too many things in my org files. Hence, I limit the refile targets to projects, which are not finished.

Occasionally, I need to add subtask to the existing task, which is not a project.

*************** TODO Change global binding in =helm-map=, it does not make sense in place, other than org mode completion
*************** END

#+begin_src emacs-lisp
(defvar refile-to-tasks nil
  "Non nil means, that single tasks will be included into refile candidates.")

(defun yant/toggle-refile-to-tasks ()
  "Toggle refiling into single tasks."
  (interactive)
  (setq refile-to-tasks (not refile-to-tasks))
  (setq org-refile-cache nil); reset refile cache
  (if refile-to-tasks (message "Refiling to tasks") (message "Not refiling to tasks")))

(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-mode-map)
(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks org-agenda-mode-map)
(bind-key "C-c C-S-w" #'yant/toggle-refile-to-tasks helm-map)

(defun yant/verify-refile-target ()
  "Exclude tasks and todo keywords with a done state from refile targets."
  (and (or refile-to-tasks
	   (not (bh/is-task-p)))
       (not (member (nth 2 (org-heading-components)) org-done-keywords))))

(setq org-refile-target-verify-function 'yant/verify-refile-target)
#+end_src

*************** TODO Integrate with helm refile
*************** END


**** =__epilogue=
:PROPERTIES:
:ID:       2e6f7380-707a-4ff9-992c-4992377ae1ee
:END:
#+begin_src emacs-lisp
)
#+end_src
*** TODO Export
:PROPERTIES:
:ID:       24d7f8cf-7729-4a05-a09d-bac24ab101b5
:END:
- I do regular export in separate script since it takes a lot of time and hangs Emacs.
- Do not run babel blocks during export
  #+begin_src emacs-lisp
(setq org-export-default-inline-image-rule '(("file" . "\\.\\(gif\\|jp\\(?:e?g\\)\\|p\\(?:bm\\|gm\\|ng\\|pm\\)\\|tiff?\\|x\\(?:[bp]m\\)\\)\\'")))
  #+end_src
  #+begin_src emacs-lisp
(setq org-export-use-babel nil)
  #+end_src
**** Ignore some headlines in a sense that it will not be exported as =\section=. 
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:17]
:ID:       e345057c-cd79-4e89-8ecc-ed81473804f1
:END:
Sometimes, I want to have a headline, but do not want it to be exported as a section, while its text should still be exported.
It is especially useful when writing papers.
I mark such a headlines with =:ignore:= tag.
The subheadings below such a headlines are promoted up *1 level*.

#+BEGIN_SRC emacs-lisp
(use-package ox-extra
:ensure nil
:config
(ox-extras-activate '(ignore-headlines)))

;; (defun yant/org-export-suppress-some-sections (data backend channel)
;;   "Do not put \\section for headlines with :NOSECEXPORT: tag."
;;   (let* ((parent (get-text-property (- (string-match "$" data) 2) :parent data))
;; 	 (headline (and parent (cadr parent)))
;;          (tags (and headline (plist-get headline :tags))))
;;     (when (and (member "NOSECEXPORT" tags)
;; 	       (not (member "SPECIALSECEXPORT" tags)))
;;       (replace-regexp-in-string "\\`.*$" "" data))))

;; (add-to-list 'org-export-filter-headline-functions 'yant/org-export-suppress-some-sections)
#+END_SRC
**** pdf
:PROPERTIES:
:ID:       6fb7a08a-ed44-46e5-aee3-82f76003de4a
:END:
#+begin_src emacs-lisp
(setq org-export-exclude-tags '("NOEXPORT"))
(setq org-latex-pdf-process
      (quote
       ;; ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ("latexmk -shell-escape -bibtex -f -pdf -output-directory=%o %f" "/home/yantar92/bin/pdf-compress.sh %b.pdf %b-compressed.pdf && mv -f %b-compressed.pdf %b.pdf")
       ))
(setq org-export-with-timestamps nil)
(setq org-export-in-background nil)
#+end_src
***** Default settings
:PROPERTIES:
:CREATED:  [2018-03-27 Tue 15:16]
:ID:       1bf4b848-2cac-4d11-a23d-a9b7cf4bcacb
:END:
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-header
      "
        \\documentclass{article}
        \\usepackage[usenames]{color}
        [PACKAGES]
        [DEFAULT-PACKAGES]
        \\pagestyle{empty}             % do not remove
        % The settings below are copied from fullpage.sty
        \\setlength{\\textwidth}{\\paperwidth}
        \\addtolength{\\textwidth}{-3cm}
        \\setlength{\\oddsidemargin}{1.5cm}
        \\addtolength{\\oddsidemargin}{-2.54cm}
        \\setlength{\\evensidemargin}{\\oddsidemargin}
        \\setlength{\\textheight}{\\paperheight}
        \\addtolength{\\textheight}{-\\headheight}
        \\addtolength{\\textheight}{-\\headsep}
        \\addtolength{\\textheight}{-\\footskip}
        \\addtolength{\\textheight}{-3cm}
        \\setlength{\\topmargin}{1.5cm}
        \\addtolength{\\topmargin}{-2.54cm}
        ")
(setq org-latex-classes
      (quote
       (("beamer" "\\documentclass[presentation]{beamer}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("article" "\\documentclass[11pt]{article}"
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	 ("\\paragraph{%s}" . "\\paragraph*{%s}")
	 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
	("report" "\\documentclass[11pt]{report}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
	("book" "\\documentclass[11pt]{book}"
	 ("\\part{%s}" . "\\part*{%s}")
	 ("\\chapter{%s}" . "\\chapter*{%s}")
	 ("\\section{%s}" . "\\section*{%s}")
	 ("\\subsection{%s}" . "\\subsection*{%s}")
	 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))))
(setq org-latex-default-packages-alist
      (quote
       (("utf8" "inputenc" t)
	("T1" "fontenc" t)
	("" "longtable" nil)
	("" "float" nil)
	("" "wrapfig" nil)
	("" "rotating" nil)
	("normalem" "ulem" t)
	("" "amsmath" t)
	("" "textcomp" t)
	("" "marvosym" t)
	("" "wasysym" t)
	("" "amssymb" t)
	("" "hyperref" nil)
	("" "graphicx" t)
	("" "underscore" t)
	("russian" "babel" t)
	("" "epstopdf" t)
	("extendedchars" "grffile" t)
	"
      	 \\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 `dirname #1`/`basename #1`.tif`-tif-converted-to.png}
      	 \\AppendGraphicsExtensions{.tif}
      	 \\usepackage{enumitem}
      	 \\setlistdepth{10}
      	 \\setlist[itemize,1]{label=$\\bullet$}
      	 \\setlist[itemize,2]{label=$\\bullet$}
      	 \\setlist[itemize,3]{label=$\\bullet$}
      	 \\setlist[itemize,4]{label=$\\bullet$}
      	 \\setlist[itemize,5]{label=$\\bullet$}
      	 \\setlist[itemize,6]{label=$\\bullet$}
      	 \\setlist[itemize,7]{label=$\\bullet$}
      	 \\setlist[itemize,8]{label=$\\bullet$}
      	 \\setlist[itemize,9]{label=$\\bullet$}
      	 \\setlist[itemize,10]{label=$\\bullet$}
      	 \\renewlist{itemize}{itemize}{10}
      	 \\setlist[enumerate,1]{label=$\\bullet$}
      	 \\setlist[enumerate,2]{label=$\\bullet$}
      	 \\setlist[enumerate,3]{label=$\\bullet$}
      	 \\setlist[enumerate,4]{label=$\\bullet$}
      	 \\setlist[enumerate,5]{label=$\\bullet$}
      	 \\setlist[enumerate,6]{label=$\\bullet$}
      	 \\setlist[enumerate,7]{label=$\\bullet$}
      	 \\setlist[enumerate,8]{label=$\\bullet$}
      	 \\setlist[enumerate,9]{label=$\\bullet$}
      	 \\setlist[enumerate,10]{label=$\\bullet$}
      	 \\renewlist{enumerate}{enumerate}{10}
      	 "
	"\\tolerance=1000"
	)))

#+END_SRC
**** html
:PROPERTIES:
:ID:       cc464b8f-4be1-4463-99bc-9f1d1c9a138f
:END:
#+begin_src emacs-lisp
(setq org-html-inline-image-rules '(("file"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|tif\\)\\'")
				    ("http"  . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")
				    ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\)\\'")))
#+end_src
**** md
:PROPERTIES:
:ID:       51a2db82-731b-4daf-bea9-dbcca50bc4e8
:END:
#+begin_src emacs-lisp 
(use-package ox-md)
#+end_src
*** Archiving
:PROPERTIES:
:ID:       85dadb9c-2a7e-47cf-ba98-a0e73377653d
:END:
I usually archive =DONE= tasks, which were done last month or earlier. They are shown in my [[id:d110dae9-f563-48bb-8293-a10b1afbe772][GTD self-check]] agenda view. These are usually small tasks like =TODO Contact someone=. There is no need to keep them.

In the case if I want to keep the task and notes, I just add =:NOARCHIVE:= tag to it.
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::datetree/* Archived Tasks")
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving."
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (subtree-end (save-excursion (org-end-of-subtree t)))
           (next-item (if (member "ARCHIVEALL" (org-get-tags-at))
			  subtree-end ; do not archive subtasks
			next-headline)))
      (if (member "NOARCHIVE" (org-get-tags-at))
	  subtree-end
	(if (member (org-get-todo-state) org-done-keywords)
	    (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
		   (a-month-ago (* 60 60 24 (+ daynr 1)))
		   (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
		   (this-month (format-time-string "%Y-%m-" (current-time)))
		   (subtree-is-current (save-excursion
					 (forward-line 1)
					 (and (< (point) subtree-end)
					      (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
	      (if subtree-is-current
		  next-item ; Has a date in this month or last month, skip it
		nil))  ; available to archive
	  next-item)))))
#+end_src

Inline tasks cannot be archived for now ([2017-12-29 Fri]), so, I override standard archiving function to make them archivable (into separate location =org-inlinetask-archive-location=)
#+BEGIN_SRC emacs-lisp
(defvar org-inlinetask-archive-location "%s_archive::datetree/* Archived inline tasks"
  "Where to archive inline tasks.")
(defvar org-inlinetask-max-level 100
  "Maximum level for inline task to be archived.")

(define-advice org-archive-subtree (:around (oldfunc &rest args) org-archive-inline-task)
  "Archive inline tasks according to `org-inlinetask-archive-location'."
  (if (boundp 'org-inlinetask-min-level)
      (let* ((org-inlinetask-min-level-real org-inlinetask-min-level)
	     (at-inline-task (org-inlinetask-in-task-p))
	     (org-inlinetask-min-level (if at-inline-task
					   org-inlinetask-max-level
					 org-inlinetask-min-level))
	     (org-archive-location (if at-inline-task
				       org-inlinetask-archive-location
				     org-archive-location))
	     (org-archived-inlinetask-point (point)))
	(apply oldfunc args))
    (apply oldfunc args)))

;; It is needed to cut inlinetask properly (remove trailing "***... END")
(add-hook 'org-archive-hook (lambda () (when (boundp 'org-inlinetask-min-level-real)
				    (setq org-inlinetask-min-level org-inlinetask-min-level-real))))

(define-advice org-archive-subtree (:after (&rest args) org-archive-inline-task-keep-point)
  "Keep the point after archiving inline task."
  (when (boundp 'org-archived-inlinetask-point)
    (goto-char org-archived-inlinetask-point)))
#+END_SRC

Sometimes, I have a small projects, where I do not want to decide whether I want to archive every single subtask or not. I tag them =:ARCHIVEALL:=.

Thanks God, I do not need to open my archive file frequently - my =TODO.org_archive= is =>1Mba= and takes forever to open. I am not sure if I need to do something with it.
*************** HOLD Speed up opening large org files                     :HOLD:
SCHEDULED: <2018-10-11 Thu>
:LOGBOOK:
- State "HOLD"       from "TODO"          [2017-12-22 Fri 22:01] \\
  Consider it if it becomes annoying
:END:
*************** END


*** Preview
:PROPERTIES:
:ID:       a85d2993-1d90-40b3-b69a-52cf7d6bd18b
:END:
#+begin_src emacs-lisp
(when init-flag
#+end_src
Preview images and latex formulas.
#+begin_src emacs-lisp
(setq org-image-actual-width '(400))
(setq org-latex-create-formula-image-program 'imagemagick)
'(org-format-latex-options
  (quote
   (:foreground default :background default :scale 2.0 :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers
		("begin" "$1" "$" "$$" "\\(" "\\[")))); 2x height of formulas
(setq org-latex-inline-image-rules
      (quote
       (("file" . "\\.\\(jpeg\\|jpg\\|png\\|eps\\|tikz\\|pgf\\|svg\\|bmp\\|tif\\)\\'"))))
#+end_src
**** =__epilogue=
:PROPERTIES:
:ID:       153a637e-68b2-40fd-b75f-5fea92bcc071
:END:
#+begin_src emacs-lisp
)
#+end_src
*** Babel
:PROPERTIES:
:ID:       b11124c4-3bad-445e-b8d1-8f2a61471da5
:END:
#+begin_src emacs-lisp
(bind-key "C-c C-b" 'org-edit-special org-mode-map)
(bind-key "C-c C-b" 'org-edit-src-exit org-src-mode-map)
(add-to-list 'org-default-properties "header-args")
#+end_src
**** Default arguments
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:58]
:ID:       27e1a878-35c8-4023-8881-645393db0274
:END:
- =Noweb= is useful, I'd rather enable it everywhere than set it every time to run the code
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args '((:session . "none")
				      (:results . "replace")
                                      (:exports . "code")
                                      (:cache . "no")
                                      (:noweb . "yes")
                                      (:hlines . "no")
                                      (:tangle . "no")
                                      (:comments . "link")
                                      (:eval . "never-export")))
#+END_SRC
**** Backends
:PROPERTIES:
:ID:       397b6a12-0a2f-4d05-9c76-9735314434fa
:END:
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "~/.emacs.d/site-lisp/ditaa.jar")
;; (setq org-babel-mathematica-command "mash.pl")
;; (use-package ob-async)
(org-babel-do-load-languages 'org-babel-load-languages
			     '(
			       (shell .t)
			       (emacs-lisp . t)
			       (org . t)
			       (perl . t)
			       (python .t)
			       (C . t)
			       (ditaa . t)
			       (gnuplot . t)
			       (calc . t)
			       (dot . t)
			       (latex . t)
			       (mathematica . t)
			       ))
(use-package wolfram-mode
  :if init-flag
  :defer t
  :init
  (add-to-list 'org-src-lang-modes '("mathematica" . "wolfram")))
#+end_src
**** TODO Evaluation
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 18:03]
:ID:       49900f8e-cde9-4e41-944a-904852ad92b9
:END:
:LOGBOOK:
- State "TODO"       from              [2018-07-11 Wed 09:19]
:END:
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
I hate when org is cluttering org file directory with generated files (=:file=). It is better to save everything inside hidden entry's attachment folder instead. I just redefine =default-directory= before
=org-babel-execute-src-block=, so that =:dir= or =:output-dir= can be still set if needed.

*************** TODO we cannot do it using default-directory because expand-file-name is going recursive if org-babel-execute-src-block calls expand-file-name inside
*************** END

#+BEGIN_SRC emacs-lisp :tangle no
(define-advice org-babel-execute-src-block (:around (OLDFUN &rest args) set-detault-dir-to-org-attach-path)
  "Set default-directory to the current entry's attach directory."
  (if (eq major-mode 'org-mode)
      (let ((default-directory (file-name-as-directory (org-attach-dir 'create-if-none))))
	(apply OLDFUN args))
    (apply OLDFUN args)))
#+END_SRC

Also, it make sense to show inline images, which I frequently generate via gnuplot after the evaluation
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC

**** TODO Tangle
I have a lot of small scripts and programs written at some point for some purpose I do not remember anymore. Hence, I prefer to use org files instead of all kinds of script files in the system. There are few things, which I need to make it work comfortably:
 - make sure that the script are tangled when I save org file, because it is easy to forget tangling of some files after editing.
*************** TODO Auto tangle on save
*************** END
**** Export
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 15:47]
:END:
Frequently, I run heavy analytical code as a part of my project. I it totally inconvenient to run these hour longing codes during export. Hence, I [[id:27e1a878-35c8-4023-8881-645393db0274][disable]] babel evaluation on export by default.
*** Appearance
**** Org indent mode
:PROPERTIES:
:ID:       da9f0439-e518-4166-8395-0e026d7871d8
:END:
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
#+END_SRC
**** Links
***** Show broken links to files
:PROPERTIES:
:ID:       df5b9cb0-e3d1-406e-b71f-55a7b90c221e
:END:
#+begin_src emacs-lisp
(org-link-set-parameters
 "file"
 :face (lambda (path) (if (file-exists-p (org-link-unescape path)) 'org-link 'org-warning)))
#+end_src
**** Items
:PROPERTIES:
:ID:       6b238696-fbbe-4206-91fb-eeebff4a032a
:END:
- I do not want bigger items font because I tend to use items a lot
  #+begin_src emacs-lisp
(custom-set-faces
 '(org-level-1 ((t (:inherit outline-1 :height 1.0))))
 '(org-level-2 ((t (:inherit outline-2 :height 1.0))))
 '(org-level-3 ((t (:inherit outline-3 :height 1.0))))
 '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
 '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
 )
  #+end_src
  - prefer bullets instead of stars in items
    #+begin_src emacs-lisp
(use-package org-bullets
  :disabled t
  :ensure t
  :config
  (setq org-bullets-bullet-list '("⁂" "•" "⊢" "⋮" "⋱" "⋱" "⋱"))
  (add-hook 'org-mode-hook
	    '(lambda () (org-bullets-mode 1))
	    'append))
    #+end_src
  - prefer to replace default =...= by something more distinct if item is folded
    #+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵")
(set-face-underline 'org-ellipsis nil)
    #+END_SRC
  - no blanks in items
      #+begin_src emacs-lisp
;;turn off blanks in a new entries
(setq org-blank-before-new-entry (quote ((heading)
					 (plain-list-item . auto))))
(setq org-cycle-separator-lines 0)
      #+end_src
  - hide emphasis markers 
      #+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
      #+end_src
  - keyword faces
      #+begin_src emacs-lisp
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
      	      ("NEXT" :foreground "blue" :weight bold)
      	      ("DONE" :foreground "forest green" :weight bold)
      	      ("FAILED" :foreground "red" :weight bold)
      	      ("WAITING" :foreground "orange" :weight bold)
      	      ("HOLD" :foreground "magenta" :weight bold)
      	      ("CANCELLED" :foreground "gray80" :weight bold))))
(use-package pretty-symbols
  :disabled t 
  :config
  (setq pretty-symbol-patterns (append pretty-symbol-patterns '((?▤ org-specific ":LOGBOOK:" (org-mode))
      								(?⚙ org-specific ":PROPERTIES:" (org-mode))
      								(?⏏ org-specific ":END:" (org-mode))
      								;; (?★ org-specific "\\[#A\\]" (org-mode))
      								;; ("" org-specific "\\[#B\\]" (org-mode))
      								;; (?☕ org-specific "\\[#C\\]" (org-mode))
      								((yant/str-to-glyph "☐") org-specific "\\(?:^*+ +\\)\\(\\<TODO\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "☑") org-specific "\\(?:^*+ +\\)\\(\\<DONE\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "✘") org-specific "\\(?:^*+ +\\)\\(\\<FAILED\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "✘") org-specific "\\(?:^*+ +\\)\\(\\<CANCELLED\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "▶") org-specific "\\(?:^*+ +\\)\\(\\<NEXT\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "⚑") org-specific "\\(?:^*+ +\\)\\(\\<WAITING\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "♲") org-specific "\\(?:^*+ +\\)\\(\\<HOLD\\>\\)" (org-mode) 1)
      								((yant/str-to-glyph "☠D") org-specific "\\<DEADLINE:" (org-mode))
      								((yant/str-to-glyph "◴S") org-specific "\\<SCHEDULED:" (org-mode))))))
(use-package org-fancy-priorities
  :disabled t
  :if init-flag
  :ensure t
  :hook 
  ((org-mode org-agenda-mode) . org-fancy-priorities-mode)
  :diminish org-fancy-priorities-mode
  :config
  (setq org-fancy-priorities-list '("★" "" "☕")))
      #+end_src
**** Agenda
:PROPERTIES:
:ID:       1c3c3255-10b3-401c-99cf-3edd91427475
:END:
#+begin_src emacs-lisp
(defun place-agenda-tags ()
  "Put the agenda tags by the right border of the agenda window."
  (setq org-agenda-tags-column (- 4 (window-width)))
  (org-agenda-align-tags))
(add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
(defadvice org-agenda (around split-vertically activate)
  (let ((split-width-threshold 1000))  ; or whatever width makes sense for you
    ad-do-it))
#+end_src
- do not highlight line below mouse
  #+begin_src emacs-lisp
(add-hook 'org-finalize-agenda-hook
	  (lambda () (remove-text-properties
		 (point-min) (point-max) '(mouse-face t))))
  #+end_src
- highlight current line in agenda
  #+begin_src emacs-lisp
(use-package hl-line
  :if init-flag

  :diminish global-hl-line-mode
  :config
  (progn
    (add-hook 'org-agenda-mode-hook
	      '(lambda () (hl-line-mode 1))
	      'append)
    )
  )
  #+end_src
- prefix for entries
  #+begin_src emacs-lisp
(setq org-agenda-scheduled-leaders '("* today" "* %2d d. ago"))
(defun yant/format-summary-for-agenda ()
  "Format the contents of :SUMMARY: property to show in agenda view."
  (let ((summary (org-entry-get (point) "SUMMARY" 'INHERIT)))
    (if summary
	(concat "\tComment: \"" summary "\"\n\t\t\t\t\t")
      "")))
(defun yant/format-time-balance-multiplier ()
  "Format :ORG-TIME-BALANCE-MULTIPLIER: into agenda."
  (let ((mult (when (and (org-at-heading-p)
			 (member (nth 2 (org-heading-components)) org-todo-keywords-for-agenda))
		(org-get-time-balance-multiplier-at-point))))
    (if mult
	(format "%sx" mult)
      "")))
(setq org-agenda-prefix-format "%-12s\t%-12.12:c\t%?-12t%(concat (yant/format-summary-for-agenda) (yant/format-time-balance-multiplier) \"\\t\")")
  #+end_src
**** Babel
:PROPERTIES:
:ID:       6fed68f0-c4ca-43f3-b487-4b58d9dc1315
:END:
#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t
      org-hide-block-startup t)
(set-face-background 'org-block "Gainsboro")
#+end_src
**** Symbols 
:PROPERTIES:
:ID:       aae027ae-a2b7-42b6-a833-cf038edcad3a
:END:
#+begin_src emacs-lisp 
(setq org-pretty-entities t)
(setq org-pretty-entities-include-sub-superscripts t)
#+end_src
*** Misc
:PROPERTIES:
:ID:       b195d9ea-e3e0-476e-b898-43b69fbd365d
:END:
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'error)
(setq org-M-RET-may-split-line '((default . nil)))
(setq org-startup-folded nil)
#+end_src

*** TODO Notmuch interaction
:PROPERTIES:
:ID:       e8fe1ace-9ddc-4bf1-8a89-a8e87c43a326
:END:
#+begin_src emacs-lisp
(use-package org-notmuch)
;; (use-package helm-notmuch
;;   :config
;;   (let (helm-source-notmuch-action (plist-get helm-source-notmuch :action))
;;     (plist-put helm-source-notmuch :action
;; 	       (add-to-list helm-source-notmuch-action '("Copy message link" . (lambda (id)
;; 										 (format "notmuch:%s" id)))))
;;     ))

(defun yant/add-email-to-task (&optional ARG)
  "Add an email into :EMAIL-SOURCE: property of the task.
       C-u argument means that we add the last link from link ring."
  (interactive)
  (if (not (eq ARG 4))
      (progn
	(bookmark-set "ADD-EMAIL-BKMRK")
	(bind-key "C-c l" '(lambda ()
			     (interactive)
			     (bind-key "C-c l" 'org-store-link)
			     (call-interactively 'org-store-link)
			     (bookmark-jump "ADD-EMAIL-BKMRK")
			     (yant/add-email-to-task 4)
			     )
		  )
	(notmuch-search "tag:todo"))
    (progn
      (let ((last-link (car (car org-stored-links)))
	    (last-description (cadr (car org-stored-links))))
	(if (string-match "^notmuch.*$" last-link)
	    (org-set-property "EMAIL-SOURCE" (concat "[[" last-link "][" last-description "]]"))
	  (message "Link \"%s\" is not a message link." last-link)))
      (yant/mark-linked-email-after-todo-state-change))))

(defun yant/mark-linked-email-after-todo-state-change ()
  "Remove inbox tag from a linked email :EMAIL-SOURCE: after the task is marked as finished."
  (let ((mystate (or (and (fboundp 'org-state)
			  state)
		     (nth 2 (org-heading-components))))
	(email-link (org-entry-get nil "EMAIL-SOURCE"))
        (done-keywords org-done-keywords))
    (when (not (or (not email-link)
		   (eq email-link "")))
      (progn
	(interactive)
	(org-open-link-from-string email-link)
	(switch-to-buffer (first (buffer-list)))
	(if (member mystate done-keywords)
	    (notmuch-show-tag-message "-inbox" "-todo" "-listinbox")
	  (if mystate
	      (notmuch-show-tag-message "-listinbox" "+inbox" "-todo")
	    (if (member "inbox" (notmuch-show-get-tags))
		(notmuch-show-tag-message "-listinbox" "+inbox" "+todo"))))
	(notmuch-bury-or-kill-this-buffer)))))
(add-hook 'org-after-todo-state-change-hook 'yant/mark-linked-email-after-todo-state-change 'append)
(add-hook 'org-capture-before-finalize-hook 'yant/mark-linked-email-after-todo-state-change 'append)
#+end_src
*** TODO Key combinations
:PROPERTIES:
:ID:       fe1a02aa-90fb-4ddb-9d04-925b08697e58
:EMAIL-SOURCE: [[notmuch:id:0100015f833663f9-95881448-4653-4709-a5bb-bfa94f3f0bff-000000@email.amazonses.com][Email from Amazon com: Leave Packaging Feedback for y]]
:END:
#+begin_src emacs-lisp
(bind-keys 
 ("C-c C-S-l" . org-store-link)
 ("C-c m" . org-capture)
 ("C-c c" . org-clock-goto)
 :map boon-goto-map
 ("a" . org-agenda)
 ("p" . references-open)
 ("t" . gtd-open)
 ("n" . notes-open)
 )
(bind-keys :map org-mode-map
	   ("C-c C-+" . add-current-buffer-to-agenda-files)
	   ("C-c C--" . remove-current-buffer-from-agenda-files)
	   ("C-c e" . yant/add-email-to-task) 
	   ("C-c i" . org-clock-in)
	   ("C-c o" . org-clock-out)
           :map org-agenda-mode-map
           ("s" . org-agenda-bulk-mark)
           ("S" . org-agenda-bulk-mark-all)
	   ("a" . org-agenda-bulk-unmark)
	   ("A" . org-agenda-bulk-unmark-all))
(use-package meta-functions
  :config
  (add-to-list 'meta-functions-meta-move-line-up-alist '(org-mode . org-metaup))
  (add-to-list 'meta-functions-meta-move-line-down-alist '(org-mode . org-metadown))
  (add-to-list 'meta-functions-meta-move-element-up-alist '(org-mode . org-shiftmetaup))
  (add-to-list 'meta-functions-meta-move-element-down-alist '(org-mode . org-shiftmetadown))
  (add-to-list 'meta-functions-meta-move-element-left-alist '(org-mode . org-shiftmetaleft))
  (add-to-list 'meta-functions-meta-move-element-right-alist '(org-mode . org-shiftmetaright))
  (add-to-list 'meta-functions-meta-move-line-left-alist '(org-mode . org-metaleft))
  (add-to-list 'meta-functions-meta-move-line-right-alist '(org-mode . org-metaright))
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(org-mode . org-insert-heading-respect-content))
  (add-to-list 'meta-functions-meta-insert-active-enclosure-new-line-alist '(org-mode . org-insert-todo-heading-respect-content))
  (add-to-list 'meta-functions-meta-new-line-alist '(org-mode . org-return))
  (defun yant/org-smart-meta-down-element ()
    "Move down org item if at heading, move down paragraph otherwise."
    (interactive)
    (if (org-at-heading-p)
	(call-interactively #'org-next-visible-heading)
      (forward-paragraph)))
  (defun yant/org-smart-meta-up-element ()
    "Move up org item if at heading, move up paragraph otherwise."
    (interactive)
    (if (org-at-heading-p)
	(call-interactively #'org-previous-visible-heading)
      (backward-paragraph)))  
  (add-to-list 'meta-functions-meta-down-element-alist '(org-mode . yant/org-smart-meta-down-element))
  (add-to-list 'meta-functions-meta-up-element-alist '(org-mode . yant/org-smart-meta-up-element))
  
  (add-to-list 'meta-functions-meta-move-line-up-alist '(org-struct-mode . org-metaup))
  (add-to-list 'meta-functions-meta-move-line-down-alist '(org-struct-mode . org-metadown))
  (add-to-list 'meta-functions-meta-move-element-up-alist '(org-struct-mode . org-shiftmetaup))
  (add-to-list 'meta-functions-meta-move-element-down-alist '(org-struct-mode . org-shiftmetadown))
  (add-to-list 'meta-functions-meta-move-element-left-alist '(org-struct-mode . org-shiftmetaleft))
  (add-to-list 'meta-functions-meta-move-element-right-alist '(org-struct-mode . org-shiftmetaright))
  (add-to-list 'meta-functions-meta-move-line-left-alist '(org-struct-mode . org-metaleft))
  (add-to-list 'meta-functions-meta-move-line-right-alist '(org-struct-mode . org-metaright))
  (add-to-list 'meta-functions-meta-insert-enclosure-new-line-alist '(org-struct-mode . org-insert-heading-respect-content))
  (add-to-list 'meta-functions-meta-insert-active-enclosure-new-line-alist '(org-struct-mode . org-insert-todo-heading-respect-content))
  (add-to-list 'meta-functions-meta-new-line-alist '(org-struct-mode . org-return))
  (add-to-list 'meta-functions-meta-up-alist '(org-agenda-mode . org-agenda-previous-line))
  (add-to-list 'meta-functions-meta-down-alist '(org-agenda-mode . org-agenda-next-line))
  (meta-functions-update-function-definitions))

#+end_src
*************** NEXT change =C-c e= to something proper
*************** END
**** Boon integration
:PROPERTIES:
:ID:       3bc88ae9-2346-4d9a-b50f-5e9970aa173a
:END:
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'boon-insert 'append)
#+end_src
*** =__finalize=
:PROPERTIES:
:ID:       8414a0fc-0456-4c19-a20d-cc20af9573be
:END:
#+begin_src emacs-lisp
)
#+end_src
** Sensitive info                                                  :NOEXPORT:
:PROPERTIES:
:ID:       83801f6a-daf5-4738-a15e-2d20c2b4551c
:END:
#+begin_src emacs-lisp
(org-babel-load-file "~/PersonalDocuments/emacs-personal.org")
#+end_src
** Magic - I have no clue why it works
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:50]
:END:
*** Strange error with =w3m-idle-timer=
:PROPERTIES:
:CREATED:  [2018-03-07 Wed 09:51]
:ID:       7ce2e20a-7f38-4cb2-9241-6bd1b7e10d39
:END:
#+BEGIN_SRC emacs-lisp
(setq w3m-image-no-idle-timer t)
#+END_SRC
** TODO Summary of key bindings
*** Command frequency measurement in emacs
:PROPERTIES:
:ID:       cd5dd0a5-e810-4846-91a3-ba5b6c649cdc
:END:
#+begin_src emacs-lisp
(use-package keyfreq
  :ensure t
  :config
  (define-globalized-minor-mode global-keyfreq-mode keyfreq-mode
    (lambda nil (progn (keyfreq-mode 1) (keyfreq-autosave-mode 1))))
  (global-keyfreq-mode))
#+end_src
